import{Lines as e,BinReader as t,Vec2 as r,Vec4 as a,Vec3 as n,Quat as s,Plane as i,Material as o,Color as d,Box2 as l,SystemDesc as c,Box3 as u,Xfo as _,BaseGeomItem as h,MaterialParameter as f,ColorParameter as m,TreeItem as v,GeomItem as g,Registry as p,AssetItem as S,FilePathParameter as y,BooleanParameter as x,Version as b,resourceLoader as L,GLMesh as C,GLLines as R,Mesh as T,GLTexture2D as A,GLRenderTarget as E,EventEmitter as D,GLFbo as B,Float32 as V,MathFunctions as w,GrowingPacker as G,shaderLibrary as I,GLShader as F,GLPass as P}from"@zeainc/zea-engine";const U={CURVE_TYPE_LINE:20,CURVE_TYPE_CIRCLE:21,CURVE_TYPE_ELIPSE:22,CURVE_TYPE_NURBS_CURVE:26},N={SURFACE_TYPE_PLANE:0,SURFACE_TYPE_CONE:1,SURFACE_TYPE_CYLINDER:2,SURFACE_TYPE_SPHERE:3,SURFACE_TYPE_TORUS:4,SURFACE_TYPE_LINEAR_EXTRUSION:5,SURFACE_TYPE_REVOLUTION:6,SURFACE_TYPE_NURBS_SURFACE:8,SURFACE_TYPE_OFFSET_SURFACE:9,SURFACE_TYPE_TRIMMED_RECT_SURFACE:10,SURFACE_TYPE_POLY_PLANE:14,SURFACE_TYPE_FAN:15,SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN:16},z=e=>{switch(e){case U.CURVE_TYPE_LINE:return"CURVE_TYPE_LINE";case U.CURVE_TYPE_CIRCLE:return"CURVE_TYPE_CIRCLE";case U.CURVE_TYPE_ELIPSE:return"CURVE_TYPE_ELIPSE";case U.CURVE_TYPE_NURBS_CURVE:return"CURVE_TYPE_NURBS_CURVE"}},X=e=>{switch(e){case N.SURFACE_TYPE_PLANE:return"SURFACE_TYPE_PLANE";case N.SURFACE_TYPE_CONE:return"SURFACE_TYPE_CONE";case N.SURFACE_TYPE_CYLINDER:return"SURFACE_TYPE_CYLINDER";case N.SURFACE_TYPE_SPHERE:return"SURFACE_TYPE_SPHERE";case N.SURFACE_TYPE_TORUS:return"SURFACE_TYPE_TORUS";case N.SURFACE_TYPE_LINEAR_EXTRUSION:return"SURFACE_TYPE_LINEAR_EXTRUSION";case N.SURFACE_TYPE_REVOLUTION:return"SURFACE_TYPE_REVOLUTION";case N.SURFACE_TYPE_NURBS_SURFACE:return"SURFACE_TYPE_NURBS_SURFACE";case N.SURFACE_TYPE_OFFSET_SURFACE:return"SURFACE_TYPE_OFFSET_SURFACE";case N.SURFACE_TYPE_TRIMMED_RECT_SURFACE:return"SURFACE_TYPE_TRIMMED_RECT_SURFACE";case N.SURFACE_TYPE_POLY_PLANE:return"SURFACE_TYPE_POLY_PLANE";case N.SURFACE_TYPE_FAN:return"SURFACE_TYPE_FAN";case N.SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN:return"SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN"}},M=8,Z=3,Y=8,O=9,W=8,k=8,K=8,H=2,Q=4,J=14,j=8,q=1,$=2,ee=16,te=32,re=64,ae=128,ne=256,se=512;class ie extends e{constructor(e=1,t=1){super(),this.__numSpansU=e-1,this.__numSpansV=t-1,this.__rebuild()}__rebuild(){this.setNumVertices((this.__numSpansU+1)*(this.__numSpansV+1)),this.setNumSegments(this.__numSpansU*(this.__numSpansV+1)+(this.__numSpansU+1)*this.__numSpansV);let e=0;for(let t=0;t<=this.__numSpansV;t++)for(let r=0;r<this.__numSpansU;r++){const a=(this.__numSpansU+1)*t+r,n=(this.__numSpansU+1)*t+(r+1);this.setSegmentVertexIndices(e,a,n),e++}for(let t=0;t<this.__numSpansV;t++)for(let r=0;r<=this.__numSpansU;r++){const a=(this.__numSpansU+1)*t+r,n=(this.__numSpansU+1)*(t+1)+r;this.setSegmentVertexIndices(e,a,n),e++}}}class oe{constructor(e,t){this.__cadAsset=e,this.__trimSetLibrary=t,this.__curveLibraryBuffer=void 0,this.__meshes=[],this.__hulls=[],this.__formFactors={},this.__maxNumKnots=0}setBinaryBuffers(e,r,a){if(this.__surfaceLibraryBuffer=r,this.cadDataVersion=a,this.__surfaceLibraryReader=new t(this.__surfaceLibraryBuffer),this.__surfaceLibrarySize=Math.sqrt(r.byteLength/8),this.__numSurfaces=this.__surfaceLibraryReader.loadUInt32(),this.__totalSurfaceArea=this.__surfaceLibraryReader.loadFloat32(),0==this.__totalSurfaceArea)for(let e=0;e<this.__numSurfaces;e++){const t=this.getSurfaceDims(e),r=t.sizeU*t.sizeV;this.__totalSurfaceArea+=r}this.__curveLibraryBuffer=e,this.__curveLibraryReader=new t(this.__curveLibraryBuffer),this.__curveLibrarySize=Math.sqrt(e.byteLength/8),this.__numCurves=this.__curveLibraryReader.loadUInt32()}getCurveBuffer(){return this.__curveLibraryBuffer}getSurfaceBuffer(){return this.__surfaceLibraryBuffer}getNumSurfaces(){return this.__numSurfaces}getNumCurves(){return this.__numCurves}getDetailFactor(e){return Math.pow(2,e)*this.__cadAsset.curvatureToDetail}getCurveDataTexelCoords(e){return this.__curveLibraryReader.seek(8+16*e),{x:this.__curveLibraryReader.loadFloat16(),y:this.__curveLibraryReader.loadFloat16()}}__seekCurveData(e,t=0){const r=this.getCurveDataTexelCoords(e),a=8*r.x+8*r.y*this.__curveLibrarySize;this.__curveLibraryReader.seek(a+t)}getCurveType(e){return this.__seekCurveData(e),this.__curveLibraryReader.loadFloat16()}getCurveTypeLabel(e){const t=this.getCurveType(e);return z(t)}getCurveDims(e){return this.__curveLibraryReader.seek(8+16*e),{addrX:this.__curveLibraryReader.loadFloat16(),addrY:this.__curveLibraryReader.loadFloat16(),curvature:this.__curveLibraryReader.loadFloat16(),length:this.__curveLibraryReader.loadFloat16(),flags:this.__curveLibraryReader.loadFloat16()}}getCurveData(e){const t=this.getCurveDims(e),n=this.getCurveType(e),s=new r(this.__curveLibraryReader.loadFloat16(),this.__curveLibraryReader.loadFloat16());switch(n){case U.CURVE_TYPE_LINE:return{curveId:e,dims:t,curveType:"CURVE_TYPE_LINE",domain:s};case U.CURVE_TYPE_CIRCLE:return{curveId:e,dims:t,curveType:"CURVE_TYPE_CIRCLE",domain:s,radius:this.__curveLibraryReader.loadFloat16()};case U.CURVE_TYPE_ELIPSE:return{curveId:e,dims:t,curveType:"SURFACE_TYPE_CYLINDER",domain:s,majorRadius:this.__curveLibraryReader.loadFloat16(),minorRadius:this.__curveLibraryReader.loadFloat16()};case U.CURVE_TYPE_NURBS_CURVE:{const r=this.__curveLibraryReader.loadFloat16(),n=this.__curveLibraryReader.loadFloat16(),i=this.__curveLibraryReader.loadFloat16();this.__curveLibraryReader.advance(4);const o=[];for(let e=0;e<n;e++){const e=new a(this.__curveLibraryReader.loadFloat16(),this.__curveLibraryReader.loadFloat16(),this.__curveLibraryReader.loadFloat16(),this.__curveLibraryReader.loadFloat16());o.push(e)}const d=[];for(let e=0;e<i;e++)d.push(this.__curveLibraryReader.loadFloat16());return{curveId:e,dims:t,curveType:"CURVE_TYPE_NURBS_CURVE",domain:s,degree:r,numCPs:n,controlPoints:o,knots:d}}default:console.warn("Invalid Curve Type:",n)}}getSurfaceDataTexelCoords(e){return this.__surfaceLibraryReader.seek(8+18*e),{x:this.__surfaceLibraryReader.loadUFloat16(),y:this.__surfaceLibraryReader.loadUFloat16()}}__seekSurfaceData(e,t=0){const r=this.getSurfaceDataTexelCoords(e),a=8*r.x+8*r.y*this.__surfaceLibrarySize;this.__surfaceLibraryReader.seek(a+t)}getSurfaceType(e){return this.__seekSurfaceData(e),this.__surfaceLibraryReader.loadFloat16()}getSurfaceTypeLabel(e){const t=this.getSurfaceType(e);return X(t)}getSurfaceDims(e){this.__surfaceLibraryReader.seek(8+18*e);return{addrX:this.__surfaceLibraryReader.loadUFloat16(),addrY:this.__surfaceLibraryReader.loadUFloat16(),curvatureU:this.__surfaceLibraryReader.loadFloat16(),curvatureV:this.__surfaceLibraryReader.loadFloat16(),sizeU:this.__surfaceLibraryReader.loadFloat16(),sizeV:this.__surfaceLibraryReader.loadFloat16(),flags:this.__surfaceLibraryReader.loadFloat16(),trimSetId:(()=>{if(this.cadDataVersion.lessThan([0,0,27])){return this.__surfaceLibraryReader.loadFloat16()+(this.__surfaceLibraryReader.loadFloat16()<<8)}return this.__surfaceLibraryReader.loadSInt32From2xFloat16()})()}}getSurfaceData(e,t=!0){const i=this.getSurfaceDims(e),o=this.getSurfaceType(e),d=()=>{const e=new l;return e.p0.x=this.__surfaceLibraryReader.loadFloat16(),e.p0.y=this.__surfaceLibraryReader.loadFloat16(),e.p1.x=this.__surfaceLibraryReader.loadFloat16(),e.p1.y=this.__surfaceLibraryReader.loadFloat16(),e};switch(i.trimSetId>=0&&t&&(i.trimSet=this.__trimSetLibrary.getTrimSetCurves(i.trimSetId)),o){case N.SURFACE_TYPE_PLANE:return{surfaceId:e,dims:i,surfaceType:"SURFACE_TYPE_PLANE",domain:d()};case N.SURFACE_TYPE_FAN:{const t=d(),a=[],n=i.curvatureU+1;for(let e=0;e<n;e++){const e=new r(this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16());a.push(e)}return{surfaceId:e,dims:i,surfaceType:"SURFACE_TYPE_FAN",domain:t,points:a}}case N.SURFACE_TYPE_CONE:return{surfaceId:e,dims:i,surfaceType:"SURFACE_TYPE_CONE",domain:d(),radius:this.__surfaceLibraryReader.loadFloat16(),semiAngle:this.__surfaceLibraryReader.loadFloat16()};case N.SURFACE_TYPE_CYLINDER:return{surfaceId:e,dims:i,surfaceType:"SURFACE_TYPE_CYLINDER",domain:d(),radius:this.__surfaceLibraryReader.loadFloat16()};case N.SURFACE_TYPE_SPHERE:return{surfaceId:e,dims:i,surfaceType:"SURFACE_TYPE_SPHERE",domain:d(),radius:this.__surfaceLibraryReader.loadFloat16()};case N.SURFACE_TYPE_TORUS:return{surfaceId:e,dims:i,surfaceType:"SURFACE_TYPE_TORUS",domain:d(),majorRadius:this.__surfaceLibraryReader.loadFloat16(),minorRadius:this.__surfaceLibraryReader.loadFloat16()};case N.SURFACE_TYPE_LINEAR_EXTRUSION:{const t=d();let r;const a=this.__surfaceLibraryReader.loadUFloat16(),o=this.__surfaceLibraryReader.loadUFloat16();r=a+2048*o;const l=this.getCurveData(r);return{surfaceId:e,dims:i,surfaceType:"SURFACE_TYPE_LINEAR_EXTRUSION",domain:t,curve_tr:new n(this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16()),curve_ori:new s(this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16()),curveData:l,partA:a,partB:o}}case N.SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN:case N.SURFACE_TYPE_REVOLUTION:{const t=d();let r;if(this.cadDataVersion.lessThan([0,0,27])){r=this.__surfaceLibraryReader.loadFloat16()+(this.__surfaceLibraryReader.loadFloat16()<<8)}else r=this.__surfaceLibraryReader.loadUInt32From2xUFloat16();return{surfaceId:e,dims:i,surfaceType:"SURFACE_TYPE_REVOLUTION",domain:t,curve_tr:new n(this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16()),curve_ori:new s(this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16()),curveData:this.getCurveData(r)}}case N.SURFACE_TYPE_NURBS_SURFACE:{const t=d(),r=this.__surfaceLibraryReader.loadFloat16(),n=this.__surfaceLibraryReader.loadFloat16(),s=this.__surfaceLibraryReader.loadFloat16(),o=this.__surfaceLibraryReader.loadFloat16(),l=this.__surfaceLibraryReader.loadFloat16(),c=this.__surfaceLibraryReader.loadFloat16(),u=this.__surfaceLibraryReader.loadFloat16(),_=0!=(1&u),h=0!=(2&u),f=[];for(let e=0;e<s*o;e++){const e=new a(this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16());f.push(e)}const m=[];for(let e=0;e<l;e++)m.push(this.__surfaceLibraryReader.loadFloat16());const v=[];for(let e=0;e<c;e++)v.push(this.__surfaceLibraryReader.loadFloat16());return{surfaceId:e,dims:i,surfaceType:"SURFACE_TYPE_NURBS_SURFACE",domain:t,periodicU:_,periodicV:h,degreeU:r,degreeV:n,numCPsU:s,numCPsV:o,controlPoints:f,knotsU:m,knotsV:v}}case N.SURFACE_TYPE_POLY_PLANE:return{surfaceId:e,dims:i,surfaceType:"SURFACE_TYPE_POLY_PLANE",points:[this.__surfaceLibraryReader.loadFloat16Vec2(),this.__surfaceLibraryReader.loadFloat16Vec2(),this.__surfaceLibraryReader.loadFloat16Vec2(),this.__surfaceLibraryReader.loadFloat16Vec2()]};default:{const t=this.getSurfaceType(e);console.warn("Invalid Surface Type:",t," surfaceId:",e)}}}findSpan(e,t,r,a){if(this.cadDataVersion.greaterOrEqualThan([0,0,6])){this.cadDataVersion;let n=r[0],s=n,i=1;const o=r.length-t-1;for(;i<o;i++){if(n+=r[i],i>t&&e<n){i--;break}s=n}i==o&&i--,a[t]=s;let d=s,l=s;for(let e=1;e<=t;e++)d-=r[i-e+1],l+=r[i+e],a[t-e]=d,a[t+e]=l;return i}}calcBasisValues(e,t,r,a){const n=[],s=[],i=[1];a[0]=0;for(let o=1;o<=t;++o){n[o]=e-r[t+1-o],s[o]=r[t+o]-e;let d=0;for(let e=0;e<o;++e){const t=s[e+1],r=n[o-e],a=i[e]/(t+r);i[e]=d+t*a,d=r*a}if(i[o]=d,o==t-1||1==t){d=0;for(let e=0;e<t;e++){const n=e+1,s=r[n+t],o=r[n],l=t*i[e]/(s-o);a[e]=d-l,d=l}a[t]=d}}return i}calcBasisDerivatives(e,t,r){const a=[],n=[];let s=0,i=0;const o=[];for(let e=0;e<=t;e++)o.push([]);o[0][0]=1;for(let d=1;d<=t;d++){a[d]=e-r[t+1-d],n[d]=r[t+d]-e,s=0;for(let e=0;e<d;e++){const t=n[e+1],r=a[d-e],l=t+r;o[d][e]=l,i=o[e][d-1]/l,o[e][d]=s+t*i,s=r*i}o[d][d]=s}const d=[[],[]];for(let e=0;e<=t;e++)d[0][e]=o[e][t];const l=[[],[]];for(let e=0;e<=t;e++)l[0].push(0),l[1].push(0);for(let e=0;e<=t;e++){let r=0,a=1;l[0][0]=1;{const n=1;let s=0;const i=e-n,c=t-n;let u=0,_=0;e>=n&&(l[a][0]=l[r][0]/o[c+1][i],s=l[a][0]*o[i][c]),u=i>=-1?1:-i,_=e-1<=c?n-1:t-e;for(let e=u;e<=_;e++)l[a][e]=(l[r][e]-l[r][e-1])/o[c+1][i+e],s+=l[a][e]*o[i+e][c];e<=c&&(l[a][n]=-l[r][n-1]/o[c+1][e],s+=l[a][n]*o[e][c]),d[n][e]=s;const h=r;r=a,a=h}}let c=t;{const e=1;for(let r=0;r<=t;r++)d[e][r]=d[e][r]*c;c*=t-e}return d}calcSurfacePoint(e,t){const r=e,a=Math.remap(t[0],0,1,r.domain.p0.x,r.domain.p1.x),s=Math.remap(t[1],0,1,r.domain.p0.y,r.domain.p1.y),i=[],o=this.findSpan(a,r.degreeU,r.knotsU,i),d=[],l=this.findSpan(s,r.degreeV,r.knotsV,d),c=[],u=this.calcBasisValues(a,r.degreeU,i,c),_=[],h=this.calcBasisValues(s,r.degreeV,d,_),f=new n(0,0,0),m=new n(0,0,0),v=new n(0,0,0);let g=0;const p=o-r.degreeU,S=l-r.degreeV;for(let e=0;e<=r.degreeV;++e){const t=S+e;for(let a=0;a<=r.degreeU;++a){const n=p+a,s=r.controlPoints[n+t*r.numCPsU],i=s.t,o=u[a],d=h[e],l=i*o*d;f.addInPlace(s.scale(l)),g+=l;const S=c[a],y=_[e];m.addInPlace(s.scale(S*d)),v.addInPlace(s.scale(o*y))}}0!=g&&!isNaN(g)&&isFinite(g)||console.warn("Unable to evaluate surface"),f.scaleInPlace(1/g);const y=i[r.degreeU+1]-i[r.degreeU],x=d[r.degreeV+1]-d[r.degreeV],b=(r.domain.p1.x-r.domain.p0.x)/r.knotsU.length,L=(r.domain.p1.y-r.domain.p0.y)/r.knotsV.length;if(y/b<.01){let e=p;e=s>r.domain.p1.y-1e-4?p+r.degreeU-2:p+1;const t=(a-d[r.degreeV])/x,n=S+Math.floor(t*r.degreeV),i=r.controlPoints[e+n*r.numCPsU].toVec3(),o=r.controlPoints[e+1+n*r.numCPsU].toVec3();m.setFromOther(o.subtract(i))}else if(m.length()<.05){let e;e=l>r.degreeV?S+r.degreeV-2:S+1;const t=(a-i[r.degreeU])/y,n=p+Math.floor(t*r.degreeU),s=r.controlPoints[n+e*r.numCPsU].toVec3(),o=r.controlPoints[n+1+e*r.numCPsU].toVec3();m.setFromOther(o.subtract(s))}if(x/L<.01){let e=S;e=s>r.domain.p1.y-1e-4?S+r.degreeV-2:S+1;const t=(a-i[r.degreeU])/y,n=p+Math.floor(t*r.degreeU),o=r.controlPoints[n+e*r.numCPsU].toVec3(),d=r.controlPoints[n+(e+1)*r.numCPsU].toVec3();v.setFromOther(d.subtract(o))}else if(v.length()<.05){let e=p;e=s>r.domain.p1.y-1e-4?p+r.degreeU-2:p+1;const t=(a-d[r.degreeV])/x,n=S+Math.floor(t*r.degreeV),i=r.controlPoints[e+n*r.numCPsU].toVec3(),o=r.controlPoints[e+(n+1)*r.numCPsU].toVec3();v.setFromOther(o.subtract(i))}return{pos:f,normal:m.cross(v).normalize()}}generatePolygonSurface(e,t=0){if(this.__meshes[e])return this.__meshes[e];if(this.getSurfaceType(e)!=N.SURFACE_TYPE_NURBS_SURFACE)return;const r=this.getSurfaceData(e);if(!r)return;const a=r.numCPsU*Math.pow(2,t),n=r.numCPsV*Math.pow(2,t);console.log("generatePolygonSurface:"+e+" M:"+a+" N:"+n);const s=new i(1,1,a,n),l=new Lines;l.setNumVertices((a+1)*(n+1)*2),l.setNumSegments((a+1)*(n+1));const c=l.getVertexAttribute("positions");let u=0;const _=s.getVertexAttribute("positions"),h=s.getVertexAttribute("normals");for(let e=0;e<=n;e++){const t=e/n;for(let e=0;e<=a;e++){const n=e/a,s=this.calcSurfacePoint(r,[n,t]);_.getValueRef(u).set(s.pos.x,s.pos.y,s.pos.z),h.getValueRef(u).set(s.normal.x,s.normal.y,s.normal.z),l.setSegmentVertexIndices(u,2*u,2*u+1),c.getValueRef(2*u).set(s.pos.x,s.pos.y,s.pos.z),c.getValueRef(2*u+1).set(s.pos.x+.2*s.normal.x,s.pos.y+.2*s.normal.y,s.pos.z+.2*s.normal.z),u++}}const f=new o("myMat","SimpleSurfaceShader");f.getParameter("BaseColor").setValue(d.random(.15)),s.material=f;const m=new o("myMat","FlatSurfaceShader");return m.getParameter("BaseColor").setValue(new d(1,0,0)),l.material=m,this.__meshes[e]=s,{mesh:s,normals:l}}generateHullGeometry(e){if(this.__hulls[e])return this.__hulls[e];if(this.getSurfaceType(e)!=N.SURFACE_TYPE_NURBS_SURFACE)return;const t=this.getSurfaceData(e);if(!t)return;console.log("generateHullGeometry:"+e+" numCPsU:"+t.numCPsU+" numCPsV:"+t.numCPsV);const r=new ie(t.numCPsU,t.numCPsV),a=r.getVertexAttribute("positions");let n=0;for(let e=0;e<t.numCPsV;e++)for(let r=0;r<t.numCPsU;r++){const s=r+e*t.numCPsU,i=t.controlPoints[s];a.getValueRef(n).set(i.x,i.y,i.z),n++}const s=new o("hullMaterial","FlatSurfaceShader");return s.getParameter("BaseColor").setValue(d.random(-.25)),r.material=s,this.__hulls[e]=r,r}dumpDebugSurfaces(){const e=[];for(let t=0;t<this.__numSurfaces;t++)try{e.push(this.getSurfaceData(t,!1))}catch(r){console.warn("Error accessing Surface: ",t,r),e.push({})}return e}dumpDebugCurves(){const e=[];for(let t=0;t<this.__numSurfaces;t++)try{e.push(this.getCurveData(t))}catch(r){console.warn("Error accessing Curve: ",t,r),e.push({})}return e}logFormfactors(){for(const e in this.__formFactors)console.log(e+":"+this.__formFactors[e])}}class de{constructor(){this.__reader=void 0}setBinaryBuffer(e,t){if(this.__reader=e,this.__numTrimSets=this.__reader.loadUInt32(),t.greaterThan([0,0,0]))this.__totalTrimSurfaceArea=this.__reader.loadFloat32();else{this.__totalTrimSurfaceArea=0;for(let e=0;e<this.__numTrimSets;e++){const t=this.getTrimSetDim(e),r=t[0]*t[1];this.__totalTrimSurfaceArea+=r}}const r=Math.sqrt(this.__totalTrimSurfaceArea),a=c.gpuDesc.maxTextureSize,n=a>>1,s=a>>2,i=a>>3,o=a>>4;this.__texelSizes=[r/o,r/i,r/s,r/n]}getBinaryBuffer(){return this.__reader?this.__reader.data:null}getNumTrimSets(){return this.__numTrimSets}getTrimArea(){return this.__totalTrimSurfaceArea}getTexelSize(e,t){let r;return r=t<2?3:t<6?2:1,this.__texelSizes[r]}getTrimSetDim(e){return this.__reader.seek(8+4*e),this.__reader.seek(this.__reader.loadUInt32()),[this.__reader.loadFloat32(),this.__reader.loadFloat32()]}getTrimSetCurves(e){this.__reader.seek(8+4*e),this.__reader.seek(this.__reader.loadUInt32());const t=this.__reader.loadFloat32(),r=this.__reader.loadFloat32(),a=this.__reader.loadUInt32(),n=this.__reader.loadUInt32(),s=()=>({id:this.__reader.loadFloat32(),xfo_tr:[this.__reader.loadFloat32(),this.__reader.loadFloat32()],xfo_rot:[this.__reader.loadFloat32(),this.__reader.loadFloat32(),this.__reader.loadFloat32(),this.__reader.loadFloat32()],flags:this.__reader.loadFloat32()}),i=[];for(let e=0;e<n;e++)i.push(s());const o=[];for(let e=0;e<a;e++){const e=[],t=this.__reader.loadUInt32();for(let r=0;r<t;r++)e.push(s());o.push(e)}return{size:[t,r],perimeter:i,holes:o}}dumpDebugTrimSets(){const e=[];for(let t=0;t<this.__numTrimSets;t++)try{e.push({dims:this.getTrimSetDim(t),curves:this.getTrimSetCurves(t)})}catch(r){console.warn("Error accessing TrimSet: ",t,r),e.push({})}return e}}class le{constructor(e){null!=e&&this.setBinaryBuffer(e)}setBinaryBuffers(e,r){this.__buffer=r,this.__reader=new t(this.__buffer),this.__size=Math.sqrt(r.byteLength/16),this.__toc=e,this.__tocReader=new t(e),this.__numBodies=this.__tocReader.loadUInt32()}getToc(){return this.__toc}getBinaryBuffer(){return this.__buffer}getNumBodies(){return this.__numBodies}getBodyDataTexelCoords(e){return this.__tocReader.seek(4+12*e),{x:this.__tocReader.loadUInt32(),y:this.__tocReader.loadUInt32()}}__seekBodyData(e,t=0){const r=this.getBodyDataTexelCoords(e),a=16*r.x+16*r.y*this.__size;this.__reader.seek(a+t)}getNumSurfacesForBody(e){return this.__seekBodyData(e,24),this.__reader.loadFloat32()}getBodyBBox(e){this.__seekBodyData(e);const t=new u;return t.p0=this.__reader.loadFloat32Vec3(),t.p1=this.__reader.loadFloat32Vec3(),t}getBodyDescData(e,t=!0){this.__seekBodyData(e);const r=new u;r.p0=this.__reader.loadFloat32Vec3(),r.p1=this.__reader.loadFloat32Vec3();const a=this.__reader.loadFloat32(),n=this.__reader.loadFloat32(),s=[];for(let e=0;e<a;e++)if(t){const e={surfaceId:this.__reader.loadFloat32()};e.xfo=new _(this.__reader.loadFloat32Vec3(),this.__reader.loadFloat32Quat(),this.__reader.loadFloat32Vec3()),e.color=this.__reader.loadRGBAFloat32Color(),s.push(e)}else s.push(this.__reader.loadFloat32()),this.__reader.advance(56);const i=[];for(let e=0;e<n;e++)if(t){const e={curveId:this.__reader.loadFloat32()};e.xfo=new _(this.__reader.loadFloat32Vec3(),this.__reader.loadFloat32Quat(),this.__reader.loadFloat32Vec3()),e.color=this.__reader.loadRGBAFloat32Color(),i.push(e)}else i.push(this.__reader.loadFloat32()),this.__reader.advance(56);return{bbox:r,surfaceRefs:s,curveRefs:i}}}class ce extends h{constructor(e,t){super(e),this.__bodyDescId=-1,this.__id=-1,this.__bodyBBox=new u,this.__cadAsset=t,this.__cadAsset&&this.__cadAsset.incCADBodyCount(),this.__materialParam=this.addParameter(new f("Material")),this.__colorParam=this.addParameter(new m("Color",new d(1,0,0,0)))}getCADAsset(){return this.__cadAsset}clone(e){const t=new ce;return t.copyFrom(this,e),t}copyFrom(e,t){super.copyFrom(e,t),this.__cadAsset=e.getCADAsset(),this.__cadAsset.incCADBodyCount(),this.setBodyDescId(e.getBodyDescId()),this.setMaterial(e.getMaterial())}getBodyDataTexelCoords(){return this.__cadAsset.getBodyLibrary().getBodyDataTexelCoords(this.__bodyDescId)}getBodyDescData(){const e=this.__cadAsset.getBodyLibrary().getBodyDescData(this.__bodyDescId);for(const t of e.surfaceRefs)t.surfaceType=this.__cadAsset.getSurfaceLibrary().getSurfaceTypeLabel(t.surfaceId),t.dims=this.__cadAsset.getSurfaceLibrary().getSurfaceDims(t.surfaceId);return e}getSurfaceRefs(){return this.getBodyDescData().surfaceRefs}getBodyDescId(){return this.__bodyDescId}setBodyDescId(e){this.__bodyDescId=e,this.__bodyBBox=this.__cadAsset.getBodyLibrary().getBodyBBox(this.__bodyDescId),this._setBoundingBoxDirty()}getMaterial(){return this.__materialParam.getValue()}setMaterial(e,t){this.__materialParam.setValue(e,t)}_cleanBoundingBox(e){return e=super._cleanBoundingBox(e),-1!=this.__bodyDescId&&e.addBox3(this.__bodyBBox,this.getParameter("GlobalXfo").getValue()),e}readBinary(e,t){if(super.readBinary(e,t),this.__cadAsset=t.assetItem,this.__cadAsset.incCADBodyCount(),this.setBodyDescId(e.loadUInt32()),t.versions["zea-cad"].lessThan([0,0,4])){const r=e.loadStr();let a=t.assetItem.getMaterialLibrary().getMaterial(r,!1);a||(a=new o(r,"SimpleSurfaceShader"),a.getParameter("BaseColor").setValue(d.random(.25)),t.assetItem.getMaterialLibrary().addMaterial(a)),this.getParameter("Material").setValue(a)}if(t.versions["zea-cad"].greaterOrEqualThan([0,0,2])&&t.versions["zea-cad"].lessThan([0,0,4])){this.__layers=e.loadStrArray();for(const e of this.__layers)t.addGeomToLayer(this,e)}}generatePolygonMeshSurfaces(e=0){const t=new v(this.getName());return this.getBodyDescData().surfaceRefs.forEach((r,a)=>{const n=this.__cadAsset.getSurfaceLibrary().generatePolygonSurface(r.surfaceId,e);if(n){const e=new g("Surface"+a+":"+r.surfaceId,n,n.material);e.getParameter("LocalXfo").setValue(r.xfo),t.addChild(e)}}),t}generateHullGeometry(){const e=new v(this.getName());return this.getBodyDescData().surfaceRefs.forEach((t,r)=>{const a=this.__cadAsset.getSurfaceLibrary().generateHullGeometry(t.surfaceId);if(a){const n=new g("Hull"+r+":"+t.surfaceId,a,a.material);return n.getParameter("LocalXfo").setValue(t.xfo),e.addChild(n),!1}}),e}toJSON(e=0){return super.toJSON(e)}fromJSON(e,t=0){super.fromJSON(e,t)}}p.register("CADBody",ce);const ue=new RegExp("\\.(stp|step|jt|3dm|ifc|vlcad|zcad)$","i");class _e extends S{constructor(e){super(e),this.__trimSetLibrary=new de,this.__surfaceLibrary=new oe(this,this.__trimSetLibrary),this.__bodyLibrary=new le,this.__atlasSize=new r,this.__numCADBodyItems=0,this.__loaded=!1,this.__datafileParam=this.addParameter(new y("DataFilePath")),this.__datafileParam.on("valueChanged",()=>{this.loadDataFile()}),this.addParameter(new x("Display Edges",!0)),this.addParameter(new m("Edge Color",new d(.1,.1,.1,.75))),this.lod=function(){const e=new URLSearchParams(window.location.search);if(e.has("lod"))return Number.parseInt(e.get("lod"));let t=e.get("file-id");t||(t=window.location.toString());let r=window.localStorage.getItem(t+"_LOD");if(window.localStorage.getItem(t+"_LOD"))r=Number.parseInt(window.localStorage.getItem(t+"_LOD"));else switch(c.deviceCategory){case"Low":r=1;break;case"Medium":r=2;break;case"High":r=3}return r}(),this.curvatureToDetail=.5}isLoaded(){return this.__loaded}getLOD(){return Math.max(0,this.lod)}incCADBodyCount(){this.__numCADBodyItems++}getNumBodyItems(){return this.__numCADBodyItems}getSurfaceLibrary(){return this.__surfaceLibrary}getTrimSetLibrary(){return this.__trimSetLibrary}getBodyLibrary(){return this.__bodyLibrary}getMaterialLibrary(){return this.__materials}getVersion(){return this.cadfileversion}readBinary(e,t={}){t.assetItem=this,this.__numCADBodyItems=0,t.versions={},t.versions["zea-cad"]=new b(e.loadStr()),t.cadSDK=e.loadStr(),this.cadfileversion=t.versions["zea-cad"],console.log("Loading CAD File version:",this.cadfileversion," exported using SDK:",t.cadSDK);const r=[];t.resolvePath=(e,t,a)=>{if(!e)throw new Error("Path not specified");const n=this.resolvePath(e);n?t(n):r.push(()=>{const r=this.resolvePath(e);r?t(r):a?a():console.warn("Path unable to be resolved:"+e)})},t.addPLCB=e=>r.push(e),super.readBinary(e,t);for(const e of r)e()}loadDataFile(){return this.__loadPromise||(this.__loadPromise=new Promise((e,r)=>{const a=this.__datafileParam.getFileDesc();if(!a)return void console.warn("CADAsset data file not found.");const n=this.__datafileParam.getValue(),s=r=>{const a=new t((r.tree2||r.tree).buffer,0,c.isMobileDevice);r.bodies&&this.__bodyLibrary.setBinaryBuffers(r.bodiestoc.buffer,r.bodies.buffer);const s=this.getName();this.readBinary(a,{}),""!=s&&this.setName(s);const i={versions:{}};if(i.versions["zea-cad"]=this.getVersion(),i.versions["zea-engine"]=this.getEngineDataVersion(),r.geoms&&this.__geomLibrary.readBinaryBuffer(n,r.geoms.buffer,i),r.trimSets){const e=r.trimSets||r.trimsets||r.trimSets2,a=new t(e.buffer,0,c.isMobileDevice);this.__trimSetLibrary.setBinaryBuffer(a,this.getVersion())}r.curves&&this.__surfaceLibrary.setBinaryBuffers(r.curves.buffer,r.surfaces.buffer,this.getVersion()),this.__datafileLoaded?this.__datafileLoaded():this.emit("loaded"),this.__loaded=!0,e()};if(a.metadata&&a.metadata.ConvertFile){let e;const t=new RegExp("\\.(vlcad|zcad)$","i");a.metadata.ConvertFile.map(r=>{t.test(r.filename)&&(e=r)}),e?L.loadURL(n,e.url,s):console.warn("ConvertFile metadata contains no vla file.")}else a.url?L.loadUrl(n,a.url,s):console.warn("CADAsset unable to load file:",a)})),this.__loadPromise}toJSON(e,t){return super.toJSON(e,t)}fromJSON(e,t,r){const a=()=>{const a=v.LoadFlags.LOAD_FLAG_LOADING_BIN_TREE_VALUES;super.fromJSON(e,t,a,r),t.decAsyncCount(),this.__loaded||(this.emit("loaded"),this.__loaded=!0)};if(e.params&&e.params.DataFilePath){this.__datafileLoaded=a,t.incAsyncCount();const r=e.params.DataFilePath;delete e.params.DataFilePath,this.__datafileParam.fromJSON(r,t)}else a()}generatePolygonMeshSurfaces(e=0){const t=new v("surfaces"),r=a=>{a.getChildren().forEach(a=>{if(a instanceof ce){const r=a.generatePolygonMeshSurfaces(e),n=a.getParameter("GlobalXfo").getValue();r.getParameter("GlobalXfo").setValue(n),t.addChild(r)}else r(a)})};return r(this),surfaceLibrary.logFormfactors(),t}generateHullGeometry(){const e=new v("hull"),t=r=>{r.getChildren().forEach(r=>{if(r instanceof ce){const t=r.generateHullGeometry(),a=r.getParameter("GlobalXfo").getValue();e.getParameter("GlobalXfo").setValue(a),e.addChild(t)}else t(r)})};return t(this),surfaceLibrary.logFormfactors(),e}static get LOADSTATE(){return LOADSTATE}static supportsExt(e){return ue.test(e)}}p.register("CADAsset",_e);class he extends v{constructor(e){super(e)}clone(e){const t=new he;return t.copyFrom(this,e),t}toJSON(e,t=0){return super.toJSON(e,t)}fromJSON(e,t,r=0){super.fromJSON(e,t,r)}}p.register("CADAssembly",he);class fe extends e{constructor(e,t){super(),this.setNumSegments(e*t),this.setNumVertices(e*t*2);const r=this.getVertexAttribute("positions");for(let a=0;a<t;a++){const n=a/(t-1)-.5;for(let t=0;t<e;t++){const s=t/(e-1)-.5,i=a*e+t;r.getValueRef(2*i).set(s,n,0),r.getValueRef(2*i+1).set(s,n,1),this.setSegmentVertexIndices(i,2*i,2*i+1)}}}}class me extends T{constructor(e){super(),this.setNumVertices(e);const t=e-2;this.setFaceCounts([t]);for(let e=0;e<t;e++)this.setFaceVertexIndices(e,[0,e+1,e+2]);const r=this.getVertexAttribute("positions");for(let t=0;t<e;t++)r.getValueRef(t).set(t/e-.5,-.5,0)}}class ve{constructor(e){this.__gl=e,this.__drawCoordsArray=null,this.__drawCoordsBuffer=null,this.__drawCount=0,this.__bindAttr=(t,r,a,n,s,i=!0)=>{e.enableVertexAttribArray(t),e.vertexAttribPointer(t,r,a,!1,n,s),i&&e.vertexAttribDivisor(t,1)}}setDrawItems(e){this.__drawCoordsBuffer&&(this.__gl.deleteBuffer(this.__drawCoordsBuffer),this.__drawCoordsBuffer=null);const t=this.__gl;return this.__drawCoordsBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.__drawCoordsBuffer),t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW),this.__drawCount=e.length/4,this.__drawCount}addDrawItems(e){if(this.__drawCoordsArray){const t=new Float32Array(this.__drawCoordsArray.length+e.length);t.set(this.__drawCoordsArray),t.set(e,this.__drawCoordsArray.length),this.__drawCoordsArray=t}else this.__drawCoordsArray=e;this.__drawCoordsBuffer&&(this.__gl.deleteBuffer(this.__drawCoordsBuffer),this.__drawCoordsBuffer=null);const t=this.__gl;return this.__drawCoordsBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.__drawCoordsBuffer),t.bufferData(t.ARRAY_BUFFER,this.__drawCoordsArray,t.STATIC_DRAW),this.__drawCount+=e.length/4,this.__drawCount}getDrawCount(){return this.__drawCount}bind(e){if(0==this.__drawCount)return 0;const t=this.__gl;t.bindBuffer(t.ARRAY_BUFFER,this.__drawCoordsBuffer);const r=e.attrs;return this.__bindAttr(r.drawCoords.location,4,t.FLOAT,16,0),this.__drawCount}destroy(){this.__gl.deleteBuffer(this.__drawCoordsBuffer),this.__drawCoordsBuffer=null}}const ge={};class pe{constructor(e,t,r){if(this.__gl=e,0!=t&&0!=r||console.error("invalid GLSurfaceDrawSet:"+t+","+r),1==r){const a=t;ge[a]||(ge[a]=new C(e,new me(t))),this.__glgeom=ge[a],this.__numTris=t-2,this.__glnormalsgeom=new R(e,new fe(t,r)),this.key=a}else{const a=t+"x"+r;ge[a]||(ge[a]=new C(e,new i(1,1,t-1,r-1))),this.__glgeom=ge[a],this.__numTris=(t-1)*(r-1)*2,this.__glnormalsgeom=new R(e,new fe(t,r)),this.key=a}this.__quadDetail=[t-1,r-1],this.__freeIndices=[],this.__subSets={}}setDrawItems(e,t){this.__subSets[t]||(this.__subSets[t]=new ve(this.__gl));const r=this.__subSets[t].setDrawItems(e);return this.__numTris*r}addDrawItems(e,t){this.__subSets[t]||(this.__subSets[t]=new ve(this.__gl));const r=this.__subSets[t].addDrawItems(e);return this.__numTris*r}getDrawCount(e){return this.__subSets[e]?this.__subSets[e].getDrawCount():0}draw(e,t){const r=this.__subSets[t];if(!r)return;const a=this.__gl,n=e.unifs;n.quadDetail&&a.uniform2i(n.quadDetail.location,this.__quadDetail[0],this.__quadDetail[1]),this.__glgeom.bind(e);const s=r.bind(e);e.bindViewports(e.unifs,()=>{this.__glgeom.drawInstanced(s)})}drawNormals(e,t){if(!this.__glnormalsgeom)return;const r=this.__subSets[t];if(!r)return;const a=this.__gl,n=e.unifs;n.quadDetail&&a.uniform2i(n.quadDetail.location,this.__quadDetail[0],this.__quadDetail[1]),this.__glnormalsgeom.bind(e);const s=r.bind(e);e.bindViewports(e.unifs,()=>{this.__glnormalsgeom.drawInstanced(s)})}destroy(){this.__glnormalsgeom&&this.__glnormalsgeom.destroy();for(const e in this.__subSets){this.__subSets[e].destroy()}}}class Se extends e{constructor(e=1){super(),this.setNumVertices(e+1),this.setNumSegments(e);const t=this.getVertexAttribute("positions");for(let r=0;r<=e;r++)r<e&&this.setSegmentVertexIndices(r,r,r+1),t.getValueRef(r).set(r/e,0,0);this.emit("geomDataTopologyChanged")}}class ye{constructor(e){this.__gl=e,this.__drawCoordsArray=null,this.__drawCoordsBuffer=null,this.__drawCount=0,this.__bindAttr=(t,r,a,n,s,i=!0)=>{e.enableVertexAttribArray(t),e.vertexAttribPointer(t,r,a,!1,n,s),i&&e.vertexAttribDivisor(t,1)}}setDrawItems(e){this.__drawCoordsBuffer&&(this.__gl.deleteBuffer(this.__drawCoordsBuffer),this.__drawCoordsBuffer=null);const t=this.__gl;return this.__drawCoordsBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.__drawCoordsBuffer),t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW),this.__drawCount=e.length/4,this.__drawCount}addDrawItems(e){if(this.__drawCoordsArray){const t=new Float32Array(this.__drawCoordsArray.length+e.length);t.set(this.__drawCoordsArray),t.set(e,this.__drawCoordsArray.length),this.__drawCoordsArray=t}else this.__drawCoordsArray=e;this.__drawCoordsBuffer&&(this.__gl.deleteBuffer(this.__drawCoordsBuffer),this.__drawCoordsBuffer=null);const t=this.__gl;return this.__drawCoordsBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.__drawCoordsBuffer),t.bufferData(t.ARRAY_BUFFER,this.__drawCoordsArray,t.STATIC_DRAW),this.__drawCount+=e.length/4,this.__drawCount}getDrawCount(){return this.__drawCount}bind(e){if(0==this.__drawCount)return 0;const t=this.__gl;t.bindBuffer(t.ARRAY_BUFFER,this.__drawCoordsBuffer);const r=e.attrs;return this.__bindAttr(r.drawCoords.location,4,t.FLOAT,16,0),this.__drawCount}destroy(){this.__gl.deleteBuffer(this.__drawCoordsBuffer),this.__drawCoordsBuffer=null}}const xe={};class be{constructor(e,t){this.__gl=e,0==t&&console.error("invalid GLCurveDrawSet:"+t),xe[t]||(xe[t]=new R(e,new Se(t))),this.key=t,this.__glgeom=xe[t],this.__edgeDetail=t,this.__freeIndices=[],this.__subSets={},this.__numDrawItems=0}setDrawItems(e,t){return this.__subSets[t]||(this.__subSets[t]=new ye(this.__gl)),this.__subSets[t].setDrawItems(e),this.__numDrawItems+=e.length/2,this.__numDrawItems}addDrawItems(e,t){this.__subSets[t]||(this.__subSets[t]=new ye(this.__gl)),this.__numDrawItems+=this.__subSets[t].addDrawItems(e)}getDrawCount(e){return this.__subSets[e]?this.__subSets[e].getDrawCount():0}draw(e,t){const r=this.__subSets[t];if(!r)return;const a=this.__gl,n=e.unifs;n.edgeDetail&&a.uniform1i(n.edgeDetail.location,this.__edgeDetail),this.__glgeom.bind(e);const s=r.bind(e);e.bindViewports(e.unifs,()=>{this.__glgeom.drawInstanced(s)})}destroy(){this.__glnormalsgeom&&this.__glnormalsgeom.destroy();for(const e in this.__subSets){this.__subSets[e].destroy()}}}class Le{constructor(e,t,r,a){this.__gl=e,this.__cadpassdata=t,this.__surfacesLibrary=r,this.cadDataVersion=a;const n=this.__surfacesLibrary.getCurveBuffer(),s=Math.sqrt(n.byteLength/8);this.__cadpassdata.convertTo8BitTextures?this.__curveDataTexture=new A(e,{format:"RGBA",type:"UNSIGNED_BYTE",width:2*s,height:s,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,data:new Uint8Array(n)}):this.__curveDataTexture=new A(e,{format:"RGBA",type:"HALF_FLOAT",width:s,height:s,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,data:new Uint16Array(n)}),this.__bindAttr=(t,r,a,n,s,i=!0)=>{e.enableVertexAttribArray(t),e.vertexAttribPointer(t,r,e.FLOAT,!1,n,s),i&&e.vertexAttribDivisor(t,1)}}evaluateCurves(e,t,r,a){const n=t;if(0==n)return;const s=this.__gl;this.__curveAtlasLayoutTexture=new A(this.__gl,{format:"RGBA",type:"FLOAT",width:r[0],height:r[1],filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,data:e}),this.__curvesAtlasRenderTarget?this.__curvesAtlasRenderTarget.width==a[0]&&this.__curvesAtlasRenderTarget.height==a[1]||this.__curvesAtlasRenderTarget.resize(a[0],a[1],!0):(this.__curvesAtlasRenderTarget=new E(s,{format:"RGBA",type:"FLOAT",width:a[0],height:a[1],filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1}),this.__curvesTangentAtlasRenderTarget=new E(s,{format:"RGBA",type:"FLOAT",width:a[0],height:a[1],filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1}));const i={};this.__curvesAtlasRenderTarget.bindForWriting(i,!0),this.cadDataVersion.greaterThan([0,0,0])&&(i.shaderopts=Object.assign({},s.shaderopts),i.shaderopts.defines=i.shaderopts.defines+"#define EXPORT_KNOTS_AS_DELTAS 1"),this.cadDataVersion.greaterThan([0,0,26])&&(i.shaderopts.defines=i.shaderopts.defines+"#define INTS_PACKED_AS_2FLOAT16 1"),this.__cadpassdata.convertTo8BitTextures&&(i.shaderopts=Object.assign({},s.shaderopts),i.shaderopts.frag=Object.assign({},s.shaderopts.frag),i.shaderopts.frag.defines="#define DECODE_16BIT_FLOAT_FROM_8BIT_INT 1\n"),this.__cadpassdata.evaluateCurveShader.bind(i),this.__cadpassdata.glplanegeom.bind(i);const o=i.unifs,d=i.attrs;s.uniform2i(o.curvesAtlasTextureSize.location,this.__curvesAtlasRenderTarget.width,this.__curvesAtlasRenderTarget.height),this.__curveDataTexture.bindToUniform(i,o.curveDataTexture),s.uniform2i(o.curveDataTextureSize.location,this.__curveDataTexture.width,this.__curveDataTexture.height);const l=s.createBuffer();s.bindBuffer(s.ARRAY_BUFFER,l),s.bufferData(s.ARRAY_BUFFER,e,s.STATIC_DRAW),this.__bindAttr(d.patchCoords.location,4,s.FLOAT,32,0),this.__bindAttr(d.curveDataCoords.location,2,s.FLOAT,32,16),s.uniform1i(o.writeTangents.location,0),this.__cadpassdata.glplanegeom.drawInstanced(n),this.__curvesTangentAtlasRenderTarget.bindForWriting(i,!0),s.uniform1i(o.writeTangents.location,1),this.__cadpassdata.glplanegeom.drawInstanced(n),s.deleteBuffer(l),this.__curvesTangentAtlasRenderTarget.unbind(),s.finish()}bindCurvesAtlasLayout(e){const t=this.__gl,r=e.unifs;this.__curvesAtlasRenderTarget&&r.curvesAtlasLayoutTexture&&(this.__curveAtlasLayoutTexture.bindToUniform(e,r.curvesAtlasLayoutTexture),t.uniform2i(r.curvesAtlasLayoutTextureSize.location,this.__curveAtlasLayoutTexture.width,this.__curveAtlasLayoutTexture.height))}bindCurvesAtlas(e){const t=this.__gl,r=e.unifs;this.__curvesAtlasRenderTarget&&(this.__curvesAtlasRenderTarget.bindColorTexture(e,r.curvesAtlasTexture),r.curveTangentsTexture&&this.__curvesTangentAtlasRenderTarget.bindColorTexture(e,r.curveTangentsTexture),r.curvesAtlasTextureSize&&t.uniform2i(r.curvesAtlasTextureSize.location,this.__curvesAtlasRenderTarget.width,this.__curvesAtlasRenderTarget.height),r.curvesAtlasLayoutTexture&&(this.__curveAtlasLayoutTexture.bindToUniform(e,r.curvesAtlasLayoutTexture),t.uniform2i(r.curvesAtlasLayoutTextureSize.location,this.__curveAtlasLayoutTexture.width,this.__curveAtlasLayoutTexture.height)))}destroy(){this.__curveDataTexture.destroy(),this.__curveAtlasLayoutTexture&&(this.__curveAtlasLayoutTexture.destroy(),this.__curvesAtlasRenderTarget.destroy(),this.__curvesTangentAtlasRenderTarget.destroy())}}class Ce{constructor(e,t=0,r=!0){this.__data=e,this.__byteOffset=t,this.__dataView=new DataView(this.__data),this.__isMobileDevice=r,this.utf8decoder=new TextDecoder}get isMobileDevice(){return this.__isMobileDevice}get data(){return this.__data}get byteLength(){return this.__dataView.byteLength}get remainingByteLength(){return this.__dataView.byteLength-this.__byteOffset}pos(){return this.__byteOffset}seek(e){this.__byteOffset=e}advance(e){this.__byteOffset+=e}loadUInt8(){const e=this.__dataView.getUint8(this.__byteOffset);return this.__byteOffset+=1,e}loadUInt16(){const e=this.__dataView.getUint16(this.__byteOffset,!0);return this.__byteOffset+=2,e}loadUInt32(){const e=this.__dataView.getUint32(this.__byteOffset,!0);return this.__byteOffset+=4,e}loadSInt32(){const e=this.__dataView.getInt32(this.__byteOffset,!0);return this.__byteOffset+=4,e}loadFloat16(){return(e=>{const t=(32768&e)>>15,r=(31744&e)>>10,a=1023&e;return 0==r?(t?-1:1)*Math.pow(2,-14)*(a/Math.pow(2,10)):31==r?a?NaN:1/0*(t?-1:1):(t?-1:1)*Math.pow(2,r-15)*(1+a/Math.pow(2,10))})(this.loadUInt16())}loadUFloat16(){const e=this.loadFloat16();return e<0?2048-e:e}loadFloat16From2xUInt8(){const e=this.__dataView.getFloat16(this.__byteOffset,!0);return this.__byteOffset+=2,e}loadUInt32From2xUFloat16(){return this.loadUFloat16()+4096*this.loadUFloat16()}loadSInt32From2xFloat16(){return this.loadFloat16()+2048*this.loadFloat16()}loadFloat32(){const e=this.__dataView.getFloat32(this.__byteOffset,!0);return this.__byteOffset+=4,e}loadUInt8Array(e,t=!1){null==e&&(e=this.loadUInt32());const r=new Uint8Array(this.__data,this.__byteOffset,e);this.__byteOffset+=e;this.__byteOffset;return r}loadUInt16Array(e,t=!1){if(null==e&&(e=this.loadUInt32()),0==e)return new Uint16Array;let r;if(this.readPadd(2),this.__isMobileDevice){r=new Uint16Array(e);for(let t=0;t<e;t++)r[t]=this.__dataView.getUint16(this.__byteOffset,!0),this.__byteOffset+=2}else r=new Uint16Array(this.__data,this.__byteOffset,e),this.__byteOffset+=2*e;return r}loadUInt32Array(e,t=!1){if(null==e&&(e=this.loadUInt32()),0==e)return new Uint32Array;let r;if(this.readPadd(4),this.__isMobileDevice){r=new Uint32Array(e);for(let t=0;t<e;t++)r[t]=this.__dataView.getUint32(this.__byteOffset,!0),this.__byteOffset+=4}else r=new Uint32Array(this.__data,this.__byteOffset,e),this.__byteOffset+=4*e;return r}loadFloat32Array(e,t=!1){if(null==e&&(e=this.loadUInt32()),0==e)return new Float32Array;let r;if(this.readPadd(4),this.__isMobileDevice){r=new Float32Array(e);for(let t=0;t<e;t++)r[t]=this.__dataView.getFloat32(this.__byteOffset,!0),this.__byteOffset+=4}else r=new Float32Array(this.__data,this.__byteOffset,e),this.__byteOffset+=4*e;return r}loadStr(){const e=this.loadUInt32(),t=new Uint8Array(this.__data,this.__byteOffset,e);this.__byteOffset+=e;let r="";for(let a=0;a<e;a++)r+=String.fromCharCode(t[a]);return r}loadStrArray(){const e=this.loadUInt32(),t=[];for(let r=0;r<e;r++)t[r]=this.loadStr();return t}readPadd(e){const t=this.__byteOffset%e;0!=t&&(this.__byteOffset+=e-t)}}class Re extends D{constructor(e,t,r,a,n){super(),this.__gl=e,this.__cadpassdata=t,this.__surfacesLibrary=r,this.__glCurveLibrary=a,this.cadDataVersion=n;const s=this.__surfacesLibrary.getSurfaceBuffer(),i=Math.sqrt(s.byteLength/8);this.__cadpassdata.convertTo8BitTextures?this.__surfaceDataTexture=new A(e,{format:"RGBA",type:"UNSIGNED_BYTE",width:2*i,height:i,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,data:new Uint8Array(s)}):this.__surfaceDataTexture=new A(e,{format:"RGBA",type:"HALF_FLOAT",width:i,height:i,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,data:new Uint16Array(s)}),this.__bindAttr=(t,r,a,n,s,i=!0)=>{e.enableVertexAttribArray(t),e.vertexAttribPointer(t,r,e.FLOAT,!1,n,s),i&&e.vertexAttribDivisor(t,1)},this.__surfaceDrawSets={};const o=Object.assign({},this.__gl.shaderopts);this.cadDataVersion.greaterOrEqualThan([0,0,6])&&(o.defines=o.defines+"#define EXPORT_KNOTS_AS_DELTAS 1\n"),this.cadDataVersion.greaterThan([0,0,26])&&(o.defines=o.defines+"#define INTS_PACKED_AS_2FLOAT16 1"),this.__cadpassdata.convertTo8BitTextures&&(o.frag={defines:"#define DECODE_16BIT_FLOAT_FROM_8BIT_INT 1\n"}),this.__cadpassdata.evaluateSurfaceShaders.forEach(e=>{e.compileForTarget(void 0,o)})}drawSurfaceData(){const e={};if(!this.__surfaceDataTexture||!this.__cadpassdata.debugTrimSetsShader.bind(e))return!1;this.__surfaceDataTexture.bindToUniform(e,e.unifs.trimSetAtlasTexture),this.__cadpassdata.glplanegeom.bind(e),this.__cadpassdata.glplanegeom.draw()}evaluateSurfaces(e,t,r,a){const n=performance.now();if(0==t.length/8)return;const s=this.__gl;this.__surfaceAtlasLayoutTexture=new A(s,{format:"RGBA",type:"FLOAT",width:r[0],height:r[1],filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,data:t}),this.__surfacesAtlasTexture?this.__surfacesAtlasTexture.width==a[0]&&this.__surfacesAtlasTexture.height==a[1]||(this.__surfacesAtlasTexture.resize(a[0],a[1],!0),this.__surfacesFbo.resize()):(this.__surfacesAtlasTexture=new A(s,{format:"RGBA",type:"FLOAT",width:a[0],height:a[1],filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1}),this.__surfacesFbo=new B(s,this.__surfacesAtlasTexture),this.__surfacesFbo.setClearColor([0,0,0,0]),this.__surfacesFbo.bindAndClear(),this.__normalsTexture=new A(s,{format:"RGBA",type:"FLOAT",width:a[0],height:a[1],filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1}),this.__normalsFbo=new B(s,this.__normalsTexture),this.__normalsFbo.setClearColor([0,0,0,0]),this.__normalsFbo.bindAndClear());const i={};return e.forEach((e,t)=>{this.__cadpassdata.evaluateSurfaceShaders[t].bind(i),this.__cadpassdata.glplanegeom.bind(i);const r=i.unifs,a=i.attrs;this.__surfaceAtlasLayoutTexture.bindToUniform(i,r.surfaceAtlasLayoutTexture),s.uniform2i(r.surfaceAtlasLayoutTextureSize.location,this.__surfaceAtlasLayoutTexture.width,this.__surfaceAtlasLayoutTexture.height),s.uniform2i(r.surfacesAtlasTextureSize.location,this.__surfacesAtlasTexture.width,this.__surfacesAtlasTexture.height),this.__surfaceDataTexture.bindToUniform(i,r.surfaceDataTexture),s.uniform2i(r.surfaceDataTextureSize.location,this.__surfaceDataTexture.width,this.__surfaceDataTexture.height),r.curveTangentsTexture&&this.__glCurveLibrary.bindCurvesAtlas(i);const n=s.createBuffer();s.bindBuffer(s.ARRAY_BUFFER,n),s.bufferData(s.ARRAY_BUFFER,e,s.STATIC_DRAW),this.__bindAttr(a.surfaceId.location,1,s.FLOAT,4,0),this.__surfacesFbo.bind(),s.uniform1i(r.writeNormals.location,0),this.__cadpassdata.glplanegeom.drawInstanced(e.length),this.__normalsFbo.bind(),s.uniform1i(r.writeNormals.location,1),this.__cadpassdata.glplanegeom.drawInstanced(e.length),s.deleteBuffer(n)}),this.__surfacesFbo.unbind(),this.__surfacesAtlasLayout=t,performance.now()-n}logSurfaceData(e){const t=this.__surfacesLibrary.getSurfaceBuffer(),r=new Ce(t);r.seek(8+16*e+4);const a=r.loadFloat16(),n=r.loadFloat16(),s=r.loadFloat16(),i=r.loadFloat16(),o=r.loadFloat16();console.log("logGeomData "+e+" detailU:["+a+","+n+"] sizeU ["+s+","+i+"] trimSetIndex:"+o)}drawSurfaceAtlas(e){if(!this.__normalsTexture||!this.__cadpassdata.debugTrimSetsShader.bind(e))return!1;this.__normalsTexture.bindToUniform(e,e.unifs.trimSetAtlasTexture),this.__cadpassdata.glplanegeom.bind(e),this.__cadpassdata.glplanegeom.draw()}bindSurfacesData(e){const t=this.__gl,r=e.unifs;this.__surfaceDataTexture.bindToUniform(e,r.surfaceDataTexture),t.uniform2i(r.surfaceDataTextureSize.location,this.__surfaceDataTexture.width,this.__surfaceDataTexture.height)}bindSurfacesAtlas(e){if(!this.__surfacesAtlasTexture)return!1;const t=e.unifs;this.__surfacesAtlasTexture.bindToUniform(e,t.surfacesAtlasTexture);const r=this.__gl;return t.normalsTexture&&this.__normalsTexture.bindToUniform(e,t.normalsTexture),t.surfacesAtlasTextureSize&&r.uniform2i(t.surfacesAtlasTextureSize.location,this.__surfacesAtlasTexture.width,this.__surfacesAtlasTexture.height),t.numSurfacesInLibrary&&r.uniform1i(t.numSurfacesInLibrary.location,this.__surfacesLibrary.getNumSurfaces()),t.surfaceAtlasLayoutTexture&&(this.__surfaceAtlasLayoutTexture.bindToUniform(e,t.surfaceAtlasLayoutTexture),r.uniform2i(t.surfaceAtlasLayoutTextureSize.location,this.__surfaceAtlasLayoutTexture.width,this.__surfaceAtlasLayoutTexture.height)),!0}getSurfaceData(e){return this.__surfacesLibrary.getSurfaceData(e)}destroy(){this.__surfaceDataTexture.destroy(),this.__surfacesAtlasTexture&&(this.__surfacesAtlasTexture.destroy(),this.__normalsTexture.destroy(),this.__surfacesFbo.destroy(),this.__normalsFbo.destroy())}}class Te extends T{constructor(e=1){super(),this.__detail=e,this.addVertexAttribute("vertexIds",V),this.__rebuild()}__rebuild(){this.setNumVertices(this.__detail+2),this.setFaceCounts([this.__detail]);for(let e=0;e<this.__detail;e++)this.setFaceVertexIndices(e,[0,e+1,e+2]);const e=this.getVertexAttribute("vertexIds");for(let t=0;t<=e.length;t++)e.setFloat32Value(t,t)}}class Ae extends i{constructor(e=1){super(1,2,e,1,!1,!1)}__resize(){this.__sizeXParam.getValue();const e=this.__sizeYParam.getValue(),t=this.__detailXParam.getValue(),r=this.__detailYParam.getValue(),a=this.getVertexAttribute("positions");let n=0;for(let s=0;s<=r;s++){const i=(s/r-.5)*e;for(let e=0;e<=t;e++){const t=e;a.getValueRef(n).set(t,i,0),n++}}this.setBoundingBoxDirty()}}const Ee={};class De{constructor(e,t,r){this.__gl=e,this.__detail=t,Ee[t]||(Ee[t]={glfangeom:new C(e,new Te(t)),glstripgeom:new C(e,new Ae(t))}),this.__glfangeom=Ee[t].glfangeom,this.__glstripgeom=Ee[t].glstripgeom,this.__buffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.__buffer),e.bufferData(e.ARRAY_BUFFER,r,e.STATIC_DRAW),this.__drawCount=r.length/14}bindAttr(e,t,r,a,n){if(e<0)return;const s=this.__gl;s.enableVertexAttribArray(e),s.vertexAttribPointer(e,t,s.FLOAT,!1,a,n),s.vertexAttribDivisor(e,1)}setBuffer(){}drawFans(e){const t=this.__gl;this.__glfangeom.bind(e);const r=e.unifs,a=e.attrs;t.bindBuffer(t.ARRAY_BUFFER,this.__buffer),this.bindAttr(a.patchCoords.location,4,t.FLOAT,56,0),this.bindAttr(a.data0.location,4,t.FLOAT,56,16),this.bindAttr(a.data1.location,4,t.FLOAT,56,32),this.bindAttr(a.data2.location,2,t.FLOAT,56,48),t.uniform1i(r.numCurveVertices.location,this.__detail+1),this.__glfangeom.drawInstanced(this.__drawCount)}drawStrips(e){const t=this.__gl;this.__glstripgeom.bind(e);const r=e.unifs,a=e.attrs;t.bindBuffer(t.ARRAY_BUFFER,this.__buffer),this.bindAttr(a.patchCoords.location,4,t.FLOAT,56,0),this.bindAttr(a.data0.location,4,t.FLOAT,56,16),this.bindAttr(a.data1.location,4,t.FLOAT,56,32),this.bindAttr(a.data2.location,2,t.FLOAT,56,48),t.uniform1i(r.numCurveVertices.location,this.__detail+1),this.__glstripgeom.drawInstanced(this.__drawCount)}cleanup(){}}class Be{constructor(e,t,r,a){this.__gl=e,this.__cadpassdata=t,this.__trimSetLibrary=r,this.__glCurvesLibrary=a;const n=this.__trimSetLibrary.getBinaryBuffer(),s=Math.sqrt(n.byteLength/8);this.__trimSetsTexture=new A(e,{format:"RGBA",type:"HALF_FLOAT",width:s,height:s,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,data:new Uint16Array(n)}),this.__bindAttr=(t,r,a,n,s,i=!0)=>{e.enableVertexAttribArray(t),e.vertexAttribPointer(t,r,e.FLOAT,!1,n,s),i&&e.vertexAttribDivisor(t,1)},this.__trimCurveDrawSets={}}evaluateTrimSets(e,t,r,a){const n=this.__gl;if(this.__trimSetsAtlasLayoutTexture=new A(this.__gl,{format:"RGBA",type:"FLOAT",width:a[0],height:a[1],filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,data:r}),this.__trimSetAtlasTexture)this.__trimSetAtlasTexture.width==t[0]&&this.__trimSetAtlasTexture.height==t[1]||(this.__trimSetAtlasTextureSize=t,this.__trimSetAtlasTexture.resize(t[0],t[1],!0),this.__trimSetAtlasFbo.resize());else{this.__trimSetAtlasTextureSize=t,(this.__trimSetAtlasTextureSize[0]>this.__cadpassdata.maxTexSize||this.__trimSetAtlasTextureSize[1]>this.__cadpassdata.maxTexSize)&&console.warn("trimSetAtlas  is too big to fit in a texture. The image will be downsized:"+this.__trimSetAtlasTextureSize+" maxTexSize:"+this.__cadpassdata.maxTexSize),this.__trimSetAtlasMaskTexture=new A(n,{format:"webgl2"==n.name?"RG":"RGBA",type:"UNSIGNED_BYTE",width:Math.min(this.__trimSetAtlasTextureSize[0],this.__cadpassdata.maxTexSize),height:Math.min(this.__trimSetAtlasTextureSize[1],this.__cadpassdata.maxTexSize),filter:"NEAREST"}),this.__trimSetAtlasMaskFbo=new B(n,this.__trimSetAtlasMaskTexture),this.__trimSetAtlasMaskFbo.setClearColor([0,0,0,0]);const e="webgl2"==n.name?"RG":"RGBA",r="LINEAR";this.__trimSetAtlasTexture=new A(n,{format:e,type:"UNSIGNED_BYTE",width:Math.min(this.__cadpassdata.maxTexSize,this.__trimSetAtlasTextureSize[0]),height:Math.min(this.__cadpassdata.maxTexSize,this.__trimSetAtlasTextureSize[1]),magFilter:r,minFilter:r}),this.__trimSetAtlasFbo=new B(n,this.__trimSetAtlasTexture),this.__trimSetAtlasFbo.setClearColor([0,0,0,0])}const s={};this.__trimSetAtlasMaskFbo.bindAndClear();{n.enable(n.BLEND),n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ONE),this.__cadpassdata.trimCurveFansShader.bind(s);const t=s.unifs;this.__glCurvesLibrary.bindCurvesAtlas(s),n.uniform2i(t.trimSetAtlasTextureSize.location,this.__trimSetAtlasTextureSize[0],this.__trimSetAtlasTextureSize[1]),t.trimSetTexture&&(this.__trimSetsTexture.bindToUniform(s,t.trimSetTexture),t.trimSetTextureSize&&n.uniform2i(t.trimSetTextureSize.location,this.__trimSetsTexture.width,this.__trimSetsTexture.height),this.__trimSetsAtlasLayoutTexture.bindToUniform(s,t.curvesAtlasLayoutTexture),t.curvesAtlasLayoutTextureSize&&n.uniform2i(t.curvesAtlasLayoutTextureSize.location,this.__trimSetsAtlasLayoutTexture.width,this.__trimSetsAtlasLayoutTexture.height));for(const t in e){const r=parseInt(t);if(r<0)continue;let a=this.__trimCurveDrawSets[t];a||(a=new De(this.__gl,r,e[t]),this.__trimCurveDrawSets[t]=a),a.drawFans(s)}n.disable(n.BLEND)}this.__trimSetAtlasFbo.bindAndClear();{this.__cadpassdata.flattenTrimSetsShader.bind(s);const e=s.unifs;this.__trimSetAtlasMaskTexture.bindToUniform(s,e.trimSetAtlasTexture),e.trimSetAtlasTextureSize&&this.__gl.uniform2i(e.trimSetAtlasTextureSize.location,this.__trimSetAtlasTextureSize[0],this.__trimSetAtlasTextureSize[1]),this.__cadpassdata.glplanegeom.bind(s),this.__cadpassdata.glplanegeom.draw()}{this.__cadpassdata.trimCurveStripsShader.bind(s);const t=s.unifs;this.__glCurvesLibrary.bindCurvesAtlas(s),n.uniform2i(t.trimSetAtlasTextureSize.location,this.__trimSetAtlasTextureSize[0],this.__trimSetAtlasTextureSize[1]),n.uniform1f(t.stripWidth.location,1.25),n.uniform1i(t.flatten.location,1),n.disable(n.BLEND);for(const t in e){const r=parseInt(t);if(r<0)continue;let a=this.__trimCurveDrawSets[t];a||(a=new De(this.__gl,r,e[t]),this.__trimCurveDrawSets[t]=a),a.drawStrips(s)}n.uniform1i(t.flatten.location,0),n.enable(n.BLEND),n.blendEquation(n.MIN),n.blendFunc(n.ONE,n.ONE);for(const t in e){const r=parseInt(t);if(r<0)continue;let a=this.__trimCurveDrawSets[t];a||(a=new De(this.__gl,r,e[t]),this.__trimCurveDrawSets[t]=a),a.drawStrips(s)}n.disable(n.BLEND)}for(const t in e){const e=this.__trimCurveDrawSets[t];e&&e.cleanup()}this.__trimSetsAtlasLayoutData=r,n.finish()}logTrimSetMask(e){const t=this.__gl;this.__trimSetAtlasMaskFbo.bind();const r=[this.__trimSetsAtlasLayoutData[4*e+0],this.__trimSetsAtlasLayoutData[4*e+1],this.__trimSetsAtlasLayoutData[4*e+2],this.__trimSetsAtlasLayoutData[4*e+3]];console.log("logTrimSetMask "+e+":["+r[0]+","+r[1]+"]:"+r[2]+"x"+r[3]);const a=new Uint8Array(4*r[2]);for(let e=0;e<r[3];e++){t.readPixels(r[0],r[1]+e,r[2],1,"webgl2"==t.name?t.RED:t.RGBA,t.UNSIGNED_BYTE,a);let n=e+" ";for(let e=0;e<r[2];e++)n+=a[4*e];console.log(n)}}logTrimSet(e){const t=this.__gl;this.__trimSetAtlasFbo.bind();const r=[this.__trimSetsAtlasLayoutData[4*e+0],this.__trimSetsAtlasLayoutData[4*e+1],this.__trimSetsAtlasLayoutData[4*e+2],this.__trimSetsAtlasLayoutData[4*e+3]];console.log("logTrimSet "+e+":["+r[0]+","+r[1]+"]:"+r[2]+"x"+r[3]);const a=new Uint16Array(4*r[2]);for(let e=0;e<r[3];e++){t.readPixels(r[0],r[1]+e,r[2],1,t.RGBA,t.HALF_FLOAT,a);let n=e+" ";for(let e=0;e<r[2];e++)n+=a[4*e];console.log(n)}}bindTrimSetAtlas(e){const t=this.__gl,r=e.unifs,{trimSetAtlasTexture:a,trimSetAtlasTextureSize:n}=r;this.__trimSetAtlasTexture&&a&&(this.__trimSetAtlasTexture.bindToUniform(e,a),n&&t.uniform2i(n.location,this.__trimSetAtlasTextureSize[0],this.__trimSetAtlasTextureSize[1]),this.ext_filter_anisotropic&&t.texParameterf(t.TEXTURE_2D,this.ext_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT,1))}bindTrimSetAtlasLayout(e){if(!this.__trimSetsAtlasLayoutTexture)return;const t=this.__gl,r=e.unifs;this.__trimSetsAtlasLayoutTexture.bindToUniform(e,r.trimSetsAtlasLayoutTexture),t.uniform2i(r.trimSetsAtlasLayoutTextureSize.location,this.__trimSetsAtlasLayoutTexture.width,this.__trimSetsAtlasLayoutTexture.height)}drawTrimSets(e){if(!this.__trimSetAtlasTexture||!this.__cadpassdata.debugTrimSetsShader.bind(e))return!1;this.__trimSetAtlasTexture.bindToUniform(e,e.unifs.trimSetAtlasTexture),this.__cadpassdata.glplanegeom.bind(e),this.__cadpassdata.glplanegeom.draw()}destroy(){this.__trimSetsTexture.destroy(),this.__trimSetsAtlasLayoutTexture&&(this.__trimSetsAtlasLayoutTexture.destroy(),this.__trimSetAtlasMaskTexture.destroy(),this.__trimSetAtlasMaskFbo.destroy(),this.__trimSetAtlasTexture.destroy(),this.__trimSetAtlasFbo.destroy())}}class Ve extends D{constructor(e,t){super(),this.cadBody=e,this.bodyId=t,this.flags=0,this.dirtyValues=new Set}bind(e,t,r,a,n,s,i){this.cadBodyTextureData=r;const o=this.cadBody.getBodyDataTexelCoords();this.cadBody.isVisible()||(this.flags|=512),(this.cadBody.isCutawayEnabled&&this.cadBody.isCutawayEnabled()||this.cadBody.hasParameter("CutawayEnabled")&&this.cadBody.getParameter("CutawayEnabled").getValue())&&(this.flags|=256);const d=this.cadBody.getMaterial(),l=e.genShaderID(d.getShaderName());let c=d.getMetadata("glmaterialcoords");c||(c=e.materialLibrary.addMaterial(d)),t[0]=this.cadBody.getBodyDescId(),t[1]=l,r[0]=this.cadBody.getBodyDescId(),r[1]=this.flags,r[2]=o.x,r[3]=o.y,r[4]=c.x,r[5]=c.y,this.visibilityChanged=()=>{this.cadBody.isVisible()?0!=(512&this.flags)&&(this.flags&=-513,this.cadBodyTextureData[1]=this.flags,a(this.bodyId)):0==(512&this.flags)&&(this.flags|=512,this.cadBodyTextureData[1]=this.flags,a(this.bodyId))},this.cadBody.on("visibilityChanged",this.visibilityChanged),this.materialChanged=()=>{const t=this.cadBody.getMaterial();let n=t.getMetadata("glmaterialcoords");n||(n=e.materialLibrary.addMaterial(t)),r[4]=n.x,r[5]=n.y,a(this.bodyId)},this.cadBody.getParameter("Material").on("valueChanged",this.materialChanged),this.globalXfoParam=this.cadBody.getParameter("GlobalXfo"),this.updateXfo(),this.globalXfoChanged=()=>{a(this.bodyId),this.dirtyValues.add("Xfo")},this.globalXfoParam.on("valueChanged",this.globalXfoChanged),this.cadBody.isHighlighted()&&(this.updateHighlightColor(),n.push(this.bodyId)),this.highlightChanged=()=>{if(s.dirty||(setTimeout(i,1),s.dirty=!0),this.cadBody.isHighlighted()){if(this.dirtyValues.add("Highlight"),a(this.bodyId),-1==n.indexOf(this.bodyId)){n.push(this.bodyId);const e=s.unhighlightedBodyIds.indexOf(this.bodyId);-1!=e?s.unhighlightedBodyIds.splice(e,1):s.highlightedBodyIds.push(this.bodyId)}}else{const e=n.indexOf(this.bodyId);if(-1!=e){n.splice(e,1);const t=s.highlightedBodyIds.indexOf(this.bodyId);-1!=t?s.highlightedBodyIds.splice(t,1):s.unhighlightedBodyIds.push(this.bodyId)}}},this.cadBody.on("highlightChanged",this.highlightChanged),this.updateCutaway(),this.cutAwayChangedId=this.cadBody.on("cutAwayChanged",()=>{a(this.bodyId),this.dirtyValues.add("Cutaway")})}updateCutaway(){if(this.cadBody.isCutawayEnabled()){256&this.flags||(this.flags|=256,this.cadBodyTextureData[1]=this.flags);const e=this.cadBody.getCutVector(),t=this.cadBody.getCutDist();this.cadBodyTextureData[24]=e.x,this.cadBodyTextureData[25]=e.y,this.cadBodyTextureData[26]=e.z,this.cadBodyTextureData[27]=t}else 256&this.flags&&(this.flags&=-257,this.cadBodyTextureData[1]=this.flags)}updateHighlightColor(){const e=this.cadBody.getHighlight();if(e){const t=20;this.cadBodyTextureData[t+0]=e.r,this.cadBodyTextureData[t+1]=e.g,this.cadBodyTextureData[t+2]=e.b,this.cadBodyTextureData[t+3]=e.a}}updateXfo(){const e=this.globalXfoParam.getValue();this.cadBodyTextureData[8]=e.tr.x,this.cadBodyTextureData[9]=e.tr.y,this.cadBodyTextureData[10]=e.tr.z,this.cadBodyTextureData[12]=e.ori.x,this.cadBodyTextureData[13]=e.ori.y,this.cadBodyTextureData[14]=e.ori.z,this.cadBodyTextureData[15]=e.ori.w,this.cadBodyTextureData[16]=e.sc.x,this.cadBodyTextureData[17]=e.sc.y,this.cadBodyTextureData[18]=e.sc.z}updateCadBodyTex(){this.dirtyValues.forEach(e=>{"Xfo"==e?this.updateXfo():"Highlight"==e?this.updateHighlightColor():"Cutaway"==e&&this.updateCutaway()}),this.dirtyValues.clear()}destroy(){if(this.cadBody.off("visibilityChanged",this.visibilityChanged),this.cadBody.cutAwayChanged)this.cadBody.off("cutAwayChanged",this.cutAwayChangedId);else{const e=this.cadBody.getParameter("CutawayEnabled");e&&e.off("valueChanged",this.cutAwayEnabledId)}this.cadBody.getParameter("Material").off("valueChanged",this.materialChanged),this.cadBody.getParameter("GlobalXfo").off("valueChanged",this.globalXfoChanged),this.cadBody.off("highlightChanged",this.highlightChanged)}}const we="[object process]"===Object.prototype.toString.call("undefined"!=typeof process?process:0),Ge=we&&"function"==typeof module.require?module.require:null;var Ie=function(e,t=null,r=!1){const a=we?function(e,t){return Buffer.from(e,"base64").toString(t?"utf16":"utf8")}(e,r):function(e,t){const r=atob(e);if(t){const e=new Uint8Array(r.length);return Array.prototype.forEach.call(e,(e,t,a)=>{a[t]=r.charCodeAt(t)}),String.fromCharCode.apply(null,new Uint16Array(e.buffer))}return r}(e,r),n=a.indexOf("\n",10)+1,s=a.substring(n)+(t?`//# sourceMappingURL=${t}`:"");if(Ge){const e=Ge("worker_threads").Worker;return function(t){return new e(s,Object.assign({},t,{eval:!0}))}}const i=new Blob([s],{type:"application/javascript"}),o=URL.createObjectURL(i);return function(e){return new Worker(o,e)}}("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwpjbGFzcyB0e2NvbnN0cnVjdG9yKHQ9MCxlPTApe3RoaXMucm9vdD17eDowLHk6MCx3OnQsaDplfX1maXQodCl7aWYoMD09dC5sZW5ndGgpcmV0dXJuO3RoaXMucm9vdC53PHRbMF0udyYmKHRoaXMucm9vdC53PXRbMF0udyksdGhpcy5yb290Lmg8dFswXS5oJiYodGhpcy5yb290Lmg9dFswXS5oKTt0LmZvckVhY2godD0+e3QuZml0PXRoaXMuX19hZGRCbG9jayh0KX0pfV9fYWRkQmxvY2sodCl7Y29uc3QgZT10aGlzLmZpbmROb2RlKHRoaXMucm9vdCx0LncsdC5oKTtyZXR1cm4gZT90aGlzLnNwbGl0Tm9kZShlLHQudyx0LmgpOnRoaXMuZ3Jvd05vZGUodC53LHQuaCl9YWRkQmxvY2sodCl7dGhpcy5yb290LnVzZWR8fCh0aGlzLnJvb3Qudzx0LncmJih0aGlzLnJvb3Qudz10LncpLHRoaXMucm9vdC5oPHQuaCYmKHRoaXMucm9vdC5oPXQuaCkpO2NvbnN0IGU9dGhpcy5maW5kTm9kZSh0aGlzLnJvb3QsdC53LHQuaCk7cmV0dXJuIGU/dGhpcy5zcGxpdE5vZGUoZSx0LncsdC5oKTp0aGlzLmdyb3dOb2RlKHQudyx0LmgpfWZpbmROb2RlKHQsZSxzKXtyZXR1cm4gdC51c2VkP3RoaXMuZmluZE5vZGUodC5yaWdodCxlLHMpfHx0aGlzLmZpbmROb2RlKHQuZG93bixlLHMpOmU8PXQudyYmczw9dC5oP3Q6bnVsbH1zcGxpdE5vZGUodCxlLHMpe3JldHVybiB0LnVzZWQ9ITAsdC5kb3duPXt4OnQueCx5OnQueStzLHc6dC53LGg6dC5oLXN9LHQucmlnaHQ9e3g6dC54K2UseTp0Lnksdzp0LnctZSxoOnN9LHR9Z3Jvd05vZGUodCxlKXtjb25zdCBzPXQ8PXRoaXMucm9vdC53LG89ZTw9dGhpcy5yb290Lmgscj1vJiZ0aGlzLnJvb3QuaD49dGhpcy5yb290LncrdCxhPXMmJnRoaXMucm9vdC53Pj10aGlzLnJvb3QuaCtlO3JldHVybiByP3RoaXMuZ3Jvd1JpZ2h0KHQsZSk6YT90aGlzLmdyb3dEb3duKHQsZSk6bz90aGlzLmdyb3dSaWdodCh0LGUpOnM/dGhpcy5ncm93RG93bih0LGUpOm51bGx9Z3Jvd1JpZ2h0KHQsZSl7dGhpcy5yb290PXt1c2VkOiEwLHg6MCx5OjAsdzp0aGlzLnJvb3Qudyt0LGg6dGhpcy5yb290LmgsZG93bjp0aGlzLnJvb3QscmlnaHQ6e3g6dGhpcy5yb290LncseTowLHc6dCxoOnRoaXMucm9vdC5ofX07Y29uc3Qgcz10aGlzLmZpbmROb2RlKHRoaXMucm9vdCx0LGUpO2xldCBvO3JldHVybiBzJiYobz10aGlzLnNwbGl0Tm9kZShzLHQsZSkpLG99Z3Jvd0Rvd24odCxlKXt0aGlzLnJvb3Q9e3VzZWQ6ITAseDowLHk6MCx3OnRoaXMucm9vdC53LGg6dGhpcy5yb290LmgrZSxkb3duOnt4OjAseTp0aGlzLnJvb3QuaCx3OnRoaXMucm9vdC53LGg6ZX0scmlnaHQ6dGhpcy5yb290fTtjb25zdCBzPXRoaXMuZmluZE5vZGUodGhpcy5yb290LHQsZSk7bGV0IG87cmV0dXJuIHMmJihvPXRoaXMuc3BsaXROb2RlKHMsdCxlKSksb319Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0LGU9MCxzPSEwKXt0aGlzLl9fZGF0YT10LHRoaXMuX19ieXRlT2Zmc2V0PWUsdGhpcy5fX2RhdGFWaWV3PW5ldyBEYXRhVmlldyh0aGlzLl9fZGF0YSksdGhpcy5fX2lzTW9iaWxlRGV2aWNlPXMsdGhpcy51dGY4ZGVjb2Rlcj1uZXcgVGV4dERlY29kZXJ9Z2V0IGlzTW9iaWxlRGV2aWNlKCl7cmV0dXJuIHRoaXMuX19pc01vYmlsZURldmljZX1nZXQgZGF0YSgpe3JldHVybiB0aGlzLl9fZGF0YX1nZXQgYnl0ZUxlbmd0aCgpe3JldHVybiB0aGlzLl9fZGF0YVZpZXcuYnl0ZUxlbmd0aH1nZXQgcmVtYWluaW5nQnl0ZUxlbmd0aCgpe3JldHVybiB0aGlzLl9fZGF0YVZpZXcuYnl0ZUxlbmd0aC10aGlzLl9fYnl0ZU9mZnNldH1wb3MoKXtyZXR1cm4gdGhpcy5fX2J5dGVPZmZzZXR9c2Vlayh0KXt0aGlzLl9fYnl0ZU9mZnNldD10fWFkdmFuY2UodCl7dGhpcy5fX2J5dGVPZmZzZXQrPXR9bG9hZFVJbnQ4KCl7Y29uc3QgdD10aGlzLl9fZGF0YVZpZXcuZ2V0VWludDgodGhpcy5fX2J5dGVPZmZzZXQpO3JldHVybiB0aGlzLl9fYnl0ZU9mZnNldCs9MSx0fWxvYWRVSW50MTYoKXtjb25zdCB0PXRoaXMuX19kYXRhVmlldy5nZXRVaW50MTYodGhpcy5fX2J5dGVPZmZzZXQsITApO3JldHVybiB0aGlzLl9fYnl0ZU9mZnNldCs9Mix0fWxvYWRVSW50MzIoKXtjb25zdCB0PXRoaXMuX19kYXRhVmlldy5nZXRVaW50MzIodGhpcy5fX2J5dGVPZmZzZXQsITApO3JldHVybiB0aGlzLl9fYnl0ZU9mZnNldCs9NCx0fWxvYWRTSW50MzIoKXtjb25zdCB0PXRoaXMuX19kYXRhVmlldy5nZXRJbnQzMih0aGlzLl9fYnl0ZU9mZnNldCwhMCk7cmV0dXJuIHRoaXMuX19ieXRlT2Zmc2V0Kz00LHR9bG9hZEZsb2F0MTYoKXtyZXR1cm4odD0+e2NvbnN0IGU9KDMyNzY4JnQpPj4xNSxzPSgzMTc0NCZ0KT4+MTAsbz0xMDIzJnQ7cmV0dXJuIDA9PXM/KGU/LTE6MSkqTWF0aC5wb3coMiwtMTQpKihvL01hdGgucG93KDIsMTApKTozMT09cz9vP05hTjoxLzAqKGU/LTE6MSk6KGU/LTE6MSkqTWF0aC5wb3coMixzLTE1KSooMStvL01hdGgucG93KDIsMTApKX0pKHRoaXMubG9hZFVJbnQxNigpKX1sb2FkVUZsb2F0MTYoKXtjb25zdCB0PXRoaXMubG9hZEZsb2F0MTYoKTtyZXR1cm4gdDwwPzIwNDgtdDp0fWxvYWRGbG9hdDE2RnJvbTJ4VUludDgoKXtjb25zdCB0PXRoaXMuX19kYXRhVmlldy5nZXRGbG9hdDE2KHRoaXMuX19ieXRlT2Zmc2V0LCEwKTtyZXR1cm4gdGhpcy5fX2J5dGVPZmZzZXQrPTIsdH1sb2FkVUludDMyRnJvbTJ4VUZsb2F0MTYoKXtyZXR1cm4gdGhpcy5sb2FkVUZsb2F0MTYoKSs0MDk2KnRoaXMubG9hZFVGbG9hdDE2KCl9bG9hZFNJbnQzMkZyb20yeEZsb2F0MTYoKXtyZXR1cm4gdGhpcy5sb2FkRmxvYXQxNigpKzIwNDgqdGhpcy5sb2FkRmxvYXQxNigpfWxvYWRGbG9hdDMyKCl7Y29uc3QgdD10aGlzLl9fZGF0YVZpZXcuZ2V0RmxvYXQzMih0aGlzLl9fYnl0ZU9mZnNldCwhMCk7cmV0dXJuIHRoaXMuX19ieXRlT2Zmc2V0Kz00LHR9bG9hZFVJbnQ4QXJyYXkodCxlPSExKXtudWxsPT10JiYodD10aGlzLmxvYWRVSW50MzIoKSk7Y29uc3Qgcz1uZXcgVWludDhBcnJheSh0aGlzLl9fZGF0YSx0aGlzLl9fYnl0ZU9mZnNldCx0KTt0aGlzLl9fYnl0ZU9mZnNldCs9dDt0aGlzLl9fYnl0ZU9mZnNldDtyZXR1cm4gc31sb2FkVUludDE2QXJyYXkodCxlPSExKXtpZihudWxsPT10JiYodD10aGlzLmxvYWRVSW50MzIoKSksMD09dClyZXR1cm4gbmV3IFVpbnQxNkFycmF5O2xldCBzO2lmKHRoaXMucmVhZFBhZGQoMiksdGhpcy5fX2lzTW9iaWxlRGV2aWNlKXtzPW5ldyBVaW50MTZBcnJheSh0KTtmb3IobGV0IGU9MDtlPHQ7ZSsrKXNbZV09dGhpcy5fX2RhdGFWaWV3LmdldFVpbnQxNih0aGlzLl9fYnl0ZU9mZnNldCwhMCksdGhpcy5fX2J5dGVPZmZzZXQrPTJ9ZWxzZSBzPW5ldyBVaW50MTZBcnJheSh0aGlzLl9fZGF0YSx0aGlzLl9fYnl0ZU9mZnNldCx0KSx0aGlzLl9fYnl0ZU9mZnNldCs9Mip0O3JldHVybiBzfWxvYWRVSW50MzJBcnJheSh0LGU9ITEpe2lmKG51bGw9PXQmJih0PXRoaXMubG9hZFVJbnQzMigpKSwwPT10KXJldHVybiBuZXcgVWludDMyQXJyYXk7bGV0IHM7aWYodGhpcy5yZWFkUGFkZCg0KSx0aGlzLl9faXNNb2JpbGVEZXZpY2Upe3M9bmV3IFVpbnQzMkFycmF5KHQpO2ZvcihsZXQgZT0wO2U8dDtlKyspc1tlXT10aGlzLl9fZGF0YVZpZXcuZ2V0VWludDMyKHRoaXMuX19ieXRlT2Zmc2V0LCEwKSx0aGlzLl9fYnl0ZU9mZnNldCs9NH1lbHNlIHM9bmV3IFVpbnQzMkFycmF5KHRoaXMuX19kYXRhLHRoaXMuX19ieXRlT2Zmc2V0LHQpLHRoaXMuX19ieXRlT2Zmc2V0Kz00KnQ7cmV0dXJuIHN9bG9hZEZsb2F0MzJBcnJheSh0LGU9ITEpe2lmKG51bGw9PXQmJih0PXRoaXMubG9hZFVJbnQzMigpKSwwPT10KXJldHVybiBuZXcgRmxvYXQzMkFycmF5O2xldCBzO2lmKHRoaXMucmVhZFBhZGQoNCksdGhpcy5fX2lzTW9iaWxlRGV2aWNlKXtzPW5ldyBGbG9hdDMyQXJyYXkodCk7Zm9yKGxldCBlPTA7ZTx0O2UrKylzW2VdPXRoaXMuX19kYXRhVmlldy5nZXRGbG9hdDMyKHRoaXMuX19ieXRlT2Zmc2V0LCEwKSx0aGlzLl9fYnl0ZU9mZnNldCs9NH1lbHNlIHM9bmV3IEZsb2F0MzJBcnJheSh0aGlzLl9fZGF0YSx0aGlzLl9fYnl0ZU9mZnNldCx0KSx0aGlzLl9fYnl0ZU9mZnNldCs9NCp0O3JldHVybiBzfWxvYWRTdHIoKXtjb25zdCB0PXRoaXMubG9hZFVJbnQzMigpLGU9bmV3IFVpbnQ4QXJyYXkodGhpcy5fX2RhdGEsdGhpcy5fX2J5dGVPZmZzZXQsdCk7dGhpcy5fX2J5dGVPZmZzZXQrPXQ7bGV0IHM9IiI7Zm9yKGxldCBvPTA7bzx0O28rKylzKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbb10pO3JldHVybiBzfWxvYWRTdHJBcnJheSgpe2NvbnN0IHQ9dGhpcy5sb2FkVUludDMyKCksZT1bXTtmb3IobGV0IHM9MDtzPHQ7cysrKWVbc109dGhpcy5sb2FkU3RyKCk7cmV0dXJuIGV9cmVhZFBhZGQodCl7Y29uc3QgZT10aGlzLl9fYnl0ZU9mZnNldCV0OzAhPWUmJih0aGlzLl9fYnl0ZU9mZnNldCs9dC1lKX19Y29uc3Qgcz0wLG89MSxyPTIsYT0zLG49NCxpPTUsbD02LGg9OCx1PTksYz0xMCxmPTE0LGQ9MTUsdz0xNixfPXQ9Pntzd2l0Y2godCl7Y2FzZSBzOnJldHVybiJTVVJGQUNFX1RZUEVfUExBTkUiO2Nhc2UgbzpyZXR1cm4iU1VSRkFDRV9UWVBFX0NPTkUiO2Nhc2UgcjpyZXR1cm4iU1VSRkFDRV9UWVBFX0NZTElOREVSIjtjYXNlIGE6cmV0dXJuIlNVUkZBQ0VfVFlQRV9TUEhFUkUiO2Nhc2UgbjpyZXR1cm4iU1VSRkFDRV9UWVBFX1RPUlVTIjtjYXNlIGk6cmV0dXJuIlNVUkZBQ0VfVFlQRV9MSU5FQVJfRVhUUlVTSU9OIjtjYXNlIGw6cmV0dXJuIlNVUkZBQ0VfVFlQRV9SRVZPTFVUSU9OIjtjYXNlIGg6cmV0dXJuIlNVUkZBQ0VfVFlQRV9OVVJCU19TVVJGQUNFIjtjYXNlIHU6cmV0dXJuIlNVUkZBQ0VfVFlQRV9PRkZTRVRfU1VSRkFDRSI7Y2FzZSBjOnJldHVybiJTVVJGQUNFX1RZUEVfVFJJTU1FRF9SRUNUX1NVUkZBQ0UiO2Nhc2UgZjpyZXR1cm4iU1VSRkFDRV9UWVBFX1BPTFlfUExBTkUiO2Nhc2UgZDpyZXR1cm4iU1VSRkFDRV9UWVBFX0ZBTiI7Y2FzZSB3OnJldHVybiJTVVJGQUNFX1RZUEVfUkVWT0xVVElPTl9GTElQUEVEX0RPTUFJTiJ9fSx5PW5ldyB0LG09bmV3IHQsZz1uZXcgdCxBPXt9O2Z1bmN0aW9uIFModCxlKXtmb3IobGV0IHM9MDtzPDM7cysrKWlmKHRbc10hPT1lW3NdKXJldHVybiB0W3NdLWVbc107cmV0dXJuIDB9Y29uc3QgRj10PT5NYXRoLnBvdygyLE1hdGgucm91bmQoTWF0aC5sb2codCkvTWF0aC5sb2coMikpKTtmdW5jdGlvbiBiKHQsZT0xLHM9MSl7Y29uc3Qgbz1NYXRoLnNxcnQodCplKnMpO2xldCByLGE7aWYoZT49cyl7cj1vL2U7Y29uc3Qgcz1yLU1hdGguZmxvb3Iocik7cz4uNSYmczwxP3IrPTEtczpyPU1hdGgubWF4KDEsTWF0aC5mbG9vcihyKSksYT10L3I7Y29uc3Qgbj1hLU1hdGguZmxvb3IoYSk7bj4wJiZuPDEmJihhKz0xLW4pfWVsc2V7YT1vL3M7Y29uc3QgZT1hLU1hdGguZmxvb3IoYSk7ZT4uNSYmZTwxP2ErPTEtZTphPU1hdGgubWF4KDEsTWF0aC5mbG9vcihhKSkscj10L2E7Y29uc3Qgbj1yLU1hdGguZmxvb3Iocik7bj4wJiZuPDEmJihyKz0xLW4pfWlmKHIqYTx0KXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBjb250YWluZXIgc2l6ZSIpO3JldHVybltyLGFdfWZ1bmN0aW9uIFUodCxlLHMsbyxyKXtjb25zdCBhPWUrIngiK3Msbj1yW2FdO251bGwhPW4/b1tuXS5pZHMucHVzaCh0KTooclthXT1vLmxlbmd0aCxvLnB1c2goe2l0ZW1XaWR0aDplLGl0ZW1IZWlnaHQ6cyxpZHM6W3RdfSkpfWZ1bmN0aW9uIEQodCxlLHMsbyl7Y29uc3Qgcj1mdW5jdGlvbih0KXtjb25zdCBlPW5ldyBVaW50MTZBcnJheSh0Lmxlbmd0aCk7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspe2Vbc109cztjb25zdCBvPXRbc10scj1iKG8uaWRzLmxlbmd0aCxvLml0ZW1XaWR0aCxvLml0ZW1IZWlnaHQpO28uaXRlbUNvdW50VVY9cixvLnc9clswXSpvLml0ZW1XaWR0aCxvLmg9clsxXSpvLml0ZW1IZWlnaHQsby5sPU1hdGgubWF4KG8udyxvLmgpfXJldHVybiBlLnNvcnQoKGUscyk9PnRbZV0ubD50W3NdLmw/LTE6dFtlXS5sPHRbc10ubD8xOjApLGV9KHQpO2Zvcihjb25zdCBhIG9mIHIpe2NvbnN0IHI9dFthXSxuPWUuYWRkQmxvY2soe3c6ci53LGg6ci5ofSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKCJVbmFibGUgdG8gbGF5b3V0IGJpbjoiK3IudysiIHggIityLmgpO28mJm8ocixuKTtmb3IobGV0IHQ9MDt0PHIuaWRzLmxlbmd0aDt0Kyspe3Mocix0LG4ueCt0JXIuaXRlbUNvdW50VVZbMF0qci5pdGVtV2lkdGgsbi55K01hdGguZmxvb3IodC9yLml0ZW1Db3VudFVWWzBdKSpyLml0ZW1IZWlnaHQpfX19Y29uc3QgcD0odCxlLHMsbyxyKT0+e2NvbnN0IGE9dC5sb2FkVUludDMyKCk7bGV0IG49NDtTKFtlLm1ham9yLGUubWlub3IsZS5wYXRjaF0sWzAsMCwwXSk+MCYmKG49OCk7Y29uc3QgaT1iKGEsMSwxKSxsPW5ldyBGbG9hdDMyQXJyYXkoaVswXSppWzFdKjQpLGg9ZT0+e2NvbnN0IG89dC5sb2FkRmxvYXQzMigpLHI9dC5sb2FkRmxvYXQzMigpLGE9dC5sb2FkRmxvYXQzMigpLG49dC5sb2FkRmxvYXQzMigpLGk9dC5sb2FkRmxvYXQzMigpLGw9dC5sb2FkRmxvYXQzMigpLGg9dC5sb2FkRmxvYXQzMigpLHU9dC5sb2FkRmxvYXQzMigpLGM9c1s4Km8rMl0tMTtyZXR1cm57Y3VydmVJZDpvLGN1cnZlSW5kZXhXaXRoaW5Mb29wOmUsYWRkcjpbc1s4Km8rMF0sc1s4Km8rMV1dLGRldGFpbDpjLHRyOltyLGFdLHJvdzA6W24saV0scm93MTpbbCxoXSxmbGFnczp1fX0sdT1bXSxjPXt9O2ZvcihsZXQgZT0wO2U8YTtlKyspdHJ5e3Quc2VlayhuKzQqZSksdC5zZWVrKHQubG9hZFVJbnQzMigpKTtjb25zdCBzPXQubG9hZEZsb2F0MzIoKSxvPXQubG9hZEZsb2F0MzIoKTtpZihpc05hTihzKXx8aXNOYU4obykpe2NvbnNvbGUud2FybigiVW5hYmxlIHRvIGxheW91dCBpdGVtOiIrcysiIHggIitvKTtjb250aW51ZX1jb25zdCBhPU1hdGgubWF4KDEsRihNYXRoLmNlaWwocy9yKSktMSksaT1NYXRoLm1heCgxLEYoTWF0aC5jZWlsKG8vcikpLTEpO2lmKGlzTmFOKGEpfHxpc05hTihpKSl7Y29uc29sZS53YXJuKCJVbmFibGUgdG8gbGF5b3V0IGl0ZW06IithKyIgeCAiK2kpO2NvbnRpbnVlfVUoZSxhKzIsaSsyLHUsYyl9Y2F0Y2godCl7Y29uc29sZS53YXJuKCJFcnJvciB3aGlsZSByZWFkaW5nIFRyaW1TZXQgZGF0YSBpbiB3ZWIgd29ya2VyOiAiLGUsdCl9Y29uc3QgZj17fTtEKHUsZywoZSxzLG8scik9Pntjb25zdCBhPWUuaWRzW3NdLGk9KGU9Pnt0LnNlZWsobis0KmUpLHQuc2Vlayh0LmxvYWRVSW50MzIoKSs4KTtjb25zdCBzPXQubG9hZFVJbnQzMigpLG89dC5sb2FkVUludDMyKCkscj1bXTtmb3IobGV0IHQ9MDt0PG87dCsrKXIucHVzaChoKHQpKTtmb3IobGV0IGU9MDtlPHM7ZSsrKXtjb25zdCBlPXQubG9hZFVJbnQzMigpO2ZvcihsZXQgdD0wO3Q8ZTt0Kyspe2NvbnN0IGU9aCh0KTtyLnB1c2goZSl9fXJldHVybiByfSkoYSksdT00KmE7bFt1KzBdPW8rMSxsW3UrMV09cisxLGxbdSsyXT1lLml0ZW1XaWR0aC0yLGxbdSszXT1lLml0ZW1IZWlnaHQtMjtmb3IoY29uc3QgdCBvZiBpKXtsZXQgcz1mW3QuZGV0YWlsXTtzfHwocz1bXSxmW3QuZGV0YWlsXT1zKSxzLnB1c2gobysxKSxzLnB1c2gocisxKSxzLnB1c2goZS5pdGVtV2lkdGgtMikscy5wdXNoKGUuaXRlbUhlaWdodC0yKSxzLnB1c2godC50clswXSkscy5wdXNoKHQudHJbMV0pLHMucHVzaCh0LnJvdzBbMF0pLHMucHVzaCh0LnJvdzBbMV0pLHMucHVzaCh0LnJvdzFbMF0pLHMucHVzaCh0LnJvdzFbMV0pLHMucHVzaCh0LmFkZHJbMF0pLHMucHVzaCh0LmFkZHJbMV0pLHMucHVzaCh0LmZsYWdzKSxzLnB1c2godC5jdXJ2ZUluZGV4V2l0aGluTG9vcCl9fSk7Y29uc3QgZD17fTtmb3IoY29uc3QgdCBpbiBmKWRbdF09RmxvYXQzMkFycmF5LmZyb20oZlt0XSk7cmV0dXJuIEEudHJpbVNldHNBdGxhc0xheW91dERhdGE9bCx7dHJpbUN1cnZlRHJhd1NldHM6ZCx0cmltU2V0c0F0bGFzTGF5b3V0RGF0YTpsLHRyaW1TZXRzQXRsYXNMYXlvdXRUZXh0dXJlU2l6ZTppfX07bGV0IHYsSTtjb25zdCB4PSh0LHMpPT57Y29uc3Qgbz17fSxyPXtldmVudFR5cGU6ImxvYWRBc3NldERvbmUiLHByb2ZpbGluZzpvfSxhPVtdO2xldCBuLGM9cGVyZm9ybWFuY2Uubm93KCk7e2NvbnN0IHM9KCh0LGUscyk9Pntjb25zdCBvPXQubG9hZFVJbnQzMigpO2lmKDA9PW8pcmV0dXJuO2NvbnNvbGUubG9nKCJudW1DdXJ2ZXMgOiIsbyk7TWF0aC5zcXJ0KHQuZGF0YS5ieXRlTGVuZ3RoLzgpO2NvbnN0IHI9bmV3IFVpbnQzMkFycmF5KG8pLGE9W10sbj17fTtmb3IobGV0IHM9MDtzPG87cysrKXRyeXt0LnNlZWsoOCsxNipzKzQpO2xldCBvPXQubG9hZEZsb2F0MTYoKSxpPXQubG9hZEZsb2F0MTYoKTtjb25zdCBsPXQubG9hZEZsb2F0MTYoKTtsZXQgaDtpZihOdW1iZXIuaXNGaW5pdGUobyl8fChvPTY1NTM2KSxOdW1iZXIuaXNGaW5pdGUoaSl8fChpPTY1NTM2KSw4JmwpaD1vO2Vsc2UgaWYoMD09byloPTE7ZWxzZXtjb25zdCB0PTEvKG8vaSk7aWYodDxlKWg9NjtlbHNle2NvbnN0IHM9dC1lO2lmKGg9by8oMipNYXRoLmFjb3Mocy90KSksaD1NYXRoLm1heCgxLE1hdGgucm91bmQoRihoKSkpLGg+MTAyNSYmKGNvbnNvbGUud2FybigiQ3VydmUgZGV0YWlsOiIraCksaD1NYXRoLm1pbihoLDEwMjUpKSxpc05hTihoKSl7Y29uc29sZS53YXJuKCJVbmFibGUgdG8gbGF5b3V0IEN1cnZlOiIraCk7Y29udGludWV9fX1VKHMsaCsxLDEsYSxuKSxyW3NdPWh9Y2F0Y2godCl7Y29uc29sZS53YXJuKCJFcnJvciB3aGlsZSByZWFkaW5nIENBREN1cnZlIGRhdGEgaW4gd2ViIHdvcmtlcjogIixzLHQpfWNvbnN0IGk9YigyKm8pLGw9bmV3IEZsb2F0MzJBcnJheShpWzBdKmlbMV0qNCk7cmV0dXJuIEQoYSx5LChlLHMsbyxyKT0+e2NvbnN0IGE9ZS5pZHNbc10sbj04KmE7bFtuKzBdPW8sbFtuKzFdPXIsbFtuKzJdPWUuaXRlbVdpZHRoLGxbbiszXT1lLml0ZW1IZWlnaHQsdC5zZWVrKDgrMTYqYSk7Y29uc3QgaT10LmxvYWRVRmxvYXQxNigpLGg9dC5sb2FkVUZsb2F0MTYoKTtsW24rNF09aSxsW24rNV09aH0pLEEuY3VydmVEZXRhaWxzPXIse251bUN1cnZlczpvLGN1cnZlc0F0bGFzTGF5b3V0OmwsY3VydmVzQXRsYXNMYXlvdXRUZXh0dXJlU2l6ZTppfX0pKG5ldyBlKHQuY3VydmVzRGF0YUJ1ZmZlciksdC5lcnJvclRvbGVyYW5jZSx0Lm1heFRleFNpemUpO2lmKHMpe3IubnVtQ3VydmVzPXMubnVtQ3VydmVzLHIuY3VydmVzQXRsYXNMYXlvdXQ9cy5jdXJ2ZXNBdGxhc0xheW91dCxyLmN1cnZlc0F0bGFzTGF5b3V0VGV4dHVyZVNpemU9cy5jdXJ2ZXNBdGxhc0xheW91dFRleHR1cmVTaXplLHIuY3VydmVzQXRsYXNUZXh0dXJlRGltPVt5LnJvb3Qudyx5LnJvb3QuaF0sYS5wdXNoKHIuY3VydmVzQXRsYXNMYXlvdXQuYnVmZmVyKTtmb3IoY29uc3QgdCBpbiByLmN1cnZlRHJhd1NldHMpYS5wdXNoKHIuY3VydmVEcmF3U2V0c1t0XS5idWZmZXIpO249cGVyZm9ybWFuY2Uubm93KCksby5udW1DdXJ2ZXM9cy5udW1DdXJ2ZXMsby5sYXlvdXRDdXJ2ZXM9bi1jLG8uY3VydmVzQXRsYXNUZXh0dXJlRGltPXIuY3VydmVzQXRsYXNUZXh0dXJlRGltfX17Y29uc3Qgcz0oKHQsZSxzLG8scik9Pntjb25zdCBhPU1hdGguc3FydCh0LmRhdGEuYnl0ZUxlbmd0aC84KSxuPXQubG9hZFVJbnQzMigpO2lmKGNvbnNvbGUubG9nKCJudW1TdXJmYWNlcyA6IixuKSwwPT1uKXJldHVybjt0LmxvYWRGbG9hdDMyKCksdC5sb2FkRmxvYXQzMigpO2NvbnN0IGM9bmV3IEludDMyQXJyYXkoNypuKSxmPWU9Pntjb25zdCBzPTgqZS54KzgqZS55KmE7dC5zZWVrKHMpfSx5PVtdLGc9e30scD17fTtsZXQgdj0wO2NvbnN0IEk9Uyhbci5tYWpvcixyLm1pbm9yLHIucGF0Y2hdLFswLDAsMjddKT49MDtmb3IobGV0IHM9MDtzPG47cysrKXRyeXt0LnNlZWsoOCsxOCpzKTtjb25zdCByPXQubG9hZFVGbG9hdDE2KCksYT10LmxvYWRVRmxvYXQxNigpO2xldCBuPXQubG9hZEZsb2F0MTYoKSxtPXQubG9hZEZsb2F0MTYoKSxBPXQubG9hZEZsb2F0MTYoKSxTPXQubG9hZEZsb2F0MTYoKTtjb25zdCBiPXQubG9hZEZsb2F0MTYoKTtsZXQgRCx4LEUsVDtpZihOdW1iZXIuaXNGaW5pdGUoQSl8fChBPTY1NTM2KSxOdW1iZXIuaXNGaW5pdGUoUyl8fChTPTY1NTM2KSxJKUQ9dC5sb2FkU0ludDMyRnJvbTJ4RmxvYXQxNigpO2Vsc2V7RD10LmxvYWRGbG9hdDE2KCkrKHQubG9hZEZsb2F0MTYoKTw8OCl9Zih7eDpyLHk6YX0pO3RyeXt4PXQubG9hZEZsb2F0MTYoKX1jYXRjaCh0KXtjb25zb2xlLndhcm4oIkVycm9yIHdoaWxlIHJlYWRpbmcgU3VyZmFjZSBkYXRhIGluIHdlYiB3b3JrZXI6ICIscyx0KTtjb250aW51ZX1sZXQgQz0wO2lmKHg9PWQpRT1uLFQ9bTtlbHNle2NvbnN0IHQ9QSpTO2lmKHQ8byl7Y29uc29sZS5sb2coIlNraXBwaW5nIDoiLF8oeCksIiBzaXplOiIsQSwieCIsUywiIGFyZWE6Iix0KTtjb250aW51ZX1pZihOdW1iZXIuaXNGaW5pdGUobil8fChuPTY1NTM2KSxOdW1iZXIuaXNGaW5pdGUobSl8fChtPTY1NTM2KSw2NCZiKUU9bjtlbHNlIGlmKDA9PW4pRT0xO2Vsc2V7Y29uc3QgdD0xLyhuL0EpO2lmKHQ8ZSlFPTY7ZWxzZXtjb25zdCBzPXQtZTtFPW4vKDIqTWF0aC5hY29zKHMvdCkpLEU9TWF0aC5tYXgoMSxNYXRoLnJvdW5kKEYoRSkpKSxFPjEwMjUmJihjb25zb2xlLndhcm4oIkdlb20gZGV0YWlsVToiK0UpLEU9MTAyNSl9fWlmKDEyOCZiKVQ9bTtlbHNlIGlmKDA9PW0pVD0xO2Vsc2V7Y29uc3QgdD0xLyhtL1MpO2lmKHQ8ZSlUPTY7ZWxzZXtjb25zdCBzPXQtZTtUPW0vKDIqTWF0aC5hY29zKHMvdCkpLFQ9TWF0aC5tYXgoMSxNYXRoLnJvdW5kKEYoVCkpKSxUPjEwMjUmJihjb25zb2xlLndhcm4oIkdlb20gZGV0YWlsVjoiK1QpLFQ9MTAyNSl9fWlmKEU8VCl7Y29uc3QgdD1FO0U9VCxUPXQsQz0zMn19aWYoaXNOYU4oRSl8fGlzTmFOKFQpfHwhTnVtYmVyLmlzRmluaXRlKEUpfHwhTnVtYmVyLmlzRmluaXRlKFQpKXtjb25zb2xlLndhcm4oIlVuYWJsZSB0byBsYXlvdXQgaXRlbSAiLF8oeCksIiA6IitFKyIgeCAiK1QpO2NvbnRpbnVlfUUrKyxUKys7bGV0IE49MDt4PT1pfHx4PT1sfHx4PT11fHx4PT13P049MTp4PT1oJiYoTj0yKSxwW05dP3BbTl0rKzpwW05dPTEsVShzLEUsVCx5LGcpO2NvbnN0IE09NypzO2NbTSswXT1DfGIsY1tNKzFdPXIsY1tNKzJdPWEsY1tNKzNdPU4sY1tNKzRdPUUsY1tNKzVdPVQsY1tNKzZdPUQsdis9RSpUfWNhdGNoKHQpe2NvbnNvbGUud2FybigiRXJyb3Igd2hpbGUgcmVhZGluZyBTdXJmYWNlIGRhdGEgaW4gd2ViIHdvcmtlcjogIixzLHQpfWNvbnN0IHg9YihuLDIsMSksRT1bMip4WzBdLHhbMV1dLFQ9bmV3IEZsb2F0MzJBcnJheSgyKnhbMF0qeFsxXSo0KSxDPVtdO2Zvcihjb25zdCB0IGluIHApe2NvbnN0IGU9cFt0XTtDW3BhcnNlSW50KHQpXT1uZXcgRmxvYXQzMkFycmF5KGUpLHBbdF09bnVsbH1yZXR1cm4gRCh5LG0sKHQsZSxzLG8pPT57Y29uc3Qgcj10Lmlkc1tlXSxhPTcqcixuPWNbYSswXSxpPWNbYSsxXSxsPWNbYSsyXSxoPWNbYSszXSx1PTgqcjtUW3UrMF09cyxUW3UrMV09byxUW3UrMl09dC5pdGVtV2lkdGgsVFt1KzNdPXQuaXRlbUhlaWdodCxUW3UrNF09aSxUW3UrNV09bCxUW3UrNl09bixudWxsPT09cFtoXT9wW2hdPTA6cFtoXSsrLENbaF1bcFtoXV09cn0pLEEuc3VyZmFjZURldGFpbHM9YyxBLnN1cmZhY2VzQXRsYXNMYXlvdXQ9VCx7bnVtU3VyZmFjZXM6bixzdXJmYWNlc0F0bGFzTGF5b3V0OlQsc3VyZmFjZXNFdmFsQXR0cnM6QyxzdXJmYWNlc0F0bGFzTGF5b3V0VGV4dHVyZVNpemU6RX19KShuZXcgZSh0LnN1cmZhY2VzRGF0YUJ1ZmZlciksdC5lcnJvclRvbGVyYW5jZSx0Lm1heFRleFNpemUsdC5zdXJmYWNlQXJlYVRocmVzaG9sZCx0LmNhZERhdGFWZXJzaW9uKTtpZihzKXtyLnN1cmZhY2VzRXZhbEF0dHJzPXMuc3VyZmFjZXNFdmFsQXR0cnMsci5zdXJmYWNlc0F0bGFzTGF5b3V0PXMuc3VyZmFjZXNBdGxhc0xheW91dCxyLnN1cmZhY2VzQXRsYXNMYXlvdXRUZXh0dXJlU2l6ZT1zLnN1cmZhY2VzQXRsYXNMYXlvdXRUZXh0dXJlU2l6ZSxyLnN1cmZhY2VzQXRsYXNUZXh0dXJlRGltPVttLnJvb3QudyxtLnJvb3QuaF0sYS5wdXNoKHIuc3VyZmFjZXNBdGxhc0xheW91dC5idWZmZXIpO2Zvcihjb25zdCB0IGluIHIuc3VyZmFjZXNFdmFsQXR0cnMpYS5wdXNoKHIuc3VyZmFjZXNFdmFsQXR0cnNbdF0uYnVmZmVyKTtuPXBlcmZvcm1hbmNlLm5vdygpLG8ubGF5b3V0U3VyZmFjZXM9bi1jLG8ubnVtU3VyZmFjZXM9cy5udW1TdXJmYWNlcyxvLnN1cmZhY2VzQXRsYXNUZXh0dXJlRGltPXIuc3VyZmFjZXNBdGxhc1RleHR1cmVEaW19fWlmKHQudHJpbVNldHNCdWZmZXIpe2NvbnN0IHM9bmV3IGUodC50cmltU2V0c0J1ZmZlciksaT1wKHMsdC5jYWREYXRhVmVyc2lvbixyLmN1cnZlc0F0bGFzTGF5b3V0LHQubG9kLHQudHJpbVRleGVsU2l6ZSk7ci50cmltQ3VydmVEcmF3U2V0cz1pLnRyaW1DdXJ2ZURyYXdTZXRzLHIudHJpbVNldHNBdGxhc0xheW91dERhdGE9aS50cmltU2V0c0F0bGFzTGF5b3V0RGF0YSxyLnRyaW1TZXRzQXRsYXNMYXlvdXRUZXh0dXJlU2l6ZT1pLnRyaW1TZXRzQXRsYXNMYXlvdXRUZXh0dXJlU2l6ZSxyLnRyaW1TZXRBdGxhc1RleHR1cmVTaXplPVtnLnJvb3QudyxnLnJvb3QuaF0sYS5wdXNoKHIudHJpbVNldHNBdGxhc0xheW91dERhdGEuYnVmZmVyKTtmb3IoY29uc3QgdCBpbiByLnRyaW1DdXJ2ZURyYXdTZXRzKWEucHVzaChyLnRyaW1DdXJ2ZURyYXdTZXRzW3RdLmJ1ZmZlcik7Yz1wZXJmb3JtYW5jZS5ub3coKSxvLmxheW91dFRyaW1TZXRzPWMtbixvLnRyaW1TZXRBdGxhc1RleHR1cmVTaXplPXIudHJpbVNldEF0bGFzVGV4dHVyZVNpemV9e2NvbnN0IHM9bmV3IGUodC5ib2R5TGlicmFyeUJ1ZmZlciksaT1uZXcgZSh0LmJvZHlMaWJyYXJ5QnVmZmVyVG9jKTtvLm51bUJvZGllcz10LnNjZW5lQm9keUl0ZW1zRGF0YS5sZW5ndGgvMjtjb25zdCBsPSgodCxlLHMsbyxyKT0+e2NvbnN0IGE9dC5sZW5ndGgvMjtJPW5ldyBVaW50MzJBcnJheShhKTtjb25zdCBuPU1hdGguc3FydChzLmJ5dGVMZW5ndGgvMTYpO2xldCBpO2k9Uyhbby5tYWpvcixvLm1pbm9yLG8ucGF0Y2hdLFswLDAsMjldKT49MD8xNToxMTtjb25zdCBsPVMoW28ubWFqb3Isby5taW5vcixvLnBhdGNoXSxbMSwwLDVdKT49MDt2PXQ9PntlLnNlZWsoNCsxMip0KTtjb25zdCBvPWUubG9hZFVJbnQzMigpLHI9ZS5sb2FkVUludDMyKCksYT0xNipvKzE2KnIqbjtzLnNlZWsoYSsyNCk7Y29uc3QgaD1zLmxvYWRGbG9hdDMyKCksdT1sP3MubG9hZEZsb2F0MzIoKTowLGM9W107Zm9yKGxldCB0PTA7dDxoO3QrKyl7Y29uc3QgdD1zLmxvYWRGbG9hdDMyKCk7Yy5wdXNoKHQpLHMuYWR2YW5jZSg0KihpLTEpKX1jb25zdCBmPVtdLGQ9cy5wb3MoKTtmb3IobGV0IHQ9MDt0PHU7dCsrKXtzLnNlZWsoZCt0KmkqNCk7Y29uc3QgZT1zLmxvYWRGbG9hdDMyKCk7Zi5wdXNoKGUpfXJldHVybnt4Om8seTpyLHN1cmZhY2VJZHM6YyxjdXJ2ZUlkczpmfX07Y29uc3QgaD17fSx1PXt9O2xldCBjPTAsZj0wO2ZvcihsZXQgZT0wO2U8YTtlKyspdHJ5e2NvbnN0IHM9MiplLG89dFtzKzBdO2lmKC0xPT1vKWNvbnRpbnVlO2NvbnN0IHI9dFtzKzFdLGE9dihvKTtpZigwPT1hLnN1cmZhY2VJZHMubGVuZ3RoKWNvbnRpbnVlO2MrPWEuc3VyZmFjZUlkcy5sZW5ndGgsZis9YS5jdXJ2ZUlkcy5sZW5ndGgsSVtlXT1vO2NvbnN0IG49YS5zdXJmYWNlSWRzO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKXtjb25zdCBzPW5bdF0sbz03KnMsYT1BLnN1cmZhY2VEZXRhaWxzW28rNF0saT1BLnN1cmZhY2VEZXRhaWxzW28rNV07aWYoMD09YXx8MD09aSljb250aW51ZTtjb25zdCBsPWErIngiK2k7bGV0IHU9aFtsXTt1fHwodT17fSxoW2xdPXUpO2xldCBjPXVbcl07Y3x8KGM9W10sdVtyXT1jKTtjb25zdCBmPUEuc3VyZmFjZURldGFpbHNbbys2XSxkPXQ7Yy5wdXNoKGUpLGMucHVzaChkKSxjLnB1c2gocyksYy5wdXNoKGYpfWNvbnN0IGk9YS5jdXJ2ZUlkcztmb3IobGV0IHQ9MDt0PGkubGVuZ3RoO3QrKyl7Y29uc3Qgcz1pW3RdLG89QS5jdXJ2ZURldGFpbHNbc107aWYoMD09byljb250aW51ZTtsZXQgcj11W29dO3J8fChyPXt9LHVbb109cik7bGV0IGE9clswXTthfHwoYT1bXSxyWzBdPWEpO2NvbnN0IGw9bi5sZW5ndGgrdDthLnB1c2goZSksYS5wdXNoKGwpLGEucHVzaChzKSxhLnB1c2goLTEpfX1jYXRjaCh0KXtjb25zb2xlLndhcm4oIkVycm9yIHdoaWxlIHJlYWRpbmcgQ0FEQm9keURlc2MgZGF0YSBpbiB3ZWIgd29ya2VyOiAiLGUsdCl9QS5udW1TdXJmYWNlSW5zdGFuY2VzPWMsQS5udW1DdXJ2ZUluc3RhbmNlcz1mO2NvbnN0IGQ9e307Zm9yKGNvbnN0IHQgaW4gaCl7ZFt0XXx8KGRbdF09e30pO2NvbnN0IGU9aFt0XTtmb3IoY29uc3QgcyBpbiBlKXtjb25zdCBvPWVbc107ZFt0XVtzXT1GbG9hdDMyQXJyYXkuZnJvbShvKX19Y29uc3Qgdz17fTtmb3IoY29uc3QgdCBpbiB1KXt3W3RdfHwod1t0XT17fSk7Y29uc3QgZT11W3RdO2Zvcihjb25zdCBzIGluIGUpe2NvbnN0IG89ZVtzXTt3W3RdW3NdPUZsb2F0MzJBcnJheS5mcm9tKG8pfX1yZXR1cm4gQS5zdXJmYWNlRHJhd1NldHNfdG1wPWgsQS5jdXJ2ZURyYXdTZXRzX3RtcD11LEEuc3VyZmFjZURyYXdTZXRzPWQsQS5jdXJ2ZURyYXdTZXRzPXcse3N1cmZhY2VEcmF3U2V0czpkLGN1cnZlRHJhd1NldHM6d319KSh0LnNjZW5lQm9keUl0ZW1zRGF0YSxpLHMsdC5jYWREYXRhVmVyc2lvbik7ci5zdXJmYWNlRHJhd1NldHM9bC5zdXJmYWNlRHJhd1NldHMsci5jdXJ2ZURyYXdTZXRzPWwuY3VydmVEcmF3U2V0cztmb3IoY29uc3QgdCBpbiByLnN1cmZhY2VEcmF3U2V0cyl7Y29uc3QgZT1yLnN1cmZhY2VEcmF3U2V0c1t0XTtmb3IoY29uc3QgdCBpbiBlKWEucHVzaChlW3RdLmJ1ZmZlcil9Zm9yKGNvbnN0IHQgaW4gci5jdXJ2ZURyYXdTZXRzKXtjb25zdCBlPXIuY3VydmVEcmF3U2V0c1t0XTtmb3IoY29uc3QgdCBpbiBlKWEucHVzaChlW3RdLmJ1ZmZlcil9by5udW1TdXJmYWNlSW5zdGFuY2VzPUEubnVtU3VyZmFjZUluc3RhbmNlcyxvLm51bUN1cnZlSW5zdGFuY2VzPUEubnVtQ3VydmVJbnN0YW5jZXMsbj1wZXJmb3JtYW5jZS5ub3coKSxvLmxheW91dEJvZHlJdGVtcz1uLWMsby5ib2R5QXRsYXNEaW09ci5ib2R5QXRsYXNEaW19cyhyLGEpLHQuaGlnaGxpZ2h0ZWRCb2RpZXMubGVuZ3RoPjAmJlQoe2hpZ2hsaWdodGVkQm9keUlkczp0LmhpZ2hsaWdodGVkQm9kaWVzLHVuaGlnaGxpZ2h0ZWRCb2R5SWRzOltdfSxzKX0sRT17fSxUPSh0LGUpPT57Y29uc3Qgcz10LmhpZ2hsaWdodGVkQm9keUlkcyxvPXQudW5oaWdobGlnaHRlZEJvZHlJZHMscj0odCxlKT0+e2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cysrKXtjb25zdCBvPXRbc10scj1JW29dLGE9dihyKS5zdXJmYWNlSWRzO2ZvcihsZXQgdD0wO3Q8YS5sZW5ndGg7dCsrKXtlKG8sbzw8MTZ8dCxhW3RdLHQpfX19O3IobywodCxlLHMsbyk9Pntjb25zdCByPTcqcyxhPUEuc3VyZmFjZURldGFpbHNbcis0XSsieCIrQS5zdXJmYWNlRGV0YWlsc1tyKzVdO2xldCBuPUVbYV07bnx8KG49e3N1cmZhY2VEcmF3Q29vcmRzOnt9LGNvdW50OjB9LEVbYV09biksZGVsZXRlIG4uc3VyZmFjZURyYXdDb29yZHNbZV0sbi5jb3VudC0tfSkscihzLCh0LGUscyxvKT0+e2NvbnN0IHI9NypzLGE9QS5zdXJmYWNlRGV0YWlsc1tyKzRdKyJ4IitBLnN1cmZhY2VEZXRhaWxzW3IrNV07bGV0IG49RVthXTtufHwobj17c3VyZmFjZURyYXdDb29yZHM6e30sY291bnQ6MH0sRVthXT1uKTtjb25zdCBpPUEuc3VyZmFjZURldGFpbHNbcis2XTtuLnN1cmZhY2VEcmF3Q29vcmRzW2VdPVt0LG8scyxpXSxuLmNvdW50Kyt9KTtjb25zdCBhPXt9LG49W107Zm9yKGNvbnN0IHQgaW4gRSl7Y29uc3QgZT1FW3RdLHM9bmV3IEZsb2F0MzJBcnJheSg0KmUuY291bnQpO2xldCBvPTA7Zm9yKGNvbnN0IGUgaW4gRVt0XS5zdXJmYWNlRHJhd0Nvb3Jkcyl7Y29uc3Qgcj1FW3RdLnN1cmZhY2VEcmF3Q29vcmRzW2VdO3Muc2V0KHIsbyksbys9NH1hW3RdPXMsbi5wdXNoKHMuYnVmZmVyKX1lKHtldmVudFR5cGU6ImhpZ2hsaWdodGVkU3VyZmFjZURyYXdTZXRzQ2hhbmdlZCIsaGlnaGxpZ2h0ZWRTdXJmYWNlRHJhd1NldHM6YSxudW1IaWdobGlnaHRlZDpzLmxlbmd0aCxudW1VbmhpZ2hsaWdodGVkOm8ubGVuZ3RofSxuKX07Z2xvYmFsVGhpcy5vbm1lc3NhZ2U9ZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSl7c3dpdGNoKHQuZXZlbnRUeXBlKXtjYXNlImxvYWRBc3NlbWJseSI6eCh0LGUpO2JyZWFrO2Nhc2UiYm9keUhpZ2hsaWdodENoYW5nZWQiOlQodCxlKX19KHQuZGF0YSwodCxlKT0+e2dsb2JhbFRoaXMucG9zdE1lc3NhZ2UodCxlKX0pfTsKCg==",null,!1);class Fe extends D{constructor(e,t,r,a){super(),this.__gl=e,this.__assetId=t,this.__cadAsset=r,this.__numSurfaces=r.getSurfaceLibrary().getNumSurfaces(),this.__numBodies=r.getBodyLibrary().getNumBodies(),this.__numMaterials=r.getMaterialLibrary().getNumMaterials(),this.__numHighlightedGeoms=0,this.__ready=!1,this.__visible=this.__cadAsset.isVisible(),this.__assetVisibilityChanged=this.__assetVisibilityChanged.bind(this),this.__cadAsset.on("visibilityChanged",this.__assetVisibilityChanged);const n=()=>{this.displayEdges=this.__cadAsset.getParameter("Display Edges").getValue(),this.displayEdges?a.incDisplayEdges():a.decDisplayEdges()};n(),this.displayEdgesChangedId=this.__cadAsset.getParameter("Display Edges").on("valueChanged",n);const s=()=>{this.edgeColor=this.__cadAsset.getParameter("Edge Color").getValue().asArray(),this.emit("updated")};s(),this.edgesColorChangedId=this.__cadAsset.getParameter("Edge Color").on("valueChanged",s),this.__cadpassdata=a,this.__curveLibrary=new Le(e,a,this.__cadAsset.getSurfaceLibrary(),r.getVersion()),this.__surfaceLibrary=new Re(e,a,this.__cadAsset.getSurfaceLibrary(),this.__curveLibrary,r.getVersion());const i=this.__cadAsset.getTrimSetLibrary().getBinaryBuffer();i&&i.byteLength>8&&(this.__trimSetLibrary=new Be(e,a,this.__cadAsset.getTrimSetLibrary(),this.__curveLibrary));{const t=this.__cadAsset.getBodyLibrary().getBinaryBuffer();if(t){const r=Math.sqrt(t.byteLength/16);this.__bodyDescTexture=new A(e,{format:"RGBA",type:"FLOAT",width:r,height:r,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,data:new Float32Array(t)})}}this.__bindAttr=(t,r,a,n,s,i=!0)=>{e.enableVertexAttribArray(t),e.vertexAttribPointer(t,r,e.FLOAT,!1,n,s),i&&e.vertexAttribDivisor(t,1)},this.__trimCurveDrawSets={},this.__surfaceDrawSets={},this.__curveDrawSets={},this.loadWorker()}__assetVisibilityChanged(){this.__visible=this.__cadAsset.isVisible(),this.emit("assetVisibilityChanged")}getCADAsset(){return this.__cadAsset}getNumSurfaces(){return this.__numSurfaces}getNumBodies(){return this.__numBodies}getNumMaterials(){return this.__numMaterials}incHighlightedCount(e){this.__numHighlightedGeoms+=e,this.__cadpassdata.incHighlightedCount(e)}decHighlightedCount(e){this.__numHighlightedGeoms-=e,this.__cadpassdata.decHighlightedCount(e)}loadWorker(){const e=this.__cadAsset.getNumBodyItems();if(0==e)return;let t=w.nextPow2(Math.round(Math.sqrt(7*e)+.5));t%7!=0&&(t+=7-t%7),this.cadBodiesTextureData=new Float32Array(t*t*4);const r=this.__cadAsset.getParameter("BoundingBox").getValue();this.__assetCentroid=new n;const a=new Float32Array(2*e);let s=0;this.__cadBodies=[];const i=[],o={highlightedBodyIds:[],unhighlightedBodyIds:[],dirty:!1},d=()=>{this.__postMessageToWorker({eventType:"bodyHighlightChanged",highlightedBodyIds:o.highlightedBodyIds,unhighlightedBodyIds:o.unhighlightedBodyIds}),o.highlightedBodyIds=[],o.unhighlightedBodyIds=[],o.dirty=!1};this.__dirtyBodyIndices=[];const l=e=>{-1==this.__dirtyBodyIndices.indexOf(e)&&(this.__dirtyBodyIndices.push(e),this.emit("updated"))},c=t=>{const r=s;if(r>=e)return;const n=2*r*4,c=new Float32Array(a.buffer,n,2),u=7*r*4*4,_=new Float32Array(this.cadBodiesTextureData.buffer,u,28),h=new Ve(t,r);h.bind(this.__cadpassdata,c,_,l,i,o,d),this.__cadBodies.push(h),s++};this.__cadAsset.traverse(e=>!(e instanceof ce)||(c(e),!1));const u=this.__gl;this.__cadBodiesTexture=new A(u,{format:"RGBA",type:"FLOAT",width:t,height:t,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,data:this.cadBodiesTextureData});const _=this.__cadAsset.getUnitsConversion(),h=.5*r.size().length()/_,f=this.__cadAsset.lod,m=128*Math.pow(2,f),v=2*Math.PI/m,g=h-h*Math.cos(v/2);console.log("assetBBoxRadius:",h," errorTolerance:",g," surfaceAreaThreshold:",0);const p=this.__cadAsset.getSurfaceLibrary().getCurveBuffer(),S=this.__cadAsset.getSurfaceLibrary().getSurfaceBuffer(),y=this.__cadAsset.getVersion(),x=this.__cadAsset.getTrimSetLibrary().getBinaryBuffer();let b=-1;if(x){const e=this.__cadpassdata.assetCount;b=this.__cadAsset.getTrimSetLibrary().getTexelSize(f,e)}const L=this.__cadAsset.getBodyLibrary().getToc(),C=this.__cadAsset.getBodyLibrary().getBinaryBuffer(),R=[S,L,C];x&&R.push(x);const T={eventType:"loadAssembly",assetId:this.__assetId,curvesDataBuffer:p,surfacesDataBuffer:S,cadDataVersion:y,trimSetsBuffer:x,lod:this.__cadAsset.getLOD(),maxTexSize:this.__cadpassdata.maxTexSize/2,errorTolerance:g,surfaceAreaThreshold:0,trimTexelSize:b,sceneBodyItemsData:a,bodyLibraryBufferToc:L,bodyLibraryBuffer:C,highlightedBodies:i};this.__postMessageToWorker(T,R)}updateBodyTexture(e){const t=this.__gl,r=this.__gl.TEXTURE0+e.boundTextures+1;t.activeTexture(r),t.bindTexture(t.TEXTURE_2D,this.__cadBodiesTexture.glTex);const a=this.__cadBodiesTexture.width;for(let e=0;e<this.__dirtyBodyIndices.length;e++){const t=this.__dirtyBodyIndices[e],r=Math.floor(7*t/a),n=7*t%a;this.__cadBodies[t].updateCadBodyTex();const s=7,i=1,o=7*t*4*4,d=new Float32Array(this.cadBodiesTextureData.buffer,o,28);this.__cadBodiesTexture.populate(d,s,i,n,r,!1)}t.bindTexture(t.TEXTURE_2D,null),this.__dirtyBodyIndices=[]}__postMessageToWorker(e,t){this.__worker||(this.__worker=new Ie),this.__worker.onmessage=e=>{this.__onWorkerMessage(e.data)},this.__worker.postMessage(e,this.__cadpassdata.debugMode?[]:t)}__onWorkerMessage(e){switch(e.eventType){case"loadAssetDone":console.log("Layout Asset:",this.getCADAsset().getName(),e.profiling),e.curvesAtlasLayout&&this.__curveLibrary.evaluateCurves(e.curvesAtlasLayout,e.numCurves,e.curvesAtlasLayoutTextureSize,e.curvesAtlasTextureDim);const t={};e.surfacesEvalAttrs&&(t.surfaceEvalTime=this.__surfaceLibrary.evaluateSurfaces(e.surfacesEvalAttrs,e.surfacesAtlasLayout,e.surfacesAtlasLayoutTextureSize,e.surfacesAtlasTextureDim)),e.trimCurveDrawSets&&e.trimSetAtlasTextureSize[0]>0&&e.trimSetAtlasTextureSize[1]>0&&this.__trimSetLibrary.evaluateTrimSets(e.trimCurveDrawSets,e.trimSetAtlasTextureSize,e.trimSetsAtlasLayoutData,e.trimSetsAtlasLayoutTextureSize),this.__bodyAtlasDim=e.bodyAtlasDim,this.updateDrawSets(t,e.surfaceDrawSets,e.curveDrawSets),this.__ready=!0,this.emit("loaded",{numSurfaces:e.profiling.numSurfaces,numSurfaceInstances:e.profiling.numSurfaceInstances,surfaceEvalTime:t.surfaceEvalTime,numBodies:e.profiling.numBodies,numMaterials:this.__numMaterials,numTriangles:t.numTriangles,numDrawSets:t.numDrawSets}),this.emit("updated");break;case"highlightedSurfaceDrawSetsChanged":for(const t in e.highlightedSurfaceDrawSets){const r=this.__surfaceDrawSets[t];r?r.setDrawItems(e.highlightedSurfaceDrawSets[t],1):console.warn("Selecting invalid items:",t)}this.incHighlightedCount(e.numHighlighted),this.decHighlightedCount(e.numUnhighlighted),this.emit("updated")}}updateDrawSets(e,t,r){if(e.numTriangles=0,e.numDrawSets=0,t)for(const r in t){let a=this.__surfaceDrawSets[r];if(!a){const e=r.split("x"),t=parseInt(e[0]),n=parseInt(e[1]);a=new pe(this.__gl,t,n),this.__surfaceDrawSets[r]=a}const n=t[r];for(const t in n){const r=n[t];e.numTriangles+=a.addDrawItems(r,t)}e.numDrawSets++}if(r)for(const t in r){let a=this.__curveDrawSets[t];if(!a){const e=parseInt(t);a=new be(this.__gl,e),this.__curveDrawSets[t]=a}const n=r[t];for(const e in n){const t=n[e];a.addDrawItems(t,e)}e.numDrawSets++}}bindDrawItemsAtlas(e){this.__drawItemsTarget.bindColorTexture(e,e.unifs.drawItemsTexture),e.unifs.vert_drawItemsTextureSize&&this.__gl.uniform2i(e.unifs.vert_drawItemsTextureSize.location,this.__bodyAtlasDim[0],this.__bodyAtlasDim[1]),e.unifs.frag_drawItemsTextureSize&&this.__gl.uniform2i(e.unifs.frag_drawItemsTextureSize.location,this.__bodyAtlasDim[0],this.__bodyAtlasDim[1])}bind(e){const t=this.__gl,r=e.unifs;r.vert_drawItemsTextureSize&&this.__gl.uniform2i(r.vert_drawItemsTextureSize.location,this.__bodyAtlasDim[0],this.__bodyAtlasDim[1]),r.frag_drawItemsTextureSize&&this.__gl.uniform2i(r.frag_drawItemsTextureSize.location,this.__bodyAtlasDim[0],this.__bodyAtlasDim[1]),r.bodyDescTexture&&(this.__bodyDescTexture.bindToUniform(e,r.bodyDescTexture),t.uniform2i(r.bodyDescTextureSize.location,this.__bodyDescTexture.width,this.__bodyDescTexture.height),r.bodyDescTextureSize_frag&&t.uniform2i(r.bodyDescTextureSize_frag.location,this.__bodyDescTexture.width,this.__bodyDescTexture.height)),r.cadBodiesTexture&&(this.__cadBodiesTexture.bindToUniform(e,r.cadBodiesTexture),r.cadBodiesTextureSize_vert&&t.uniform1i(r.cadBodiesTextureSize_vert.location,this.__cadBodiesTexture.width),r.cadBodiesTextureSize_frag&&t.uniform1i(r.cadBodiesTextureSize_frag.location,this.__cadBodiesTexture.width)),r.assetCentroid&&t.uniform3fv(r.assetCentroid.location,this.__assetCentroid.asArray())}draw(e){if(!this.__visible||!this.__ready)return!1;const t=e.boundTextures;if(this.__dirtyBodyIndices.length>0&&this.updateBodyTexture(e),this.bind(e),this.__surfaceLibrary.bindSurfacesAtlas(e)){this.__trimSetLibrary&&(this.__trimSetLibrary.bindTrimSetAtlasLayout(e),this.__trimSetLibrary.bindTrimSetAtlas(e));for(const t in this.__surfaceDrawSets){this.__surfaceDrawSets[t].draw(e,e.shaderId)}e.boundTextures=t}else e.boundTextures=t}drawHighlightedGeoms(e){if(!this.__visible||0==this.__numHighlightedGeoms)return!1;const t=e.boundTextures;this.bind(e),this.__surfaceLibrary.bindSurfacesAtlas(e),this.__trimSetLibrary&&(this.__trimSetLibrary.bindTrimSetAtlasLayout(e),this.__trimSetLibrary.bindTrimSetAtlas(e));for(const t in this.__surfaceDrawSets){this.__surfaceDrawSets[t].draw(e,1)}e.boundTextures=t}drawNormals(e,t){if(!this.__visible||!this.__ready)return!1;const r=e.boundTextures;this.bind(e),this.__surfaceLibrary.bindSurfacesAtlas(e),this.__trimSetLibrary&&(this.__trimSetLibrary.bindTrimSetAtlasLayout(e),this.__trimSetLibrary.bindTrimSetAtlas(e));for(const r in this.__surfaceDrawSets){this.__surfaceDrawSets[r].drawNormals(e,t)}e.boundTextures=r}drawEdges(e,t){if(!this.__visible||!this.__ready||!this.displayEdges)return!1;const r=e.boundTextures;this.__dirtyBodyIndices.length>0&&this.updateBodyTexture(e),this.bind(e),this.__curveLibrary.bindCurvesAtlas(e),this.__gl.uniform4fv(e.unifs.edgeColor.location,this.edgeColor);for(const r in this.__curveDrawSets){this.__curveDrawSets[r].draw(e,t)}e.boundTextures=r}drawGeomData(e){if(!this.__visible||!this.__ready)return!1;const t=e.boundTextures;this.bind(e),this.__surfaceLibrary.bindSurfacesAtlas(e),this.__trimSetLibrary&&(this.__trimSetLibrary.bindTrimSetAtlasLayout(e),this.__trimSetLibrary.bindTrimSetAtlas(e));const r=this.__gl,a=e.unifs.assetIndex;a&&r.uniform1i(a.location,this.__assetId);for(const t in this.__surfaceDrawSets){this.__surfaceDrawSets[t].draw(e,e.shaderId)}e.boundTextures=t}getGeomItem(e){return this.__cadBodies[e].cadBody}getSurfaceData(e){return this.__cadAsset.getSurfaceLibrary().getSurfaceData(e)}drawSurfaceAtlas(e){this.__surfaceLibrary&&this.__surfaceLibrary.drawSurfaceAtlas(e)}drawTrimSets(e){this.__trimSetLibrary&&this.__trimSetLibrary.drawTrimSets(e)}destroy(){this.__cadAsset.off("visibilityChanged",this.__assetVisibilityChanged),this.__cadBodiesTexture.destroy(),this.__cadBodies.forEach(e=>e.destroy()),this.__cadBodies=[],this.__curveLibrary.destroy(),this.__surfaceLibrary.destroy(),this.__trimSetLibrary&&this.__trimSetLibrary.destroy();for(const e in this.__surfaceDrawSets){this.__surfaceDrawSets[e].destroy()}}}class Pe extends D{constructor(e){super(),this.__gl=e,this.__materialDatas=[],this.__dirtyIndices=[],this.__numItems=0,this.__materialPacker=new G(256,256),this.__needsUpload=!1}addMaterial(e){if(e.getMetadata("glmaterialcoords"))return;this.__numItems++;const t=this.__materialPacker.addBlock({w:2,h:1}),r=this.__materialDatas.length;return this.__materialDatas.push({material:e,coords:t}),e.on("parameterValueChanged",()=>{this.__dirtyIndices.push(r),this.emit("updated")}),e.setMetadata("glmaterialcoords",t),this.__dirtyIndices.push(r),t}needsUpload(){return this.__dirtyIndices.length>0}uploadMaterials(){const e=this.__gl,t=this.__materialPacker.root.w,r=this.__materialPacker.root.h;if(console.log("Num Used Materials:"+this.__numItems,t,r),this.__materialsTexture){if(this.__materialsTexture.width!=t||this.__materialsTexture.height!=r)throw new Error("Cannot resize here. Need a resize the preserves the data.")}else this.__materialsTexture=new A(e,{format:"RGBA",type:"FLOAT",width:t,height:r,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1}),this.__materialsTexture.clear();e.bindTexture(e.TEXTURE_2D,this.__materialsTexture.glTex);const a=this.__materialsTexture.getTypeID(),n=this.__materialsTexture.getFormatID();this.__dirtyIndices.forEach(t=>{const r=this.__materialDatas[t],s=r.material;let i=p.getBlueprint(s.getShaderName());i&&i.getPackedMaterialData||(i=p.getBlueprint("GLDrawCADSurfaceShader"));const o=i.getPackedMaterialData(s),d=o.length/4,l=r.coords;if(a==e.FLOAT)e.texSubImage2D(e.TEXTURE_2D,0,l.x,l.y,d,1,n,a,o);else{const t=Math.convertFloat32ArrayToUInt16Array(o);e.texSubImage2D(e.TEXTURE_2D,0,l.x,l.y,d,1,n,a,t)}}),this.__dirtyIndices=[],e.bindTexture(e.TEXTURE_2D,null)}bind(e){if(!this.__materialsTexture)return!1;const t=this.__gl,r=e.unifs;return r.materialsTexture&&this.__materialsTexture.bindToUniform(e,r.materialsTexture),r.materialsTextureSize&&t.uniform2i(r.materialsTextureSize.location,this.__materialsTexture.width,this.__materialsTexture.height),!0}}I.setShaderModule("GLSLBinReader.glsl","\n\n#ifdef DECODE_16BIT_FLOAT_FROM_8BIT_INT\n\n/////////////////////////////////////////////////////////////////\n// http://concord-consortium.github.io/lab/experiments/webgl-gpgpu/script.js\n// Note: modulo on some GPUS. (e.g. iPhone)\n// often incur errors in modulo, leaving a result\n// that appears to boe the y param. in this use case\n// we are only interested in integer moduos anyway\n// so we just trim off erronious values. .Seems to work. \nfloat fixed_mod(float x, float y) {\n  float res = mod(x, y);\n  return (abs(y - res) < 0.5) ? 0.0 : res;\n}\n\nfloat shift_right(float v, float amt) {\n  v = floor(v) + 0.5;\n  return floor(v / exp2(amt));\n}\n\nfloat shift_left(float v, float amt) {\n  return floor(v * exp2(amt) + 0.5);\n}\n\nfloat mask_last(float v, float bits) {\n  return fixed_mod(v, shift_left(1.0, bits));\n}\n\nfloat extract_bits(float num, float from, float to) {\n  from = floor(from + 0.5);\n  to = floor(to + 0.5);\n  return mask_last(shift_right(num, from), to - from);\n}\n\n\n/////////////////////////////////////////////////////////////////\n\nfloat decode16BitFloatFrom2xUInt8_IEEE(vec2 c){\n  float v = 0.;\n\n  // int h = c.x + c.y * 256;\n  // const s = (h & 0x8000) >> 15;\n  // const e = (h & 0x7C00) >> 10;\n  // const f = h & 0x03FF;\n\n\n  // float h = c.x + c.y * 256.0;\n  // float s = extract_bits(h, 15.0, 16.0);\n  // float e = extract_bits(h, 10.0, 15.0);\n  // float f = extract_bits(h, 0.0, 10.0);\n\n  // float s = extract_bits(c.y, 7.0, 8.0);\n  // float e = extract_bits(c.y, 2.0, 7.0);\n\n  int s = (c.y >= 127.5) ? 1 : 0;\n  float e = shift_right(c.y - ((s == 1) ? 128.0 : 0.0), 2.0);\n  float f = c.x + mask_last(c.y, 2.0) * 256.0;\n  // return float(s);\n\n  if(e < 0.5) {\n    return ((s!=0)?-1.0:1.0) * exp2(-14.0) * (f/exp2(10.0));\n  } else if (int(e) == 0x1F) {\n    float NaN = 0.0;\n    float Inf = 0.0;\n    return (f==0.0)?(NaN):(((s!=0)?-1.0:1.0)*Inf);\n  }\n\n  return ((s!=0)?-1.0:1.0) * exp2(e-15.0) * (1.0+(f/exp2(10.0)));\n}\n\n#endif\n\n// RGBA16 textures\nvec4 GLSLBinReader_texelFetch2D(sampler2D texture, ivec2 textureSize, ivec2 address) {\n  return fetchTexel(texture, textureSize, address);\n}\n\nstruct GLSLBinReader {\n  ivec2 textureSize; \n  ivec4 region;\n  ivec2 start; /* the base address from which we base the offsets */\n  int offset; /* how far we have read into the buffer . Note: value is in channels. so 4 == 1 pixel.*/\n  vec4 buffer; \n  ivec2 bufferaddress;\n  int bpc; // bits per channel. (e.g. 8, 16, 32)\n};\n\nvoid GLSLBinReader_init(inout GLSLBinReader reader, ivec2 textureSize, ivec4 region, ivec2 start, int bpc) {\n  reader.textureSize = textureSize;\n  reader.region = region;\n  reader.start = start;\n#ifdef DECODE_16BIT_FLOAT_FROM_8BIT_INT\n  reader.start = ivec2(start.x * 2, start.y);\n#else\n  reader.start = start;\n#endif\n  reader.bpc = bpc;\n  reader.bufferaddress = ivec2(-1, -1);\n}\n\nvoid GLSLBinReader_init(inout GLSLBinReader reader, ivec2 textureSize, int bpc) {\n  reader.textureSize = textureSize;\n  reader.region = ivec4(0, 0, textureSize.x, textureSize.y);\n  reader.start = ivec2(0,0);\n  reader.bpc = bpc;\n  reader.bufferaddress = ivec2(-1, -1);\n}\n\n\nivec2 GLSLBinReader_getAddress(in GLSLBinReader reader, int offset) {\n#ifdef DECODE_16BIT_FLOAT_FROM_8BIT_INT\n  ivec2 address = ivec2(reader.start.x + (offset/2), reader.start.y);\n#else\n  ivec2 address = ivec2(reader.start.x + (offset/4), reader.start.y);\n#endif\n  address.y += address.x / reader.region.z;\n  address.x = imod(address.x, reader.region.z);\n  return address;\n}\n\n\nfloat GLSLBinReader_readFloat(inout GLSLBinReader reader, sampler2D texture, int offset) {\n\n  ivec2 address = GLSLBinReader_getAddress(reader, offset);\n\n  if(address != reader.bufferaddress){\n    reader.buffer = GLSLBinReader_texelFetch2D(texture, reader.textureSize, reader.region.xy + address);\n    reader.bufferaddress = address;\n  }\n\n#ifdef DECODE_16BIT_FLOAT_FROM_8BIT_INT\n\n  int swizelIndex = imod(offset, 2);\n  if(swizelIndex == 0)\n    return decode16BitFloatFrom2xUInt8_IEEE(reader.buffer.xy * 255.0);\n  return decode16BitFloatFrom2xUInt8_IEEE(reader.buffer.zw * 255.0);\n\n#else\n\n  int swizelIndex = imod(offset, 4);\n  if(swizelIndex == 0)\n    return reader.buffer.x;\n  if(swizelIndex == 1)\n    return reader.buffer.y;\n  if(swizelIndex == 2)\n    return reader.buffer.z;\n  return reader.buffer.w;\n  \n#endif\n}\n\n\nint GLSLBinReader_readInt(inout GLSLBinReader reader, sampler2D texture, int offset) {\n  if(reader.bpc == 8)\n    return int(GLSLBinReader_readFloat(reader, texture, offset) * 255.0);\n  else {\n    float flt = GLSLBinReader_readFloat(reader, texture, offset);\n    return int(flt);\n  }\n}\n\nint GLSLBinReader_readUInt(inout GLSLBinReader reader, sampler2D texture, int offset) {\n  if(reader.bpc == 8)\n    return int(GLSLBinReader_readFloat(reader, texture, offset) * 255.0);\n  else {\n    float flt = GLSLBinReader_readFloat(reader, texture, offset);\n    if (flt < 0.0) {\n      return int(2048.0 - flt);\n    }\n    else {\n      return int(flt);\n    }\n  }\n}\n\nvec4 GLSLBinReader_readVec4(inout GLSLBinReader reader, sampler2D texture, int offset) {\n  ivec2 address = GLSLBinReader_getAddress(reader, offset);\n  return GLSLBinReader_texelFetch2D(texture, reader.textureSize, reader.region.xy + address);\n}\n\n\nvec3 GLSLBinReader_readVec3(inout GLSLBinReader reader, sampler2D texture, int offset) {\n  return GLSLBinReader_readVec4(reader, texture, offset).rgb;\n}\n\nvec2 GLSLBinReader_readVec2(inout GLSLBinReader reader, sampler2D texture, int offset) {\n  return vec2(\n    GLSLBinReader_readFloat(reader, texture, offset),\n    GLSLBinReader_readFloat(reader, texture, offset+1)\n  );\n}\n\n\n\nfloat GLSLBinReader_readFloat(inout GLSLBinReader reader, sampler2D texture) {\n  float result = GLSLBinReader_readFloat( reader,  texture, reader.offset);\n  reader.offset++;\n  return result;\n}\n\nint GLSLBinReader_readInt(inout GLSLBinReader reader, sampler2D texture) {\n  if(reader.bpc == 8)\n    return int(GLSLBinReader_readFloat(reader, texture) * 255.0);\n  else\n    return int(GLSLBinReader_readFloat(reader, texture));\n}\n\nint GLSLBinReader_readUInt(inout GLSLBinReader reader, sampler2D texture) {\n  if(reader.bpc == 8)\n    return int(GLSLBinReader_readFloat(reader, texture) * 255.0);\n  else {\n    float flt = GLSLBinReader_readFloat(reader, texture);\n    if (flt < 0.0) {\n      return int(2048.0 - flt);\n    }\n    else {\n      return int(flt);\n    }\n  }\n}\n\nint GLSLBinReader_readUIntFrom2xUFloat16(inout GLSLBinReader reader, sampler2D texture) {\n  int partA = GLSLBinReader_readUInt(reader, texture);\n  int partB = GLSLBinReader_readUInt(reader, texture);\n  \n#ifdef INTS_PACKED_AS_2FLOAT16\n  // Changed on version 0.0.28\n  return partA + (partB * 4096);\n#else\n  return partA + (partB * 256);\n#endif\n}\n\nvec4 GLSLBinReader_readVec4(inout GLSLBinReader reader, sampler2D texture) {\n  vec4 result = GLSLBinReader_readVec4( reader, texture, reader.offset);\n  reader.offset += 4;\n  return result;\n}\n\n\nvec3 GLSLBinReader_readVec3(inout GLSLBinReader reader, sampler2D texture) {\n  return GLSLBinReader_readVec4(reader, texture).rgb;\n}\n\nvec2 GLSLBinReader_readVec2(inout GLSLBinReader reader, sampler2D texture) {\n  return vec2(\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture)\n  );\n}\n\n\n\n"),I.setShaderModule("GLSLMath.glsl",'\n\n<%include file="stack-gl/transpose.glsl"/>\n\n  ////////////////////////////////////////\n  \n  struct Xfo2d {\n    vec2 tr;\n    float rot;\n    vec2 sc;\n  };\n\n  vec2 rotateVec2(float rot, vec2 vec){\n    float cosa = cos(rot);\n    float sina = sin(rot);\n    return vec2(vec.x * cosa - vec.y * sina, vec.x * sina + vec.y * cosa);\n  }\n\n  vec2 Xfo2D_transformVec2(Xfo2d xfo2d, vec2 pos){\n    return xfo2d.tr + rotateVec2(xfo2d.rot, pos * xfo2d.sc);\n  }\n\n  ////////////////////////////////////////\n\n\n  vec4 quat_fromAxisAndAngle(vec3 axis, float angle) {\n    float halfAngle = angle / 2.0;\n    vec3 vec = axis* sin(halfAngle);\n    return vec4(vec.x, vec.y, vec.z, cos(halfAngle));\n  }\n\n  vec4 quat_conjugate(vec4 quat) {\n    return vec4(-quat.x, -quat.y, -quat.z, quat.w);\n  }\n\n  vec4 quat_multiply(vec4 lhs, vec4 rhs) {\n    float ax = lhs.x;\n    float ay = lhs.y;\n    float az = lhs.z;\n    float aw = lhs.w;\n    float bx = rhs.x;\n    float by = rhs.y;\n    float bz = rhs.z;\n    float bw = rhs.w;\n    return vec4(\n      ax * bw + aw * bx + ay * bz - az * by,\n      ay * bw + aw * by + az * bx - ax * bz,\n      az * bw + aw * bz + ax * by - ay * bx,\n      aw * bw - ax * bx - ay * by - az * bz\n    );\n  }\n\n  vec3 quat_rotateVec3(vec4 quat, vec3 rhs) {\n    vec4 vq = vec4(rhs.x, rhs.y, rhs.z, 0.0);\n    vec4 pq = quat_multiply(quat_multiply(quat, vq), quat_conjugate(quat));\n    return vec3(pq.x, pq.y, pq.z);\n  }\n\n\n  mat4 tr_toMat4(vec3 tr) {\n    // Note: GLSL matrices are transposed compared to the matrices in ZeaEngine\n    vec4 col0 = vec4(1.0, 0.0, 0.0, 0.0);\n    vec4 col1 = vec4(0.0, 1.0, 0.0, 0.0);\n    vec4 col2 = vec4(0.0, 0.0, 1.0, 0.0);\n    vec4 col3 = vec4(tr, 1.0);\n    return mat4(col0, col1, col2, col3);\n  }\n\n  mat4 quat_toMat4(vec4 quat) {\n\n    float x2 = quat.x + quat.x;\n    float y2 = quat.y + quat.y;\n    float z2 = quat.z + quat.z;\n\n    float xx = quat.x * x2;\n    float yx = quat.y * x2;\n    float yy = quat.y * y2;\n    float zx = quat.z * x2;\n    float zy = quat.z * y2;\n    float zz = quat.z * z2;\n    float wx = quat.w * x2;\n    float wy = quat.w * y2;\n    float wz = quat.w * z2;\n\n\n    // Note: GLSL matrices are transposed compared to the matrices in ZeaEngine\n    vec4 col0 = vec4(\n      1.0 - yy - zz,\n      yx - wz,\n      zx + wy,\n      0.0);\n\n    vec4 col1 = vec4(\n      yx + wz,\n      1.0 - xx - zz,\n      zy - wx,\n      0.0);\n\n    vec4 col2 = vec4(\n      zx - wy,\n      zy + wx,\n      1.0 - xx - yy,\n      0.0);\n\n    vec4 col3 = vec4(\n      0.0,\n      0.0,\n      0.0,\n      1.0);\n\n    // return mat4(col0, col1, col2, col3);\n    return transpose(mat4(col0, col1, col2, col3));\n  }\n\n  mat4 sc_toMat4(vec3 sc) {\n    // Note: GLSL matrices are transposed compared to the matrices in ZeaEngine\n    return mat4(\n      sc.x, 0.0,  0.0,  0.0,\n      0.0,  sc.y, 0.0,  0.0,\n      0.0,  0.0,  sc.z, 0.0,\n      0.0,  0.0,  0.0,  1.0);\n  }\n\n  struct Xfo {\n    vec3 tr;\n    vec4 ori;\n    vec3 sc;\n  };\n\n  Xfo xfo_multiply(Xfo xfo, Xfo other){\n    return Xfo(\n      xfo.tr + quat_rotateVec3(xfo.ori, xfo.sc * other.tr),\n      quat_multiply(xfo.ori, other.ori),\n      xfo.sc * other.sc\n    );\n  }\n\n  mat4 xfo_toMat4(Xfo xfo){\n    mat4 sc_mat4 = sc_toMat4(xfo.sc);\n    mat4 ori_mat4  = quat_toMat4(xfo.ori);\n    mat4 tr_mat4  = tr_toMat4(xfo.tr);\n    mat4 result = tr_mat4 * ori_mat4 * sc_mat4;\n    return result;\n  }\n\n'),I.setShaderModule("GLSLCADCurves.glsl","\n\n  // http://cadexchanger.com/download/sdk/doc/dev/html/sdk_data_model_geometry_topology.html#sdk_data_model_geometry_curves\n\n\n\n// http://cadexchanger.com/download/sdk/doc/dev/html/sdk_data_model_geometry_topology.html#sdk_data_model_geometry_surfaces\n\n\nvec2 loadVec2(inout GLSLBinReader reader, sampler2D texture) {\n  return vec2(GLSLBinReader_readFloat(reader, texture),  GLSLBinReader_readFloat(reader, texture));\n}\n\nfloat mapDomain1d(vec2 domain, float param) {\n  float u = domain.x + param * ( domain.y - domain.x );\n  return u;\n}\n\n/////////////////////////////////////////\n// Line\n\nPosNorm calcLinePoint(float param, inout GLSLBinReader reader, sampler2D texture) {\n  vec2 domain = loadVec2(reader, texture);\n  float u = mapDomain1d( domain, param );\n  vec3 pos = vec3(u, 0.0, 0.0);\n  vec3 norm = vec3(1.0, 0.0, 0.0);\n  return PosNorm(pos, norm, CURVE_TYPE_LINE);\n}\n\n\n/////////////////////////////////////////\n// Circle\n\nPosNorm calcCirclePoint(float param, inout GLSLBinReader reader, sampler2D texture) {\n  vec2 domain = loadVec2(reader, texture);\n  float radius = GLSLBinReader_readFloat(reader, texture);\n\n  float u = mapDomain1d( domain, param );\n  vec3 pos = vec3(cos(u) * radius, sin(u) * radius, 0.0);\n  vec3 norm = vec3(-sin(u), cos(u), 0.0);\n  return PosNorm(pos, norm, CURVE_TYPE_CIRCLE);\n}\n\n\n\n/////////////////////////////////////////\n// Elipse3d\n// An ellipse is a periodic curve parametrized as follows: C(t) = P + X * R_major * cos(t) + Y * R_minor * sin(t), where\n\n// P is an origin point,\n// X and Y are directions,\n// R_major and R_minor are major and minor radii,\n// t belongs to [0, 2 * PI].\n// Note that major radius is always along the X-axis and minor radius - along the Y-axis, and that with t=0 the point corresponds to a major radius.\n\n\nPosNorm calcElipsePoint(float param, inout GLSLBinReader reader, sampler2D texture) {\n  vec2 domain = loadVec2(reader, texture);\n  float u = mapDomain1d( domain, param );\n  float minorRadius = GLSLBinReader_readFloat(reader, texture);\n  float majorRadius = GLSLBinReader_readFloat(reader, texture);\n  vec3 pos = vec3(cos(u) * majorRadius, sin(u) * minorRadius, 0.0);\n  vec3 norm = normalize(vec3(-sin(u) * majorRadius, cos(u) * minorRadius, 0.0)); // TODO: fix this broken line.\n\n  // pos = vec3(float(minorRadius));\n\n  return PosNorm(pos, norm, CURVE_TYPE_ELIPSE);\n}\n\n"),I.setShaderModule("GLSLCADSimpleSurfaces.glsl","\n\n  // http://cadexchanger.com/download/sdk/doc/dev/html/sdk_data_model_geometry_topology.html#sdk_data_model_geometry_surfaces\n\n\n/////////////////////////////////////////\n// Plane\n// A plane is parametrized as follows: S(u,v) = P + u * dX + v * dY, where\n\n// P is an origin point,\n// dX and dY are directions (unit vectors) of X and Y axes respectively,\n// u, v belongs to (-Infinity, +Infinity).\n\nPosNorm calcPlaneSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  box2 domain = loadBox2(reader, texture);\n  vec2 uv = mapDomain(domain, params);\n\n  vec3 pos = vec3(uv.x, uv.y, 0.0);\n  vec3 normal = vec3(0.0, 0.0, 1.0);\n\n  return PosNorm(pos, normal, SURFACE_TYPE_PLANE);\n}\n\n/////////////////////////////////////////\n// Poly Plane\n// A plane is parametrized as follows: S(u,v) = P + u * dX + v * dY, where\n\n// P is an origin point,\n// dX and dY are directions (unit vectors) of X and Y axes respectively,\n// u, v belongs to (-Infinity, +Infinity).\n\nPosNorm calcPolyPlaneSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  // Domain does not need to be mapped in this case.\n  vec2 uv = params;\n  vec2 p0 = GLSLBinReader_readVec2(reader, texture);\n  vec2 p1 = GLSLBinReader_readVec2(reader, texture);\n  vec2 p2 = GLSLBinReader_readVec2(reader, texture);\n  vec2 p3 = GLSLBinReader_readVec2(reader, texture);\n\n  vec2 pos = mix(mix(p0, p1, uv.x), mix(p3, p2, uv.x), uv.y);\n  vec3 normal = vec3(0.0, 0.0, 1.0);\n\n  return PosNorm(vec3(pos, 0.0), normal, SURFACE_TYPE_POLY_PLANE);\n}\n\n\n/////////////////////////////////////////\n// Fan\n// A plane is parametrized as follows: S(u,v) = P + u * dX + v * dY, where\n\n// P is an origin point,\n// dX and dY are directions (unit vectors) of X and Y axes respectively,\n// u, v belongs to (-Infinity, +Infinity).\n\nPosNorm calcFanSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  // Domain does not need to be mapped in this case.\n  vec2 uv = params;\n  // Skip forward 2 values for each vertex.\n  reader.offset += int(2.0 * floor(v_vertexCoord.x));\n  vec2 pos = GLSLBinReader_readVec2(reader, texture);\n  vec3 normal = vec3(0.0, 0.0, 1.0);\n\n  return PosNorm(vec3(pos, 0.0), normal, SURFACE_TYPE_FAN);\n}\n\n\n\n/////////////////////////////////////////\n// Cone\n// A conical surface is parametrized as follows: S(u,v) = P + r * cos(u) * Dx + r * sin(u) * Dy + v * cos(φ) * Dz, where\n\n// P is an origin point,\n// Dx, Dy and Dz are directions (unit vectors) of X, Y and Z axes respectively,\n// φ - semi-angle, i.e. an angle between Dz and any generatrix,\n// r = R + v * sin(φ), i.e. a radius of a circle at respective parameter v,\n// u belongs to [0, 2 * PI],\n// v belongs to (-infinity, +infinity).\n// U-parameter is an angle along the circle at a given parameter V and V-parameter is a length along the cone. Thus, U-isolines are lines and V-isoline are circles.\n\n// V-isoline at V=0 is a circle of radius R in the plane defined by an axis placement.\n\n// Conical surface contains both halfs of mathematical cone.\n\n// Conical surface is U-periodical with period 2 * PI. At a cone apex, r equals 0, hence V-parameter of an apex equals -R / sin(φ)\n\n\nPosNorm calcConeSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  box2 domain = loadBox2(reader, texture);\n  float r = GLSLBinReader_readFloat(reader, texture);\n  float semiAngle = GLSLBinReader_readFloat(reader, texture);\n  vec2 uv = mapDomain(domain, params);\n\n  float u = uv.x;\n  float v = uv.y;\n  float r_at_v = r + v * sin(semiAngle);\n  vec3 pos = vec3(r_at_v * cos(u), r_at_v * sin(u), v * cos(semiAngle));\n  vec3 normal = normalize(vec3(cos(u)*cos(semiAngle), sin(u)*cos(semiAngle), -sin(semiAngle)));\n  return PosNorm(pos, normal, SURFACE_TYPE_CONE);\n}\n\n\n/////////////////////////////////////////\n// Cylinder\n// A cylindrical surface is parametrized as follows: S(u,v) = P + R * cos(u) * dX + R * sin(u) * dY + v * dZ, where\n\n// P is an origin point,\n// dX, dY and dZ are directions (unit vectors) of X, Y and Z axes respectively,\n// R is a radius,\n// u belongs to [0, 2 * PI],\n// v belongs to (-infinity, +infinity).\n\n\nPosNorm calcCylinderSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  box2 domain = loadBox2(reader, texture);\n  float r = GLSLBinReader_readFloat(reader, texture);\n  vec2 uv = mapDomain(domain, params);\n\n  vec3 normal = vec3(cos(uv.x), sin(uv.x), 0.0);\n  vec3 pos = r * normal + vec3(0.0, 0.0, uv.y);\n\n  return PosNorm(pos, normal, SURFACE_TYPE_CYLINDER);\n}\n\n\n/////////////////////////////////////////\n// Sphere\n// A spherical surface is parametrized as follows: S(u,v) = P + R * cos(v) * (cos(u) * Dx + sin(u) * Dy) + R * sin(v) * Dz, where\n\n// P is an origin point,\n// Dx, Dy and Dz are directions (unit vectors) of X, Y and Z axes respectively,\n// R is a radius,\n// u belongs to [0, 2 * PI],\n// v belongs to [-PI/2, +PI/2].\n// U-parameter is an angle of rotation around the Dz axis counterclockwise (i.e. similar to longitude on the Earth), and V-parameter is an angle between plane defined by an axis placement and line from P to a point on a sphere (i.e. latitude). Thus, U-isolines are semi-circles and V-isoline are circles.\n\n// V-isoline at V=0 is a circle of radius R in the plane defined by an axis placement. U-isoline at U=0 corresponds to a semi-circle from south to north pole.\n\n// Spherical surface is U-periodical with period 2 * PI.\n\n// If a face lies on a full spherical surface its boundary wire will contain two a degenerated edges corresponding to the south and north poles (V equals -PI/2 and PI/2 respectively), and a seam-edge.\n\n\nPosNorm calcSphereSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  box2 domain = loadBox2(reader, texture);\n  vec2 uv = mapDomain(domain, params);\n\n  float r = GLSLBinReader_readFloat(reader, texture);\n\n  float u = uv.x;\n  float v = uv.y;\n  vec3 normal = vec3(cos(v) * cos(u), cos(v) * sin(u), sin(v));\n  vec3 pos = r * normal;\n\n  return PosNorm(pos, normal, SURFACE_TYPE_SPHERE);\n}\n\n/////////////////////////////////////////\n// Torus\n\n// A toroidal surface is parametrized as follows: S(u,v) = (R1 + R2 * cos(v)) * (cos(u) * Dx + sin(u) * Dy) + R2 * sin(v) * Dz, where\n\n// R1 is a major radius,\n// R2 is a minor radius,\n// u belongs to [0, 2 * PI],\n// v belongs to [0, 2 * PI],\n// U-parameter is an angle when rotating around the Dz axis counterclockwise, and V-parameter is an angle in circular section at a given parameter U. Thus, U-isolines circles lying in the plane containing Z axis and V-isolines are circles in the planes perpendicular to Z axis.\n\n// V-isoline at V=0 is a circle of radius (R1 + R2) in the plane defined by an axis placement. U-isoline at U=0 is a circle of radius R2 in the plane containing Z and X axes.\n\n// Radii R1 and R2 must be positive. If R2 > R1 then toroidal surface will be self-intersecting.\n\n// Toroidal surface is both U- and V-periodical with periods 2 * PI.\n\n// If a face lies on a full toroidal surface its boundary wire will contain two seam-edges, corresponding to U=0 and U=2*PI, and V=0 and V=2*PI respectively.\n\n\nPosNorm calcTorusSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  box2 domain = loadBox2(reader, texture);\n  vec2 uv = mapDomain(domain, params);\n\n  float majorRadius = GLSLBinReader_readFloat(reader, texture);\n  float minorRadius = GLSLBinReader_readFloat(reader, texture);\n  float u = uv.x;\n  float v = uv.y;\n  vec3 pos = (majorRadius + minorRadius * cos(v)) * vec3(cos(u), sin(u), 0.0) + vec3(0.0, 0.0, minorRadius * sin(v));\n\n  vec3 normal = vec3(cos(v) * cos(u), cos(v) * sin(u), sin(v));\n  // vec3 pos = majorRadius * normal;\n\n  return PosNorm(pos, normal, SURFACE_TYPE_TORUS);\n}\n\n"),I.setShaderModule("GLSLCADCompoundSurfaces.glsl","\n\n/////////////////////////////////////////\n// LinearExtrusion\n\nPosNorm calcLinearExtrusionSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  box2 domain = loadBox2(reader, texture);\n  \n  int curve_index = GLSLBinReader_readUIntFrom2xUFloat16(reader, texture);\n\n  vec3 curve_tr = vec3(\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture)\n  );\n  vec4 curve_ori = vec4(\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture)\n    );\n  vec3 curve_sc = vec3(\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture)\n  );\n  vec2 uv = mapDomain(domain, params);\n\n  PosNorm curveResult = evalCADCurve3d(curve_index, uv.x);\n  \n  vec3 pos = quat_rotateVec3(curve_ori, curveResult.pos * curve_sc) + curve_tr;\n  pos.z += uv.y;\n\n  vec3 normal = normalize(cross(vec3(0.0, 0.0, 1.0), quat_rotateVec3(curve_ori, curveResult.normal)));\n\n  return PosNorm(pos, normal, SURFACE_TYPE_LINEAR_EXTRUSION);\n}\n\n\n/////////////////////////////////////////\n// Revolution\nPosNorm calcRevolutionSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture, bool flipDomain) {\n  box2 domain = loadBox2(reader, texture);\n\n  int curve_index = GLSLBinReader_readUIntFrom2xUFloat16(reader, texture);\n\n  vec3 curve_tr = vec3(\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture)\n  );\n  vec4 curve_ori = vec4(\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture)\n    );\n  vec3 curve_sc = vec3(\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture)\n  );\n  vec2 uv = mapDomain(domain, params);\n\n  vec3 axis = vec3(0.0, 0.0, 1.0);\n  PosNorm curveResult;\n  vec4 rev;\n  if (flipDomain) {\n    curveResult = evalCADCurve3d(curve_index, uv.x);\n    rev = quat_fromAxisAndAngle(axis, uv.y);\n  } else {\n    curveResult = evalCADCurve3d(curve_index, uv.y);\n    rev = quat_fromAxisAndAngle(axis, uv.x);\n  }\n\n  vec3 p_t = quat_rotateVec3(curve_ori, curveResult.pos * curve_sc) + curve_tr;\n  vec3 pos = quat_rotateVec3(rev, p_t);\n\n  vec3 p_n = quat_rotateVec3(rev, quat_rotateVec3(curve_ori, curveResult.normal));\n  \n  vec3 tangent;\n  if (abs(1.0 - dot(p_n, axis)) > 0.001) {\n    tangent = cross(p_n, axis);\n  } else {\n    tangent = cross(pos, axis);\n  }\n  // TODO: Find a conclusive test file that demonstrates this as correct.\n  // I think it is the master cylinder sample.\n  // vec3 normal = normalize(cross(p_n, tangent));\n  vec3 normal = normalize(cross(tangent, p_n));\n\n  // vec3 pos;\n  // vec3 normal;\n  // pos.x = float(partA);\n  // pos.y = float(partB);\n  // pos.z = float(curve_index);\n  return PosNorm(pos, normal, SURFACE_TYPE_REVOLUTION);\n}\n\n\n/////////////////////////////////////////\n// OffsetSurface\n\nPosNorm calcOffsetSurfaceSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  box2 domain = loadBox2(reader, texture);\n  int surfaceId = GLSLBinReader_readUInt(reader, texture);\n  float offset = GLSLBinReader_readFloat(reader, texture);\n  vec2 uv = mapDomain(domain, params);\n\n/*\n  GLSLBinReader subSurfaceReader = reader;\n  subSurfaceReader.start = \n  GLSLBinReader_init(reader, surfaceDataTextureSize, region, start, 32);\n\n  vec3 p = calcCurvePoint(uv.x);\n  vec3 pos = p + dir * (dist * uv.y);\n  \n*/\n  vec3 pos;\n  vec3 normal;\n  return PosNorm(pos, normal, SURFACE_TYPE_OFFSET_SURFACE);\n}\n\n\n\n"),I.setShaderModule("GLSLNURBS.glsl","\n\n#define MAX_KNOTS 256\n// Note: The BRP motorcycle features many surfaces of degree 15.\n#define MAX_DEGREE 16\n\nfloat kp(int index, inout GLSLBinReader r, sampler2D t, int offset) {\n  return GLSLBinReader_readFloat(r, t, offset+index);\n}\n\n#ifdef EXPORT_KNOTS_AS_DELTAS\n\nint findSpan(float u, in int degree, in int numKnots, int kpOff, inout GLSLBinReader r, sampler2D t, out highp float knots[MAX_DEGREE*2+1]) {\n  \n  float nextKnot = kp(0, r, t, kpOff);\n  float knot = nextKnot;\n\n  int span = 1;\n  int n = numKnots - degree - 1;\n  // Linear Search...\n  for (; span<n; span++){\n    nextKnot += kp(span, r, t, kpOff);\n    if (span > degree && u < nextKnot){\n      span--;\n      break;\n    }\n    knot = nextKnot;\n  }\n  if (span == n) {\n    span--;\n  }\n\n\n  //Calculate knot values\n  knots[degree] = knot;\n  float left = knot;\n  float right = knot; \n  for (int i=1; i<=degree; i++) {\n    left -= kp(span-i+1, r, t, kpOff);\n    right += kp(span+i, r, t, kpOff);\n    knots[degree-i] = left;\n    knots[degree+i] = right;\n  }\n\n  return span;\n}\n\nvoid calcBasisValues(in float u, in int degree, in highp float knots[MAX_DEGREE*2+1], out highp float basisValues[MAX_DEGREE+1], out highp float bvD[MAX_DEGREE+1]) {\n  \n  highp vec2 savedTemp;\n  highp float left[MAX_DEGREE+1];\n  highp float right[MAX_DEGREE+1];\n\n  //Basis[0] is always 1.0\n  basisValues[0] = 1.0;\n  // Calculate basis values\n  for (int i=1; i<=degree; i++) {\n    left[i] = u - knots[degree+1-i];\n    right[i] = knots[degree+i] - u;\n\n    savedTemp.x = 0.0;\n    for (int j=0; j<i; j++) {\n      float rv = right[j+1];\n      float lv = left[i-j];\n      savedTemp.y = basisValues[j] / (rv + lv);\n      basisValues[j] = savedTemp.x + rv * savedTemp.y;\n      savedTemp.x = lv * savedTemp.y;\n    }\n    basisValues[i] = savedTemp.x;\n\n    // Calculate N' if on second to last iteration\n    if (i == degree-1 || degree == 1) {\n      savedTemp.x = 0.0;\n      //Loop through all basis values\n      for (int j=0; j<degree; j++) {\n        // Calculate a temp variable\n        int jr_z = j + 1;\n        //Calculate right side\n        float kp_0 = knots[jr_z + degree];\n        float kp_1 = knots[jr_z];\n        savedTemp.y = (float(degree) * basisValues[j]) / (kp_0 - kp_1);\n        // Calculate derivative value\n        bvD[j] = savedTemp.x - savedTemp.y;\n        // Swap right side to left\n        savedTemp.x = savedTemp.y;\n      }\n      //Save the last der-basis\n      bvD[degree] = savedTemp.x;\n    }\n  }\n}\n\n#else\n\n// http://read.pudn.com/downloads134/sourcecode/math/569665/nurbsR2006b/findspan.c__.htm\n// Note: I have found the 'early outs' in the Three code to be more correct\n// https://github.com/mrdoob/three.js/blob/b8d8a8625465bd634aa68e5846354d69f34d2ff5/examples/js/curves/NURBSUtils.js\nint findSpan(float u, in int degree, in int numKnots, int kpOff, inout GLSLBinReader r, sampler2D t, bool periodic) {\n  \n  // early outs\n  int n = numKnots - degree - 1;\n  if(u >= kp(n, r, t, kpOff))\n    return n-1;\n  if(u <= kp(degree, r, t, kpOff)) {\n    return degree;\n  }\n\n  // Linear Search...\n#ifdef ENABLE_ES3\n  int i = degree; \n  for (; i<n; i++){\n#else\n  // Note: loop values must be constant.\n  // Loops start at 1 because that is the minimum degree for a curve.\n  for (int i = 1; i<MAX_KNOTS; i++){\n    if(i >= degree && i < numKnots-1){\n#endif\n    if (u < kp(i+1, r, t, kpOff)){\n      return i;\n    }\n#ifndef ENABLE_ES3\n  }\n#endif\n  }\n\n  return i;\n}\n\n\nvoid calcBasisValues(in float u, in int span, int degree, int kpOff, int numKnots, inout GLSLBinReader r, sampler2D t, out highp float basisValues[MAX_DEGREE+1], out highp float bvD[MAX_DEGREE+1]) {\n  \n  highp vec2 savedTemp;\n  highp float left[MAX_DEGREE+1];\n  highp float right[MAX_DEGREE+1];\n\n  // Basis[0] is always 1.0\n  basisValues[0] = 1.0;\n  // Calculate basis values\n#ifdef ENABLE_ES3\n  for (int i=1; i<=degree; i++) {\n#else\n  for (int i=1; i<MAX_DEGREE; i++) {\n    if(i > degree) // i<=degree\n      break;\n#endif\n    left[i] = u - kp(span+1-i, r, t, kpOff);\n    right[i] = kp(span+i, r, t, kpOff) - u;\n\n    savedTemp.x = 0.0;\n#ifdef ENABLE_ES3\n    for (int j=0; j<i; j++) {\n#else\n    for (int j=0; j<MAX_DEGREE; j++) {\n      if(j >= i) // j < i\n        break;\n#endif\n      float rv = right[j+1];\n      float lv = left[i-j];\n      savedTemp.y = basisValues[j] / (rv + lv);\n      basisValues[j] = savedTemp.x + rv * savedTemp.y;\n      savedTemp.x = lv * savedTemp.y;\n    }\n    basisValues[i] = savedTemp.x;\n    \n    // Calculate N' if on second to last iteration\n    if (i == degree-1 || degree == 1) {\n      savedTemp.x = 0.0;\n      // Loop through all basis values\n#ifdef ENABLE_ES3\n      for (int j=0; j<degree; j++) {\n#else\n      for (int j=0; j<MAX_DEGREE; j++) {\n        if(j >= degree) // j < degree\n          break;\n#endif\n        // Calculate a temp variable\n        int jr_z = span - degree + j + 1;\n        // Calculate right side\n        float kp_0 = kp(jr_z + degree, r, t, kpOff);\n        float kp_1 = kp(jr_z, r, t, kpOff);\n        savedTemp.y = (float(degree) * basisValues[j]) / (kp_0 - kp_1);\n        // Calculate derivative value\n        bvD[j] = savedTemp.x - savedTemp.y;\n        // Swap right side to left\n        savedTemp.x = savedTemp.y;\n      }\n      // Save the last der-basis\n#ifdef ENABLE_ES3\n      bvD[degree] = savedTemp.x;\n#else\n      if(degree == 1)\n        bvD[1] = savedTemp.x;\n      else if(degree == 2)\n        bvD[2] = savedTemp.x;\n      else if(degree == 3)\n        bvD[3] = savedTemp.x;\n      else if(degree == 4)\n        bvD[4] = savedTemp.x;\n      else if(degree == 5)\n        bvD[5] = savedTemp.x;\n      else if(degree == 6)\n        bvD[6] = savedTemp.x;\n      else if(degree == 7)\n        bvD[7] = savedTemp.x;\n      else if(degree == 8)\n        bvD[8] = savedTemp.x;\n      else if(degree == 9)\n        bvD[9] = savedTemp.x;\n      else if(degree == 10)\n        bvD[10] = savedTemp.x;\n      else if(degree == 11)\n        bvD[11] = savedTemp.x;\n      else if(degree == 12)\n        bvD[12] = savedTemp.x;\n      else if(degree == 13)\n        bvD[13] = savedTemp.x;\n      else if(degree == 14)\n        bvD[14] = savedTemp.x;\n      else if(degree == 15)\n        bvD[15] = savedTemp.x;\n#endif\n    }\n  }\n}\n\n\n#endif\n\n"),I.setShaderModule("GLSLNURBSCurves.glsl","\n\nstruct NURBSCurveData {\n  vec2 domain;\n  bool periodic;\n  int degree;\n  int numCPs;\n  int numKnots;\n\n  int cpStart;\n  int kpStart;\n};\n\nvoid loadNURBSCurve3dData(inout GLSLBinReader reader, sampler2D texture, out NURBSCurveData result) {\n\n  result.domain.x = GLSLBinReader_readFloat(reader, texture);\n  result.domain.y = GLSLBinReader_readFloat(reader, texture);\n  result.degree = GLSLBinReader_readUInt(reader, texture);\n\n  result.numCPs = GLSLBinReader_readUInt(reader, texture);\n  result.numKnots = GLSLBinReader_readUInt(reader, texture);\n  int flags = GLSLBinReader_readUInt(reader, texture);\n  result.periodic = testFlag(flags, CURVE_FLAG_PERIODIC);\n\n  result.cpStart = 2*4; // 2 RGBA pixels of data before the knot values start.\n  result.kpStart = result.cpStart + (result.numCPs*4);\n}\n\nvec4 curve_cp3d(int u, inout GLSLBinReader r, NURBSCurveData d, sampler2D t) {\n  int index = u * 4;\n  return GLSLBinReader_readVec4(r, t, d.cpStart + index);\n}\n\n// https://github.com/akshatamohanty/wildcat-cad/blob/650e18d665ccde3dbc4c78029e35c38951581c92/Source/Geometry/Shaders/ns23_default_plM.fsh\n// https://github.com/mrdoob/three.js/blob/6c7f000734f8579da37fb39e5c2e9e5e2dfb14f8/examples/js/curves/NURBSUtils.js\n\n/*\n  Calculate rational B-Spline curve point. See The NURBS Book, page 134, algorithm A4.3.\n*/\nPosNorm calcNURBSCurve3dPoint(float param, inout GLSLBinReader r, sampler2D t) {\n\n  NURBSCurveData d;\n  loadNURBSCurve3dData(r, t, d);\n\n  float u = d.domain.x + param * ( d.domain.y - d.domain.x ); // linear mapping param->u\n  //if(d.periodic)\n  //    u = wrap(u, kp(0, r, t, d.kpStart), kp(d.numKnots-1, r, t, d.kpStart));\n \n  float bv[MAX_DEGREE+1];\n  float bvds[MAX_DEGREE+1];\n\n#ifdef EXPORT_KNOTS_AS_DELTAS\n  highp float knots[MAX_DEGREE*2+1];\n  int span = findSpan(u, d.degree, d.numKnots, d.kpStart, r, t, knots);\n  //return PosNorm(vec3(span, knots[d.degree], knots[d.degree+1]), vec3(1.0), CURVE_TYPE_NURBS_CURVE);\n  //return PosNorm(vec3(knots[d.degree-1], knots[d.degree], knots[d.degree+1]), vec3(1.0), CURVE_TYPE_NURBS_CURVE);\n  //return PosNorm(vec3(knots[d.degree+1], knots[d.degree+2], knots[d.degree+3]), vec3(1.0), CURVE_TYPE_NURBS_CURVE);\n\n  calcBasisValues(u, d.degree, knots, bv, bvds);\n  // return PosNorm(vec3(bv[0], bv[1], bv[2]), vec3(bv[3], bv[4], bv[5]), CURVE_TYPE_NURBS_CURVE);\n#else\n  int span = findSpan(u, d.degree, d.numKnots, d.kpStart, r, t, d.periodic);\n  // return PosNorm(vec3(float(span)), vec3(1.0), CURVE_TYPE_NURBS_CURVE);\n  // return PosNorm(vec3(kp(span-1, r, t, d.kpStart), kp(span-0, r, t, d.kpStart), kp(span+1, r, t, d.kpStart)), vec3(0.0), CURVE_TYPE_NURBS_CURVE);\n\n  // Invalid knot vectors exist where all the values are identical.\n  if (kp(span, r, t, d.kpStart) == kp(span+1, r, t, d.kpStart)) {\n    for(int x=0; x <= d.degree; x++)\n      bv[x] = 0.0;\n    bv[d.degree] = 1.0;\n  }\n  else {\n    calcBasisValues(u, span, d.degree, d.kpStart, d.numKnots, r, t, bv, bvds);\n  }\n  // return PosNorm(vec3(bv[0], bv[1], bv[2]), vec3(bv[3], bv[4], bv[5]), CURVE_TYPE_NURBS_CURVE);\n#endif\n\n\n  float w = 0.0;\n  vec3 pos = vec3(0.0);\n  vec3 tangent = vec3(0.0);\n\n  int cv0 = (span - d.degree);\n#ifdef ENABLE_ES3\n  for(int x=0; x <= d.degree; x++) {\n#else\n  for(int x=0; x < MAX_DEGREE; x++) {\n    if(x > d.degree) // x<=degree\n      break;\n#endif\n    int index = cv0 + x;\n    vec4 pt = curve_cp3d(index, r, d, t);\n\n    if(d.degree < 3) {\n      // Rhino style evaluation....\n      highp float bvw = bv[x];\n      pos += pt.xyz * bvw;\n      w += pt.w * bvw;\n    }\n    else {\n      // Tiny NURBS/CADEx style evaluation....\n      highp float bvw = pt.w * bv[x];\n      pos += pt.xyz * bvw;\n      w += bvw;\n    }\n\n    tangent += pt.xyz * bvds[x];\n  }\n\n  pos /= w;\n\n\n  // Calc tangent\n  if(d.degree == 1){\n    vec3 pt0 = curve_cp3d(cv0, r, d, t).xyz;\n    vec3 pt1 = curve_cp3d(cv0+1, r, d, t).xyz;\n    tangent = pt1 - pt0;\n  }\n  else {\n    if (length(tangent) < 0.05) {\n\n      float spanLerp = u - knots[span];\n      float spanRange = knots[span+1] - knots[span];\n      int cv = int(floor((spanLerp / spanRange) * float(d.degree-1)));\n\n      vec3 pt0 = curve_cp3d(cv, r, d, t).xyz;\n      vec3 pt1 = curve_cp3d(cv+1, r, d, t).xyz;\n      tangent = pt1 - pt0;\n    }\n  }\n\n  return PosNorm(pos, normalize(tangent), CURVE_TYPE_NURBS_CURVE);\n}\n\n\n\n"),I.setShaderModule("GLSLNURBSSurfaces.glsl","\n\nstruct NURBSSurfaceData {\n  box2 domain;\n  bool periodicU;\n  bool periodicV;\n  int degreeU;\n  int degreeV;\n  int numCPsU;\n  int numCPsV;\n  int numKnotsU;\n  int numKnotsV;\n\n  int cpStart;\n  int kpUStart;\n  int kpVStart;\n};\n\nvoid loadNURBSSurfaceData(inout GLSLBinReader reader, sampler2D texture, out NURBSSurfaceData result) {\n\n  result.domain.p0.x = GLSLBinReader_readFloat(reader, texture);\n  result.domain.p0.y = GLSLBinReader_readFloat(reader, texture);\n  result.domain.p1.x = GLSLBinReader_readFloat(reader, texture);\n\n  result.domain.p1.y = GLSLBinReader_readFloat(reader, texture);\n  result.degreeU = GLSLBinReader_readInt(reader, texture);\n  if(result.degreeU > MAX_DEGREE)\n    result.degreeU = MAX_DEGREE;\n  result.degreeV = GLSLBinReader_readInt(reader, texture);\n  if(result.degreeV > MAX_DEGREE)\n    result.degreeV = MAX_DEGREE;\n  result.numCPsU = GLSLBinReader_readInt(reader, texture);\n\n  result.numCPsV = GLSLBinReader_readInt(reader, texture);\n  result.numKnotsU = GLSLBinReader_readInt(reader, texture);\n  result.numKnotsV = GLSLBinReader_readInt(reader, texture);\n  int flags = GLSLBinReader_readInt(reader, texture);\n  result.periodicU = testFlag(flags, SURFACE_FLAG_PERIODIC_U);\n  result.periodicV = testFlag(flags, SURFACE_FLAG_PERIODIC_V);\n\n  result.cpStart  = 3*4; // 3 RGBA pixels of data before the knot values start.\n  result.kpUStart = result.cpStart + (result.numCPsU*result.numCPsV*4);\n  result.kpVStart = result.kpUStart + result.numKnotsU;\n}\n\nvec4 surface_cp(int u, int v, inout GLSLBinReader r, NURBSSurfaceData d, sampler2D t) {\n  int index = (u + (v * d.numCPsU)) * 4;\n  return GLSLBinReader_readVec4(r, t, d.cpStart + index);\n}\n\n/*\n  Calculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\n*/\nPosNorm calcNURBSSurfacePoint(vec2 params, inout GLSLBinReader r, sampler2D t) {\n\n  vec3 tmp;\n  NURBSSurfaceData d;\n  loadNURBSSurfaceData(r, t, d);\n\n  // ///////////////////////////////////////\n  // // vec3 cp_pos = vec3(params.x + float(d.degreeU), params.y + float(d.degreeV), 0.0 );\n  // vec3 cp_pos = vec3(params.x + float(d.numCPsU), params.y + float(d.numCPsV), 0.0 );\n  // return PosNorm(cp_pos, tmp);\n  // ///////////////////////////////////////\n\n  // ///////////////////////////////////////\n  // int knot_x = int(params.x * float(d.numCPsU-1));\n  // int knot_y = int(params.y * float(d.numCPsV-1));\n  // vec4 cp_pos = surface_cp(knot_x, knot_y, r, d, t);\n  // return PosNorm(cp_pos.xyz, tmp);\n  // ///////////////////////////////////////\n\n  vec2 uv = mapDomain(d.domain, params); // linear mapping params -> uv\n  float u = uv.x;\n  float v = uv.y;\n\n  highp float basisValuesU[MAX_DEGREE+1];\n  highp float basisValuesV[MAX_DEGREE+1];\n  highp float bvdsU[MAX_DEGREE+1];\n  highp float bvdsV[MAX_DEGREE+1];\n  \n#ifdef EXPORT_KNOTS_AS_DELTAS\n  highp float knotsU[MAX_DEGREE*2+1];\n  highp float knotsV[MAX_DEGREE*2+1];\n  int spanU = findSpan(u, d.degreeU, d.numKnotsU, d.kpUStart, r, t, knotsU);\n  int spanV = findSpan(v, d.degreeV, d.numKnotsV, d.kpVStart, r, t, knotsV);\n  calcBasisValues(u, d.degreeU, knotsU, basisValuesU, bvdsU);\n  calcBasisValues(v, d.degreeV, knotsV, basisValuesV, bvdsV);\n\n#else\n  int spanU = findSpan(u, d.degreeU, d.numKnotsU, d.kpUStart, r, t, d.periodicU);\n  int spanV = findSpan(v, d.degreeV, d.numKnotsV, d.kpVStart, r, t, d.periodicV);\n\n  calcBasisValues(u, spanU, d.degreeU, d.kpUStart, d.numKnotsU, r, t, basisValuesU, bvdsU);\n  calcBasisValues(v, spanV, d.degreeV, d.kpVStart, d.numKnotsV, r, t, basisValuesV, bvdsV);\n#endif\n\n  // ///////////////////////////////////////\n  // return PosNorm(vec3(knotsV[11], knotsV[12], knotsV[13]), tmp, SURFACE_TYPE_NURBS_SURFACE);\n  // return PosNorm(vec3(knotsV[14], knotsV[15], knotsV[16]), tmp, SURFACE_TYPE_NURBS_SURFACE);\n  // return PosNorm(vec3(knotsV[17], knotsV[18], knotsV[19]), tmp, SURFACE_TYPE_NURBS_SURFACE);\n  // return PosNorm(vec3(basisValuesU[0], basisValuesU[1], basisValuesU[2]), tmp, SURFACE_TYPE_NURBS_SURFACE);\n  // ///////////////////////////////////////\n\n  ivec2 indices;\n  highp float w = 0.0;\n  highp vec3 pos = vec3(0.0);\n  highp vec3 tangentU = vec3(0.0);\n  highp vec3 tangentV = vec3(0.0);\n  int cvU0 = (spanU - d.degreeU);\n  int cvV0 = (spanV - d.degreeV);\n#ifdef ENABLE_ES3\n  for(int y=0; y <= d.degreeV; y++) {\n#else\n  for(int y=0; y < MAX_DEGREE; y++) {\n     if(y > d.degreeV) // y<=degree\n         break;\n#endif\n    indices.y = cvV0 + y;\n\n#ifdef ENABLE_ES3\n    for(int x=0; x <= d.degreeU; x++) {\n#else\n    for(int x=0; x < MAX_DEGREE; x++) {\n      if(x > d.degreeU) // x<=degree\n        break;\n#endif\n      indices.x = cvU0 + x;\n      \n      vec4 cv = surface_cp(indices.x, indices.y, r, d, t);\n      vec3 pt = cv.xyz;\n      float weight = cv.w;\n\n      float bvU = basisValuesU[x];\n      float bvV = basisValuesV[y];\n\n// #define USE_RHNIO_EVALUATION_MATH 1\n#ifdef USE_RHNIO_EVALUATION_MATH\n      // Rhino style evaluation....\n      float bvw = bvU * bvV;\n      pos += pt * bvw;\n      w += weight * bvw;\n#else\n      // Tiny NURBS/CADEx style evaluation....\n      highp float bvw = weight * bvU * bvV;\n      pos += pt * bvw;\n      w += bvw;\n#endif\n        \n      float bvdU = bvdsU[x];\n      float bvdV = bvdsV[y];\n\n      tangentU += pt * bvdU * bvV;\n      tangentV += pt * bvU * bvdV;\n    }\n  }\n\n  pos /= w;\n\n  ///////////////////////////////////////////////////////\n  // Calculate normal.\n  float spanRangeU = knotsU[d.degreeU + 1] - knotsU[d.degreeU];\n  float spanRangeV = knotsV[d.degreeV + 1] - knotsV[d.degreeV];\n  float eqKnotRangeU = ( d.domain.p1.x - d.domain.p0.x ) / float(d.numKnotsU);\n  float eqKnotRangeV = ( d.domain.p1.y - d.domain.p0.y ) / float(d.numKnotsV);\n  \n  \n  if (spanRangeU / eqKnotRangeU < 0.01) { \n    // In some cases (COOLANT_INLET_PORT_01.ipt_faceWithBlackEdge.)\n    // we have span segment which has close to zero delta, and \n    // so the normals are broken. We want to advace along the \n    // e.g. [0, 0, 0, 0.00001, 1, 3, 3, 3]\n    // length of the span rather than when we have a pinched corner, \n    // where we move along the toher direction.\n    // console.log(v, 'spanRangeU:', spanRangeU, ' eqKnotRangeU:', eqKnotRangeU, spanRangeU / eqKnotRangeU)\n\n    int cvU = cvU0;\n    if (v > d.domain.p1.y - 0.0001) {\n      // If at the end then we grab the end of the pevious row.\n      cvU = cvU0 + d.degreeU - 2;\n    } else {\n      // if the broken normal is at the start of the U range, then \n      // we will grab the next in the row. \n      cvU = cvU0 + 1;\n    }\n\n    float spanLerpV = (u - knotsV[d.degreeV]) / spanRangeV;\n    int cvV = cvV0 + int(floor(spanLerpV * float(d.degreeV)));\n\n    vec3 pt0 = surface_cp(cvU, cvV, r, d, t).xyz;\n    vec3 pt1 = surface_cp(cvU+1, cvV, r, d, t).xyz;\n\n    tangentU = pt1 - pt0;\n  } else if (length(tangentU) < 0.001) {\n    // Note: on values to big, we get false positives.\n    // See: 2_SR00404681_1_RI510090.CATPart.zcad\n    // long narrow nurbs surface above the tail light.\n    // Reduced from 0.05 to 0.001 fixed it.\n\n    // The derivative in the V direction is zero, \n    // so we calculate the linear derivative for the next control points along.\n    \n    int cvV;\n    if (spanV > d.degreeV) {\n      // If at the end then we grab the end of the pevious row.\n      cvV = cvV0 + d.degreeV - 2;\n    } else {\n      // if the broken normal is at the start of the V range, then \n      // we will grab the next in the row. \n      cvV = cvV0 + 1;\n    }\n    \n    float spanLerpU = (u - knotsU[d.degreeU]) / spanRangeU;\n    int cvU = cvU0 + int(floor(spanLerpU * float(d.degreeU)));\n    \n    vec3 pt0 = surface_cp(cvU, cvV, r, d, t).xyz;\n    vec3 pt1 = surface_cp(cvU+1, cvV, r, d, t).xyz;\n\n    tangentU = pt1 - pt0;\n  }\n\n  if (spanRangeV / eqKnotRangeV < 0.01) {\n    // In some cases (COOLANT_INLET_PORT_01.ipt_faceWithBlackEdge.)\n    // we have span segment which has close to zero delta, and \n    // so the normals are broken. We want to advace along the \n    // e.g. [0, 0, 0, 0.00001, 1, 3, 3, 3]\n    // length of the span rather than when we have a pinched corner, \n    // where we move along the toher direction.\n    // console.log(v, 'spanRangeV:', spanRangeV, ' eqKnotRangeV:', eqKnotRangeV, spanRangeV / eqKnotRangeV)\n\n    int cvV = cvV0;\n    if (v > d.domain.p1.y - 0.0001) {\n      // If at the end then we grab the end of the pevious row.\n      cvV = cvV0 + d.degreeV - 2;\n    } else {\n      // if the broken normal is at the start of the V range, then \n      // we will grab the next in the row. \n      cvV = cvV0 + 1;\n    }\n\n    float spanLerpU = (u - knotsU[d.degreeU]) / spanRangeU;\n    int cvU = cvU0 + int(floor(spanLerpU * float(d.degreeU)));\n\n    vec3 pt0 = surface_cp(cvU, cvV, r, d, t).xyz;\n    vec3 pt1 = surface_cp(cvU, cvV+1, r, d, t).xyz;\n\n    tangentV = pt1 - pt0;\n    \n  } else if (length(tangentV) < 0.001) { \n    // Note: on values to big, we get false positives.\n    // See: 2_SR00404681_1_RI510090.CATPart.zcad\n    // long narrow nurbs surface above the tail light.\n    // Reduced from 0.05 to 0.001 fixed it.\n\n    // The derivative in the V direction is close to zero, \n    // so we calculate the linear derivative for the next control points along.\n\n    int cvU = cvU0;\n    if (v > d.domain.p1.y - 0.0001) {\n      // If at the end then we grab the end of the pevious row.\n      cvU = cvU0 + d.degreeU - 2;\n    } else {\n      // if the broken normal is at the start of the U range, then\n      // we will grab the next in the row.\n      cvU = cvU0 + 1;\n    }\n\n    float spanLerpV = (u - knotsV[d.degreeV]) / spanRangeV;\n    int cvV = cvV0 + int(floor(spanLerpV * float(d.degreeV)));\n\n    vec3 pt0 = surface_cp(cvU, cvV, r, d, t).xyz;\n    vec3 pt1 = surface_cp(cvU, cvV+1, r, d, t).xyz;\n\n    tangentV = pt1 - pt0;\n  }\n\n  // vec3 normal = tangentV;\n  // Note: in the gear_box_final_asm.zcad. the nurbs surfaces were all flipped\n  // This is only apparent in cut-away scenes, which the gearbox demo is.\n  // vec3 normal = normalize(cross(tangentV, tangentU));\n  vec3 normal = normalize(cross(tangentU, tangentV));\n\n  return PosNorm(pos, normal, SURFACE_TYPE_NURBS_SURFACE);\n}\n\n");const Ue=I.parseShader("GLEvaluateCADSurfaceShader.vertexShader",'\nprecision highp float;\n\nattribute vec3 positions;\ninstancedattribute float surfaceId;\n\nuniform sampler2D surfaceAtlasLayoutTexture;\nuniform ivec2 surfaceAtlasLayoutTextureSize;\n\nuniform ivec2 surfacesAtlasTextureSize;\n\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n\n/* VS Outputs */\nvarying float v_surfaceId;      // flat\nvarying vec3 v_geomDataCoords;  // flat\nvarying vec2 v_patchSize;       // flat\nvarying vec2 v_vertexCoord;\n\n\n\nvoid main(void) {\n\n  GLSLBinReader reader;\n  GLSLBinReader_init(reader, surfaceAtlasLayoutTextureSize, 32);\n  vec4 patchCoords = GLSLBinReader_readVec4(reader, surfaceAtlasLayoutTexture, int(surfaceId)*8);\n  vec4 surfaceDataCoords = GLSLBinReader_readVec4(reader, surfaceAtlasLayoutTexture, (int(surfaceId)*8)+4);\n\n  vec2 patchPos = patchCoords.xy;\n  v_patchSize = patchCoords.zw;\n\n  v_surfaceId = surfaceId;\n  v_geomDataCoords = surfaceDataCoords.xyz;\n  v_vertexCoord = (positions.xy + 0.5) * v_patchSize;\n\n  vec2 pos = (patchPos + v_vertexCoord) / vec2(surfacesAtlasTextureSize);\n  gl_Position = vec4((pos - 0.5) * 2.0, 0.0, 1.0);\n}\n');I.setShaderModule("GLSLCADSurfaceFragmentShader.glsl","\n\nstruct PosNorm {\n  vec3 pos;\n  vec3 normal;\n  int geomType;\n};\n\n/* VS Outputs */\nvarying float v_surfaceId;      // flat\nvarying vec3 v_geomDataCoords;  // flat\nvarying vec2 v_patchSize;       // flat\nvarying vec2 v_vertexCoord;\n\nuniform sampler2D surfaceDataTexture;\nuniform ivec2 surfaceDataTextureSize;\nuniform int writeNormals;\n\nvec2 initReader(inout GLSLBinReader reader) {\n\n  // compute exact xy coords per pixel by rounding the vertex coord to the nearest integer and then dividing my patch size.\n  // The interpollated xy coords from the quad are not exact because the quad must cover the pixels with some margin.\n\n  vec2 params = vec2(floor(v_vertexCoord.x), floor(v_vertexCoord.y));\n  if(v_patchSize.x > 1.0)\n    params.x /= v_patchSize.x - 1.0;\n  if(v_patchSize.y > 1.0)\n    params.y /= v_patchSize.y - 1.0;\n\n  ivec4 region = ivec4(0, 0, surfaceDataTextureSize.x, surfaceDataTextureSize.y);\n  ivec2 start = ivec2(v_geomDataCoords.xy);\n  int flags = int(v_geomDataCoords.z);\n  if(testFlag(flags, SURFACE_FLAG_FLIPPED_UV))  {\n    float tmp = params.x;\n    params.x = params.y;\n    params.y = tmp;\n  }\n\n  GLSLBinReader_init(reader, surfaceDataTextureSize, region, start, 32);\n\n  return params;\n}\n\n\nstruct box2 {\n  vec2 p0;\n  vec2 p1;\n};\n\nbox2 loadBox2(inout GLSLBinReader reader, sampler2D texture) {\n  box2 domain;\n  domain.p0.x = GLSLBinReader_readFloat(reader, texture);\n  domain.p0.y = GLSLBinReader_readFloat(reader, texture);\n  domain.p1.x = GLSLBinReader_readFloat(reader, texture);\n  domain.p1.y = GLSLBinReader_readFloat(reader, texture);\n  return domain;\n}\n\nvec2 mapDomain(box2 domain, vec2 params) {\n  return domain.p0 + params * ( domain.p1 - domain.p0 );\n}\n\n\n");class Ne extends F{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ue,this.__shaderStages.FRAGMENT_SHADER=I.parseShader("GLEvaluateSimpleCADSurfaceShader.fragmentShader",'\n// #extension GL_EXT_draw_buffers : require\nprecision highp float;\n\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="GLSLCADSurfaceFragmentShader.glsl"/>\n\n<%include file="GLSLCADSimpleSurfaces.glsl"/>\n\nPosNorm evalCADSurfaces(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  // Evaluate the surface per vertex\n  int geomType = GLSLBinReader_readInt(reader, texture);\n\n  PosNorm posNorm;\n  if(geomType == SURFACE_TYPE_PLANE) {\n    posNorm = calcPlaneSurfacePoint(params, reader, texture);\n  } else if(geomType == SURFACE_TYPE_POLY_PLANE) {\n    posNorm = calcPolyPlaneSurfacePoint(params, reader, texture);\n  } else if(geomType == SURFACE_TYPE_FAN) {\n    posNorm = calcFanSurfacePoint(params, reader, texture);\n  } else if(geomType == SURFACE_TYPE_CONE) {\n    posNorm = calcConeSurfacePoint(params, reader, texture);\n  } else if(geomType == SURFACE_TYPE_CYLINDER) {\n    posNorm = calcCylinderSurfacePoint(params, reader, texture);\n  } else if(geomType == SURFACE_TYPE_SPHERE) {\n    posNorm = calcSphereSurfacePoint(params, reader, texture);\n  } else if(geomType == SURFACE_TYPE_TORUS) {\n    posNorm = calcTorusSurfacePoint(params, reader, texture);\n  }\n  return posNorm;\n}\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n  \n  GLSLBinReader reader;\n  vec2 xy = initReader(reader);\n  PosNorm posNorm = evalCADSurfaces(xy, reader, surfaceDataTexture);\n\n  if(writeNormals == 1) {\n    fragColor = vec4(posNorm.normal, float(posNorm.geomType));\n  }\n  else {\n    fragColor = vec4(posNorm.pos, float(posNorm.geomType));\n  }\n  // gl_FragData[0] = vec4(posNorm.pos, 1.0);\n  // gl_FragData[1] = vec4(posNorm.normal, 1.0);\n\n  // fragColor.r = v_geomDataCoords.x;\n  // fragColor.g = v_geomDataCoords.y;\n  // fragColor.r = floor(v_vertexCoord.x);\n  // fragColor.g = floor(v_vertexCoord.y);\n  // fragColor.b = v_patchSize.x;\n  // fragColor.a = v_patchSize.y;\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize()}}class ze extends F{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ue,this.__shaderStages.FRAGMENT_SHADER=I.parseShader("GLEvaluateCompoundCADSurfaceShader.fragmentShader",'\n// #extension GL_EXT_draw_buffers : require\nprecision highp float;\n\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n<%include file="GLSLCADSurfaceFragmentShader.glsl"/>\n\n<%include file="GLSLMath.glsl"/>\n\nuniform sampler2D curvesAtlasTexture;\nuniform ivec2 curvesAtlasTextureSize;\nuniform sampler2D curveTangentsTexture;\nuniform sampler2D curvesAtlasLayoutTexture;\nuniform ivec2 curvesAtlasLayoutTextureSize;\n\nvec3 getCurveVertex(ivec2 curvePatchCoords, int vertexCoord) {\n  return fetchTexel(curvesAtlasTexture, curvesAtlasTextureSize, ivec2(curvePatchCoords.x + vertexCoord, curvePatchCoords.y)).rgb;\n}\n\nvec3 getCurveTangent(ivec2 curvePatchCoords, int vertexCoord) {\n  return fetchTexel(curveTangentsTexture, curvesAtlasTextureSize, ivec2(curvePatchCoords.x + vertexCoord, curvePatchCoords.y)).rgb;\n}\n\nPosNorm evalCADCurve3d(int curveId, float u) {\n\n  GLSLBinReader curveLayoutDataReader;\n  GLSLBinReader_init(curveLayoutDataReader, curvesAtlasLayoutTextureSize, 32);\n  ivec4 curvePatch = ivec4(GLSLBinReader_readVec4(curveLayoutDataReader, curvesAtlasLayoutTexture, curveId * 8));\n\n  float t = float(curvePatch.z - 1) * u;\n  int vertexId0 = min(int(floor(t + 0.5)), curvePatch.z - 1);\n  // int vertexId1 = floor(t) + 1.0;\n  // float lerp = t - floor(t);\n\n  vec3 p0 = getCurveVertex(curvePatch.xy, vertexId0);\n  // vec3 p1 = getCurveVertex(curvePatch.xy, vertexId1);\n  vec3 t0 = getCurveTangent(curvePatch.xy, vertexId0);\n  // vec3 t1 = getCurveTangent(curvePatch.xy, vertexId1);\n\n  PosNorm res;\n  res.pos = p0;//mix(p0, p1, lerp);\n  res.normal = normalize(t0);//mix(t0, t1, lerp));\n  res.geomType = 0;\n\n  // res.pos.x = u;\n  // res.pos.y = float(curveId);\n  // res.pos.x = float(curvePatch.x);\n  // res.pos.y = float(curvePatch.y);\n  // res.pos.z = float(curvePatch.z);\n  return res;\n}\n\n\n<%include file="GLSLCADCompoundSurfaces.glsl"/>\n\nPosNorm evalCADSurfaces(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  // Evaluate the surface per vertex\n  int geomType = GLSLBinReader_readInt(reader, texture);\n\n  PosNorm posNorm;\n  if(geomType == SURFACE_TYPE_LINEAR_EXTRUSION) {\n    posNorm = calcLinearExtrusionSurfacePoint(params, reader, texture);\n  } else if(geomType == SURFACE_TYPE_REVOLUTION) {\n    posNorm = calcRevolutionSurfacePoint(params, reader, texture, false);\n  } else if(geomType == SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN) {\n    posNorm = calcRevolutionSurfacePoint(params, reader, texture, true);\n  } \n  \n  return posNorm;\n}\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n  \n  GLSLBinReader reader;\n  vec2 xy = initReader(reader);\n  PosNorm posNorm = evalCADSurfaces(xy, reader, surfaceDataTexture);\n\n  if(writeNormals == 1) {\n    fragColor = vec4(posNorm.normal, float(posNorm.geomType));\n  }\n  else {\n    fragColor = vec4(posNorm.pos, float(posNorm.geomType));\n  }\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize()}}class Xe extends F{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ue,this.__shaderStages.FRAGMENT_SHADER=I.parseShader("GLEvaluateNURBSCADSurfaceShader.fragmentShader",'\n// #extension GL_EXT_draw_buffers : require\nprecision highp float;\n\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n<%include file="GLSLCADSurfaceFragmentShader.glsl"/>\n\n<%include file="GLSLNURBS.glsl"/>\n<%include file="GLSLNURBSSurfaces.glsl"/>\n\nPosNorm evalCADSurfaces(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  // Evaluate the surface per vertex\n  int geomType = GLSLBinReader_readInt(reader, texture);\n\n  PosNorm posNorm;\n  if(geomType == SURFACE_TYPE_NURBS_SURFACE) {\n    posNorm = calcNURBSSurfacePoint(params, reader, texture);\n  }\n  \n  return posNorm;\n}\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n  \n  GLSLBinReader reader;\n  vec2 xy = initReader(reader);\n  PosNorm posNorm = evalCADSurfaces(xy, reader, surfaceDataTexture);\n\n  if(writeNormals == 1) {\n    fragColor = vec4(posNorm.normal, float(posNorm.geomType));\n  }\n  else {\n    fragColor = vec4(posNorm.pos, float(posNorm.geomType));\n  }\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize()}}I.setShaderModule("GLSLCADConstants.glsl","\n  const int SURFACE_FLAG_PERIODIC_U = 1; // 1<<0;\n  const int SURFACE_FLAG_PERIODIC_V = 2; // 1<<1;\n  const int SURFACE_FLAG_UNUSED2 = 4; // 1<<2;\n  const int SURFACE_FLAG_UNUSED3 = 8; // 1<<3;\n  const int SURFACE_FLAG_FLIPPED_NORMAL = 16; // 1<<4\n  const int SURFACE_FLAG_FLIPPED_UV = 32; // 1<<5\n  const int SURFACE_FLAG_COST_IS_DETAIL_U = 64; // 1<<6;\n  const int SURFACE_FLAG_COST_IS_DETAIL_V = 128; // 1<<7;\n\n  const int BODY_FLAG_CUTAWAY = 256; // 1<<8\n  const int BODY_FLAG_INVISIBLE = 512; // 1<<9\n\n  const int CURVE_FLAG_PERIODIC = 1; // 1<<0;\n  const int CURVE_FLAG_UNUSED2 = 4; // 1<<2;\n  const int CURVE_FLAG_COST_IS_DETAIL = 8;//1<<3;\n\n\n  const int SURFACE_TYPE_PLANE = 0;\n  const int SURFACE_TYPE_CONE = 1;\n  const int SURFACE_TYPE_CYLINDER = 2;\n  const int SURFACE_TYPE_SPHERE = 3;\n  const int SURFACE_TYPE_TORUS = 4;\n  const int SURFACE_TYPE_LINEAR_EXTRUSION = 5;\n  const int SURFACE_TYPE_REVOLUTION = 6;\n  const int SURFACE_TYPE_BEZIER_SURFACE = 7;\n  const int SURFACE_TYPE_NURBS_SURFACE = 8;\n  const int SURFACE_TYPE_OFFSET_SURFACE = 9;\n  const int SURFACE_TYPE_TRIMMED_RECT_SURFACE = 10;\n\n  const int SURFACE_TYPE_POLY_PLANE = 14;\n  const int SURFACE_TYPE_FAN = 15;\n  const int SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN = 16;\n\n\n  const int CURVE_TYPE_LINE = 20;\n  const int CURVE_TYPE_CIRCLE = 21;\n  const int CURVE_TYPE_ELIPSE = 22;\n  // const int CURVE_TYPE_HYPERBOLA = 23;\n  // const int CURVE_TYPE_PARABOLA = 24;\n  // const int CURVE_TYPE_BEZIERCURVE = 25;\n  const int CURVE_TYPE_NURBS_CURVE = 26;\n  // const int CURVE_TYPE_OFFSET_CURVE = 27;\n  // const int CURVE_TYPE_TRIMMED_CURVE = 28;\n\n\n  const int geomLibraryHeaderSize = 4; // 2 pixels at the start of the GeomLibrary and CurveLibrary\n\n  // [bodyDescId, surfaceId, cadBodyDesc.xy], [glmaterialcoords.xy][tr-xyz], [ori], [sc], [highlight], [cutPlane]\n  const int pixelsPerCADBody = 7;\n"),I.setShaderModule("GLSLCADGeomDrawing.vertexShader.glsl",'\n\n\nuniform sampler2D cadBodiesTexture;\nuniform int cadBodiesTextureSize_vert;\n  \nvec4 getCADBodyPixel(int cadBodyId, int pixelOffset) {\n  int offset = cadBodyId * pixelsPerCADBody;\n  ivec2 start;\n  start.y += offset / cadBodiesTextureSize_vert;\n  start.x = imod(offset, cadBodiesTextureSize_vert);\n  return fetchTexel(cadBodiesTexture, ivec2(cadBodiesTextureSize_vert), ivec2(start.x + pixelOffset, start.y));\n}\n\n<%include file="GLSLMath.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n\n\nconst int pixelsPerDrawItem = 10; // The number of RGBA pixels per draw item.\nconst int valuesPerSurfaceTocItem = 9;\nconst int bytesPerValue = 4; // 32 bit floats\n\n// Before enabling this, enable the 2nd vertex attribute (drawItemTexAddr)\n// in the Draw shader and in the GLDrawSet, and in the GLCADAssetWorker\n#define CALC_GLOBAL_XFO_DURING_DRAW\n#ifdef CALC_GLOBAL_XFO_DURING_DRAW\n\nmat4 getCADBodyMatrix(int cadBodyId) {\n  vec3 body_tr = getCADBodyPixel(cadBodyId, 2).rgb;\n  vec4 body_ori = normalize(getCADBodyPixel(cadBodyId, 3));\n  vec3 body_sc = getCADBodyPixel(cadBodyId, 4).rgb;\n  Xfo bodyXfo = Xfo(body_tr, body_ori, body_sc);\n  return xfo_toMat4(bodyXfo);\n  // return mat4(1.0);\n}\n\nuniform sampler2D bodyDescTexture;\nuniform ivec2 bodyDescTextureSize;\n\nGLSLBinReader setupBodyDescReader(ivec2 bodyDescAddr) {\n  GLSLBinReader bodyDescReader;\n  ivec4 region = ivec4(0, 0, bodyDescTextureSize.x, bodyDescTextureSize.y);\n  ivec2 start = ivec2(bodyDescAddr.x, bodyDescAddr.y);\n  GLSLBinReader_init(bodyDescReader, bodyDescTextureSize, region, start, 32);\n  return bodyDescReader;\n}\n\nXfo getDrawItemXfo(ivec2 bodyDescAddr, int drawItemIndexInBody) {\n  GLSLBinReader bodyDescReader = setupBodyDescReader(bodyDescAddr);\n  \n  // Skip over the bbox, numSurfaces and then to the current surface data.  \n  #ifdef ENABLE_BODY_EDGES\n  int offsetOfItemRef = (6/*bbox*/) + (1/*numSurfaces*/) + (1/*numCurves*/) + (drawItemIndexInBody * (1/*id*/ + 10/*xfo*/));\n  #else\n  int offsetOfItemRef = (6/*bbox*/) + (1/*numSurfaces*/) + (drawItemIndexInBody * (1/*id*/ + 10/*xfo*/));\n  #endif\n  #ifdef ENABLE_PER_FACE_COLORS\n  offsetOfItemRef += drawItemIndexInBody * 4/*color*/; // Skip over the color.\n  #endif\n  \n  vec3 surface_tr = vec3(\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+1),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+2),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+3)\n    );\n\n  vec4 surface_ori = normalize(vec4(\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+4),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+5),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+6),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+7)\n    ));\n\n  vec3 surface_sc = vec3(\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+8),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+9),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+10)\n  );\n\n  Xfo surfaceXfo = Xfo(surface_tr, surface_ori, surface_sc);\n  return surfaceXfo;\n\n}\nmat4 getDrawItemMatrix(ivec2 bodyDescAddr, int drawItemIndexInBody) {\n  return xfo_toMat4(getDrawItemXfo(bodyDescAddr, drawItemIndexInBody));\n  // return mat4(1.0);\n}\n\n#else // CALC_GLOBAL_XFO_DURING_DRAW\n\nuniform sampler2D drawItemsTexture;\nuniform ivec2 vert_drawItemsTextureSize;\n\n// The Draw Items texture is laid out with 8 pixels per draw item.\nvec4 getDrawItemData(int offset) {\n  return fetchTexel(drawItemsTexture, vert_drawItemsTextureSize, ivec2(ftoi(drawItemTexAddr.x) + offset, ftoi(drawItemTexAddr.y)));\n}\n\nmat4 getModelMatrix() {\n  // Unpack 3 x 4 matix columns into a 4 x 4 matrix.\n  vec4 col0 = getDrawItemData(0);\n  vec4 col1 = getDrawItemData(1);\n  vec4 col2 = getDrawItemData(2);\n  mat4 result = mat4(col0, col1, col2, vec4(0.0, 0.0, 0.0, 1.0));\n  return transpose(result);\n}\n\n#endif // CALC_GLOBAL_XFO_DURING_DRAW\n\n  '),I.setShaderModule("GLSLCADSurfaceDrawing.vertexShader.glsl",'\n  \n<%include file="GLSLCADGeomDrawing.vertexShader.glsl"/>\n\n\n// GEOM\nuniform sampler2D surfaceAtlasLayoutTexture;\nuniform ivec2 surfaceAtlasLayoutTextureSize;\n\nuniform sampler2D surfacesAtlasTexture;\nuniform ivec2 surfacesAtlasTextureSize;\nuniform sampler2D normalsTexture;\n\nvec4 getSurfaceVertex(vec2 surfacePatchCoords, vec2 vertexCoord) {\n  return fetchTexel(surfacesAtlasTexture, surfacesAtlasTextureSize, ivec2(ftoi(surfacePatchCoords.x + vertexCoord.x), ftoi(surfacePatchCoords.y + vertexCoord.y)));\n}\n\nvec3 getSurfaceNormal(vec2 surfacePatchCoords, vec2 vertexCoord) {\n  return fetchTexel(normalsTexture, surfacesAtlasTextureSize, ivec2(ftoi(surfacePatchCoords.x + vertexCoord.x), ftoi(surfacePatchCoords.y + vertexCoord.y))).rgb;\n}\n\n'),I.setShaderModule("GLSLCADGeomDrawing.fragmentShader.glsl",'\n  uniform sampler2D cadBodiesTexture;\n  uniform int cadBodiesTextureSize_frag;\n  \n  vec4 getCADBodyPixel(int cadBodyId, int pixelOffset) {\n    \n    int offset = cadBodyId * pixelsPerCADBody;\n    ivec2 start;\n    start.y += offset / cadBodiesTextureSize_frag;\n    start.x = imod(offset, cadBodiesTextureSize_frag);\n  \n    return fetchTexel(cadBodiesTexture, ivec2(cadBodiesTextureSize_frag), ivec2(start.x + pixelOffset, start.y));\n  }\n  \n  // Is this still used?\n  uniform sampler2D drawItemsTexture;\n  uniform ivec2 frag_drawItemsTextureSize;\n  // The Draw Items texture is laid out with 8 pixels per draw item.\n  vec4 getDrawItemData(int offset) {\n    return fetchTexel(drawItemsTexture, frag_drawItemsTextureSize, ivec2(ftoi(v_drawCoords.x) + offset, ftoi(v_drawCoords.y)));\n  }\n  \n  \n\n//////////////////////////////////////////////\n// Cutaways\n\n<%include file="cutaways.glsl"/>\n\n// bool applyCutaway(int cadBodyId, int flags) {\n//   if (testFlag(flags, BODY_FLAG_CUTAWAY)) {\n//     vec4 cadBodyPixel6 = getCADBodyPixel(cadBodyId, 6);\n//     vec3 cutNormal = cadBodyPixel6.xyz;\n//     float cutPlaneDist = cadBodyPixel6.w;\n//     if (cutaway(v_worldPos, cutNormal, cutPlaneDist)) {\n//         discard;\n//     }\n//     return true;\n//   }\n//   return false;\n// }\n\n// int applyCutaway(int flags, bool backFacing, vec3 cutColor, inout vec4 fragColor) {\n//   bool cut = testFlag(flags, BODY_FLAG_CUTAWAY);\n//   if(cut){\n//     if(cutaway(v_worldPos, cutNormal, planeDist)) {\n//       return 1;\n//     }\n//     if(backFacing){\n//       fragColor = vec4(cutColor, 1.0);\n//       return 2;\n//     }\n//   }\n//   return 0;\n// }\n  '),I.setShaderModule("GLSLCADSurfaceDrawing.fragmentShader.glsl",'\n  \n<%include file="GLSLCADGeomDrawing.fragmentShader.glsl"/>\n\n\nuniform sampler2D materialsTexture;\nuniform ivec2 materialsTextureSize;\n\nvec4 getMaterialValue(vec2 materialCoords, int valueIndex) {\n  return fetchTexel(materialsTexture, materialsTextureSize, ivec2(ftoi(materialCoords.x) + valueIndex, ftoi(materialCoords.y)));\n}\n\n\n//////////////////////////////////////////////\n// Surface Colors\n\nuniform sampler2D bodyDescTexture;\nuniform ivec2 bodyDescTextureSize_frag;\n\nGLSLBinReader setupBodyDescReader(ivec2 bodyDescAddr) {\n  GLSLBinReader bodyDescReader;\n  ivec4 region = ivec4(0, 0, bodyDescTextureSize_frag.x, bodyDescTextureSize_frag.y);\n  ivec2 start = ivec2(bodyDescAddr.x, bodyDescAddr.y);\n  GLSLBinReader_init(bodyDescReader, bodyDescTextureSize_frag, region, start, 32);\n  return bodyDescReader;\n}\n\nvec4 getDrawItemColor(ivec2 bodyDescAddr, int drawItemIndexInBody) {\n  GLSLBinReader bodyDescReader = setupBodyDescReader(bodyDescAddr);\n  \n  #ifdef ENABLE_BODY_EDGES\n  int offsetOfItemRef = (6/*bbox*/) + (1/*numSurfaces*/) + (1/*numCurves*/) + (drawItemIndexInBody * (1/*id*/ + 10/*xfo*/ + 4/*color*/));\n  #else\n  int offsetOfItemRef = (6/*bbox*/) + (1/*numSurfaces*/) + (drawItemIndexInBody * (1/*id*/ + 10/*xfo*/ + 4/*color*/));\n  #endif\n\n  vec4 color = vec4(\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+11),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+12),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+13),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+14)\n  );\n\n  return color;\n}\n\n//////////////////////////////////////////////\n// Trimming\nuniform sampler2D trimSetsAtlasLayoutTexture;\nuniform ivec2 trimSetsAtlasLayoutTextureSize;\n\nuniform sampler2D trimSetAtlasTexture;\nuniform ivec2 trimSetAtlasTextureSize;\n\nbool applyTrim(vec4 trimPatchQuad, inout vec3 trimCoords, int flags) {\n  if(trimPatchQuad.z > 0.0 && trimPatchQuad.w > 0.0){\n    // Remove cobwebs along borders.\n    // Tis appears to eliminate cobwebs along borders of trim sets. \n    // It does indicate that a math eror exists somewhere else\n    // that we would get cobwebs here.\n    // To repro, load Dead Eye Bearing and zoom out.\n    if (v_textureCoord.x < 0.0 || v_textureCoord.x >= 1.0 || v_textureCoord.y < 0.0 || v_textureCoord.y >= 1.0)\n      return true;\n\n    trimCoords.xy = trimPatchQuad.xy + (trimPatchQuad.zw * v_textureCoord);\n\n    vec2 trimUv = (trimCoords.xy) / vec2(trimSetAtlasTextureSize);\n    vec4 trimTexel = texture2D(trimSetAtlasTexture, trimUv);\n\n    trimCoords.z = max(trimTexel.r, trimTexel.g);\n    \n    if (trimTexel.r < 0.5 || trimTexel.g < 0.5) {\n      return true;\n    }\n    return false;\n  }\n  else {\n    // This is a non-trimmed surface, so return false.\n    trimCoords = vec3(-1.0);\n    return false;\n  }\n}\n\n\n');class Me extends F{constructor(e){super(e),this.stack=[{}]}setPreprocessorValue(e){this.getState()[e]=e}clearPreprocessorValue(e){delete this.getState()[e]}getState(){return this.stack[this.stack.length-1]}pushState(){this.stack.push(Object.assign({},this.getState()))}popState(){this.stack.pop(),this.applyOptions()}applyOptions(){const e=[],t=this.getState();for(const r in t)e.push(t[r]);const r=this.__gl.shaderopts.defines+e.join("\n")+"\n";this.__key=r,this.compileForTarget(this.__key,{defines:r})}bind(e){return super.bind(e,this.__key)}}const Ze=I.parseShader("GLDrawCADSurfaceNormalsShader.vertexShader",'\nprecision highp float;\n\nattribute vec3 positions;\ninstancedattribute vec4 drawCoords;  // (DrawItemData Coords (x, y) \n// instancedattribute vec2 drawItemTexAddr;  // Address of the data in the draw item texture. (mat4)\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform ivec2 quadDetail;\nuniform vec3 assetCentroid;\nuniform float normalLength;\n\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="stack-gl/inverse.glsl"/>\n\n<%include file="GLSLCADSurfaceDrawing.vertexShader.glsl"/>\n\nvarying vec4 v_drawCoords;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_textureCoord;\n\nvoid main(void) {\n    int cadBodyId = ftoi(drawCoords.r);\n    int drawItemIndexInBody = ftoi(drawCoords.g);\n    int surfaceId = ftoi(drawCoords.b);\n    int trimSetId = ftoi(drawCoords.a);\n\n    vec2 texCoords = positions.xy + 0.5;\n    \n    v_drawCoords = drawCoords;\n\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\n    vec4 cadBodyPixel1 = getCADBodyPixel(cadBodyId, 1);\n\n    // int bodyDescId = ftoi(cadBodyPixel0.r);\n    int cadBodyFlags = ftoi(cadBodyPixel0.g);\n    \n    //////////////////////////////////////////////\n    // Visibility\n    if(testFlag(cadBodyFlags, BODY_FLAG_INVISIBLE)) {\n        gl_Position = vec4(-3.0, -3.0, -3.0, 1.0);;\n        return;\n    }\n\n    //////////////////////////////////////////////\n    // Transforms\n#ifdef DEBUG_SURFACES\n    mat4 modelMatrix = mat4(1.0);\n    // if(v_surfaceType == SURFACE_TYPE_NURBS_SURFACE) {\n    //     // int drawItemIndexInBody = int(metadata.b+0.5);\n    //     int sideLen = int(ceil(sqrt(float(numSurfacesInLibrary))));\n    //     int x = drawItemIndexInBody % sideLen;\n    //     int y = drawItemIndexInBody / sideLen;\n    //     modelMatrix = mat4(1.0, 0.0, 0.0, 0.0, \n    //                     0.0, 1.0, 0.0, 0.0, \n    //                     0.0, 0.0, 1.0, 0.0,  \n    //                     float(x), float(y), 0.0, 1.0);\n    // }\n#else\n\n#ifdef CALC_GLOBAL_XFO_DURING_DRAW\n    mat4 bodyMat = getCADBodyMatrix(cadBodyId);\n    ivec2 bodyDescAddr = ftoi(cadBodyPixel0.ba);\n    mat4 surfaceMat = getDrawItemMatrix(bodyDescAddr, drawItemIndexInBody);\n    mat4 modelMatrix = bodyMat * surfaceMat;\n#else\n    mat4 modelMatrix = getModelMatrix();\n    // Note: on mobile GPUs, we get only FP16 math in the\n    // fragment shader, causing inaccuracies in modelMatrix\n    // calculation. By offsetting the data to the origin\n    // we calculate a modelMatrix in the asset space, and\n    //  then add it back on during final drawing.\n    // modelMatrix[3][0] += assetCentroid.x;\n    // modelMatrix[3][1] += assetCentroid.y;\n    // modelMatrix[3][2] += assetCentroid.z;\n#endif\n#endif\n    // modelMatrix = mat4(1.0);\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n    mat4 viewProjectionMatrix = projectionMatrix * viewMatrix;\n\n    //////////////////////////////////////////////\n    // Vertex Attributes\n    \n    GLSLBinReader surfaceLayoutDataReader;\n    GLSLBinReader_init(surfaceLayoutDataReader, surfaceAtlasLayoutTextureSize, 16);\n    vec4 surfaceDataAddr = GLSLBinReader_readVec4(surfaceLayoutDataReader, surfaceAtlasLayoutTexture, surfaceId * 8);\n    int surfaceFlags = GLSLBinReader_readInt(surfaceLayoutDataReader, surfaceAtlasLayoutTexture, surfaceId * 8 + 6);\n\n    bool isFan = int(quadDetail.y) == 0;\n    vec2 vertexCoords = texCoords * (isFan ? vec2(quadDetail) + vec2(1.0, 1.0) : vec2(quadDetail));\n\n    vec3 normal = getSurfaceNormal(surfaceDataAddr.xy, vertexCoords);\n    vec4 pos = vec4(getSurfaceVertex(surfaceDataAddr.xy, vertexCoords).rgb, 1.0);\n\n    bool flippedNormal = testFlag(surfaceFlags, SURFACE_FLAG_FLIPPED_NORMAL);\n    if(flippedNormal){\n        normal = -normal;\n    }\n  \n    vec4 worldPos = modelMatrix * pos;\n    vec3 worldNormal = normalize(mat3(modelMatrix) * normal);\n\n    // if (positions.z > 0.5)\n    //   worldPos = vec4(vec3(0.0), 1.0);\n    worldPos += vec4(worldNormal * positions.z * normalLength, 0.0);\n    \n    gl_Position = viewProjectionMatrix * worldPos;\n\n    \n    v_textureCoord = texCoords;\n    if(testFlag(surfaceFlags, SURFACE_FLAG_FLIPPED_UV))\n        v_textureCoord = vec2(v_textureCoord.y, v_textureCoord.x);\n\n    // v_textureCoord.y = 1.0 - v_textureCoord.y; // Flip y\n}'),Ye=I.parseShader("GLDrawCADSurfaceNormalsShader.fragmentShader",'\nprecision highp float;\n\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="materialparams.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n\nuniform color BaseColor;\n\nuniform mat4 cameraMatrix;\n\nvarying vec4 v_drawCoords;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_textureCoord;\n\n<%include file="GLSLCADSurfaceDrawing.fragmentShader.glsl"/>\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n\n    int cadBodyId = int(floor(v_drawCoords.r + 0.5));\n    int drawItemIndexInBody = int(floor(v_drawCoords.g + 0.5));\n    int surfaceId = int(floor(v_drawCoords.b + 0.5));\n    int trimSetId = int(floor(v_drawCoords.a + 0.5));\n\n    // TODO: pass as varying from pixel shader.\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\n    int flags = int(floor(cadBodyPixel0.g + 0.5));\n            \n\n    //////////////////////////////////////////////\n    // Cutaways\n    if (testFlag(flags, BODY_FLAG_CUTAWAY)) {\n        vec4 cadBodyPixel6 = getCADBodyPixel(cadBodyId, 6);\n        vec3 cutNormal = cadBodyPixel6.xyz;\n        float cutPlaneDist = cadBodyPixel6.w;\n        if (cutaway(v_worldPos, cutNormal, cutPlaneDist)) {\n            discard;\n        }\n    }\n\n    //////////////////////////////////////////////\n    // Trimming\n    vec4 trimPatchQuad;\n    vec3 trimCoords;\n    if(trimSetId >= 0) {\n        GLSLBinReader trimsetLayoutDataReader;\n        GLSLBinReader_init(trimsetLayoutDataReader, trimSetsAtlasLayoutTextureSize, 16);\n        trimPatchQuad = GLSLBinReader_readVec4(trimsetLayoutDataReader, trimSetsAtlasLayoutTexture, trimSetId*4);\n\n        if(applyTrim(trimPatchQuad, trimCoords, flags)){\n            discard;\n            return;\n        }\n    }\n\n    vec4 baseColor      = vec4(1.0,0.0,0.0,1.0);\n\n//#ifdef ENABLE_INLINE_GAMMACORRECTION\n    fragColor.rgb = toGamma(baseColor.rgb);\n//#endif\n\n}\n');class Oe extends Me{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ze,this.__shaderStages.FRAGMENT_SHADER=Ye,this.nonSelectable=!0,this.finalize()}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"BaseColor",defaultValue:new Color(1,1,.5)}),e}}p.register("GLDrawCADSurfaceNormalsShader",Oe);class We extends F{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=I.parseShader("GLDrawTrimCurveFansShader.vertexShader",'\nprecision highp float;\n\nattribute float vertexIds;\ninstancedattribute vec4 patchCoords;         // instanced attribute..\ninstancedattribute vec4 data0;     // instanced attribute..\ninstancedattribute vec4 data1;     // instanced attribute..\ninstancedattribute vec2 data2;     // instanced attribute..\n\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLMath.glsl"/>\n\nuniform sampler2D curvesAtlasTexture;\nuniform ivec2 curvesAtlasTextureSize;\n\nuniform ivec2 trimSetAtlasTextureSize;\n\nuniform int numCurveVertices;\n\nstruct CurveRef {\n  int curveId;\n  vec2 tr;\n  mat2 mat;\n  int flags;\n\n  ivec2 addr;\n  int numCurveVertices;\n\n};\n\nvec2 getCurveVertex(in CurveRef curveRef, int vertexId) {\n    if(curveRef.flags != 0)\n      vertexId = curveRef.numCurveVertices - vertexId - 1;\n    return curveRef.tr + curveRef.mat * fetchTexel(curvesAtlasTexture, curvesAtlasTextureSize, ivec2(curveRef.addr.x + vertexId, curveRef.addr.y)).rg;\n}\n\n\nuniform sampler2D curvesAtlasLayoutTexture;\nuniform ivec2 curvesAtlasLayoutTextureSize;\n\nuniform sampler2D trimSetTexture;\nuniform ivec2 trimSetTextureSize;\n\n\n<%include file="GLSLBinReader.glsl"/>\n\nCurveRef getCurveRef(inout GLSLBinReader trimsetDataReader, in int curveRefStart, inout GLSLBinReader curvesAtlasLayoutDataReader) {\n\n  CurveRef curveRef;\n\n  // Get the Curve Id from the trimSet Atlas\n  curveRef.curveId = GLSLBinReader_readInt(trimsetDataReader, trimSetTexture, curveRefStart + 0);\n\n  // Get the Xfo for the curve\n  curveRef.tr = vec2(\n    GLSLBinReader_readFloat(trimsetDataReader, trimSetTexture, curveRefStart + 1), \n    GLSLBinReader_readFloat(trimsetDataReader, trimSetTexture, curveRefStart + 2)\n    );\n  curveRef.mat = mat2(\n    vec2(\n      GLSLBinReader_readFloat(trimsetDataReader, trimSetTexture, curveRefStart + 3), \n      GLSLBinReader_readFloat(trimsetDataReader, trimSetTexture, curveRefStart + 4)\n    ),\n    vec2(\n      GLSLBinReader_readFloat(trimsetDataReader, trimSetTexture, curveRefStart + 5), \n      GLSLBinReader_readFloat(trimsetDataReader, trimSetTexture, curveRefStart + 6)\n    ));\n\n  // Get the flags for the curve\n  curveRef.flags = GLSLBinReader_readInt(trimsetDataReader, trimSetTexture, curveRefStart + 7);\n\n\n  curveRef.addr = ivec2(\n    GLSLBinReader_readInt(curvesAtlasLayoutDataReader, curvesAtlasLayoutTexture, (curveRef.curveId * 8) + 0), \n    GLSLBinReader_readInt(curvesAtlasLayoutDataReader, curvesAtlasLayoutTexture, (curveRef.curveId * 8) + 1)\n    );\n  curveRef.numCurveVertices = GLSLBinReader_readInt(curvesAtlasLayoutDataReader, curvesAtlasLayoutTexture, (curveRef.curveId * 8) + 2);\n\n  return curveRef;\n}\n\n\n\nvoid main(void) {\n\n  vec2 pos;\n  int vertexId = ftoi(vertexIds);\n  if(vertexId == 0) {\n    pos = (patchCoords.xy + patchCoords.zw * 0.5) / vec2(trimSetAtlasTextureSize);\n  }\n  else {\n    vertexId--;\n\n    CurveRef curveRef;\n    curveRef.tr = data0.xy;\n    curveRef.mat = mat2(data0.zw, data1.xy);\n    curveRef.flags = ftoi(data2.x);\n\n    curveRef.addr = ivec2(ftoi(data1.z), ftoi(data1.w));\n    curveRef.numCurveVertices = numCurveVertices;\n\n    //////////////////////////////////////////////\n    pos = getCurveVertex(curveRef, vertexId);\n\n    /*\n    //////////////////////////////////////////////\n    \n    int loopStartPos = ftoi(data0.x);\n    int curveIndexWithLoop = ftoi(data0.y);\n\n    GLSLBinReader trimsetDataReader;\n    GLSLBinReader_init(trimsetDataReader, trimSetTextureSize, 16);\n    int numCurves = GLSLBinReader_readInt(trimsetDataReader, trimSetTexture, loopStartPos);\n\n    GLSLBinReader curvesAtlasLayoutDataReader;\n    GLSLBinReader_init(curvesAtlasLayoutDataReader, curvesAtlasLayoutTextureSize, 32);\n\n    CurveRef curveRef = getCurveRef(trimsetDataReader, loopStartPos + 1 + (curveIndexWithLoop * 8), curvesAtlasLayoutDataReader);\n    pos = getCurveVertex( curveRef, vertexId );\n\n\n    // Tranform the curve points by the xfo2d to put it into the coords of the trim set.\n    Xfo2d xfo2d = Xfo2d(data0.xy, data1.x, data0.zw);\n    pos = Xfo2D_transformVec2(xfo2d, pos);\n\n\n    //////////////////////////////////\n    // Due to the reduced precision we use to store our data\n    // we get cracks in the trim textures. To fix this we weld\n    // the end points of the trim curves here.\n    // For each end point of a curve, we find the joining end point \n    // and average their positions.\n\n    if(vertexId == 0) {\n      // Lookup the vertex of the previous curve.\n      int prevCurveIndexWithinLoop = curveIndexWithLoop - 1;\n      if(prevCurveIndexWithinLoop < 0)\n        prevCurveIndexWithinLoop += numCurves;\n      CurveRef prevCurveRef = getCurveRef(trimsetDataReader, loopStartPos + 1 + (prevCurveIndexWithinLoop * 8), curvesAtlasLayoutDataReader);\n\n      // Get the end of the previous curve.\n      vec2 prevCurveEndPos = getCurveVertex( prevCurveRef, prevCurveRef.numCurveVertices-1 );\n\n      pos = (pos + prevCurveEndPos) * 0.5;\n    }\n    else if(vertexId == numCurveVertices-1) {\n      // Lookup the vertex of the next curve.\n      int nextCurveIndexWithinLoop = curveIndexWithLoop + 1;\n      if(nextCurveIndexWithinLoop >= numCurves)\n        nextCurveIndexWithinLoop = 0;\n      CurveRef nextCurveRef = getCurveRef(trimsetDataReader, loopStartPos + 1 + (nextCurveIndexWithinLoop * 8), curvesAtlasLayoutDataReader);\n\n      // Get the start of the next curve.\n      vec2 nextCurveEndPos = getCurveVertex( nextCurveRef, 0 );\n      pos = (pos + nextCurveEndPos) * 0.5;\n    }\n\n    */\n    //////////////////////////////////////////////\n\n\n    // Now transform the trim set into the coords of the full texture.\n    pos = (patchCoords.xy + (pos * patchCoords.zw));\n    pos /= vec2(trimSetAtlasTextureSize);\n  }\n\n  // transform the position into clip space.\n  gl_Position = vec4(vec2(-1.0, -1.0) + (pos * 2.0), 0.0, 1.0);\n}\n'),this.__shaderStages.FRAGMENT_SHADER=I.parseShader("GLDrawTrimCurveFansShader.fragmentShader","\nprecision highp float;\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n\n    fragColor = vec4(1.0/255.0,0.0,0.0,1.0);\n    \n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n"),this.finalize()}}p.register("GLDrawTrimCurveFansShader",We);class ke extends F{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=I.parseShader("GLFlattenTrimSetsShader.vertexShader","\nprecision highp float;\n\nattribute vec4 positions;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n    v_texCoord = (positions.xy + 0.5);\n    gl_Position =  vec4(positions.xy * 2.0, 0.0, 1.0);\n}\n"),this.__shaderStages.FRAGMENT_SHADER=I.parseShader("GLFlattenTrimSetsShader.fragmentShader","\nprecision highp float;\n\nuniform sampler2D trimSetAtlasTexture;\nuniform ivec2 trimSetAtlasTextureSize;\n\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n\n// returns true if the texel will be kept\n// When the fans are rendered, the pixels are acumulated. \n// An even number means that the pixel should be discarded\n// and an odd number mean the pixel should be kept.\nbool sampleAtlas(vec2 offset){\n    return mod(texture2D(trimSetAtlasTexture, v_texCoord + (offset / vec2(trimSetAtlasTextureSize))).r * 255.0, 2.0) > 0.5;\n}\n\nint scoreAtlas(vec2 offset){\n  if(sampleAtlas(offset))\n    return 1;\n  else\n    return 0;\n}\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n\n  // if(sampleAtlas(vec2(0.0, 0.0))){\n  //   fragColor = vec4(1.0, 0.5, 0.5, 1.0);\n  // }\n  // else{\n  //   fragColor = vec4(0.0, 0.5, 0.5, 1.0);\n  // }\n  \n  // Smoothing. Look at neighboring pixels to see\n  // if we should fill in the gaps. Due to floating\n  // point issues, we see random pixels floating\n  // in the air that shold have been trimmed by the\n  // fan. If a point \n  int score = scoreAtlas(vec2(-1.0, 0.0)) + \n              scoreAtlas(vec2(-1.0,-1.0)) + \n              scoreAtlas(vec2( 0.0,-1.0)) + \n              scoreAtlas(vec2( 1.0,-1.0)) + \n              scoreAtlas(vec2( 1.0, 0.0)) + \n              scoreAtlas(vec2( 1.0, 1.0)) + \n              scoreAtlas(vec2( 0.0, 1.0)) + \n              scoreAtlas(vec2(-1.0, 1.0));\n\n  float r = 0.0;\n  if(sampleAtlas(vec2(0.0, 0.0))){\n    if(score >= 4) // corner verts have a score of 3\n      r = 1.0;\n    else\n      r = 0.0;\n  }\n  else{\n    if(score < 4) \n      r = 0.0;\n    else\n      r = 1.0;\n  }\n  fragColor = vec4(r, r, 0.0, 0.0);\n  \n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n"),this.finalize()}}p.register("GLFlattenTrimSetsShader",ke);class Ke extends F{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=I.parseShader("GLDrawTrimCurveStripsShader.vertexShader",'\nprecision highp float;\n\nattribute vec4 positions;\ninstancedattribute vec4 patchCoords;         // instanced attribute..\ninstancedattribute vec4 data0;     // instanced attribute..\ninstancedattribute vec4 data1;     // instanced attribute..\ninstancedattribute vec3 data2;     // instanced attribute..\n\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLMath.glsl"/>\n\nuniform sampler2D curvesAtlasTexture;\nuniform ivec2 trimSetAtlasTextureSize;\n\nuniform int numCurveVertices;\nuniform float stripWidth;\n\nvec2 getCurveVertex(int vertexId, int flags) {\n  if(flags != 0)\n    vertexId = numCurveVertices - vertexId - 1;\n  return fetchTexel(curvesAtlasTexture, trimSetAtlasTextureSize, ivec2(int(data1.z) + vertexId, int(data1.w))).rg;\n}\n\n#define M_PI 3.1415926535897932384626433832795\n\n/* VS Outputs */\nvarying float v_curveIndexWithinLoop;\nvarying float v_gradient;\n\nvoid main(void) {\n\n  int vertexId = ftoi(positions.x);\n  float side = positions.y < 0.0 ? -1.0 : 1.0;\n  mat2 rot = mat2(data0.zw, data1.xy);\n  int curveRefFlags = ftoi(data2.x);\n  int curveIndexWithinLoop = ftoi(data2.y);\n  v_curveIndexWithinLoop = float(curveIndexWithinLoop);\n\n  // Tranform the curve points by the mat2 to put it into the coords of the trim set.\n  vec2 pos = data0.xy + (rot * getCurveVertex(vertexId, curveRefFlags));\n\n  //////////////////////////////////////////////\n  vec2 curveTangent;\n  if(vertexId > 0) {\n    vec2 posPrev = data0.xy + (rot * getCurveVertex(vertexId-1, curveRefFlags));\n    curveTangent += pos - posPrev;\n  }\n  if(vertexId < numCurveVertices-1) {\n    vec2 posNext = data0.xy + (rot * getCurveVertex(vertexId+1, curveRefFlags));\n    curveTangent += posNext - pos;\n  }\n  curveTangent = normalize(curveTangent);\n  vec2 curveNormal = vec2(-curveTangent.y, curveTangent.x);\n\n  // Fatten the strip\n  pos += (curveNormal * side * stripWidth) / patchCoords.zw;\n\n  //////////////////////////////////////////////\n  // Extend the strip by one pixel at each end.\n  if(vertexId == 0) {\n    pos -= curveTangent * (stripWidth / patchCoords.zw) * 0.5;\n  }\n  else if(vertexId == numCurveVertices-1) {\n    pos += curveTangent * (stripWidth / patchCoords.zw) * 0.5;\n  }\n  //////////////////////////////////////////////\n\n  // Now transform the trim set into the coords of the full texture.\n  pos = (patchCoords.xy + (pos * patchCoords.zw));\n  pos /= vec2(trimSetAtlasTextureSize);\n\n  // transform the position into clip space.\n  gl_Position = vec4((pos * 2.0) - 1.0, 0.0, 1.0);\n  \n\n  // The gradient should run 0.0 ... 1.0 from one side of the strip to the other.\n  // The side value ranges from -1.0 to +1.0\n\n  v_gradient = (side + 1.0) / 2.0;\n  // v_gradient = 1.0;\n\n  // Note: this causes the trim edge to move slightly to grow.\n  // This fills in slight gaps betwen trimmed surfaces.\n  // This causes lots of atrifacts on some thin surfaces\n  // On Mordacious, this causese many artifacts at the border of surfaces.\n  // v_gradient = (v_gradient * 1.1) + 0.05;\n  // v_gradient = (v_gradient * 1.2) + 0.1;\n  // v_gradient = (v_gradient * 1.5) + 0.25;\n  // v_gradient = (v_gradient * 2.0) + 0.5;\n  // v_gradient = (v_gradient * 2.0) + 1.0;\n}\n'),this.__shaderStages.FRAGMENT_SHADER=I.parseShader("GLDrawTrimCurveStripsShader.fragmentShader",'\nprecision highp float;\n\n<%include file="GLSLUtils.glsl"/>\n\nuniform int flatten;\n\n/* VS Outputs */\nvarying float v_curveIndexWithinLoop;\nvarying float v_gradient;\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  // Initially a build up the data around the edges by rasterizing a full color pixel,\n  // followed by a subtractive pass that cuts down the borders\n  //\n  // Initially, after the fans are rasterized \n  //     ----\n  //  .  |  .\n  //  .  |  .\n  //     ----\n  //\n  // Becomes \n  //  -------\n  //  .     .\n  //  .     .\n  //  -------\n  //\n  // Becomes \n  //    . ---\n  //    ./     \n  //   /. \n  //  -------\n  // After the subtraction pass\n\n\n  \n  if (flatten > 0) {\n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n  } else {\n    int curveIndexWithinLoop = ftoi(v_curveIndexWithinLoop);\n    if (curveIndexWithinLoop % 2 == 0) {\n      fragColor = vec4(v_gradient, 1.0, 1.0, 1.0);\n    }\n    else {\n      fragColor = vec4(1.0, v_gradient, 1.0, 1.0);\n    }\n  }\n    \n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize()}}p.register("GLDrawTrimCurveStripsShader",Ke);class He extends F{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=I.parseShader("GLDebugTrimSetsShader.vertexShader","\nprecision highp float;\n\nattribute vec4 positions;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n    v_texCoord = (positions.xy + 0.5);\n    gl_Position =  vec4(positions.xy * 2.0, 0.0, 1.0);\n    // gl_Position =  vec4(positions.xy + vec2(-0.5, 0.5), 0.0, 1.0);\n}\n"),this.__shaderStages.FRAGMENT_SHADER=I.parseShader("GLDebugTrimSetsShader.fragmentShader","\nprecision highp float;\n\nuniform sampler2D trimSetAtlasTexture;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec4 col = texture2D(trimSetAtlasTexture, v_texCoord);\n  vec3 rgb = col.rgb / col.a;\n  fragColor = vec4(rgb,1.0);\n  \n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n"),this.finalize()}}p.register("GLDebugTrimSetsShader",He);class Qe extends F{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=I.parseShader("GLEvaluateCADCurveShader.vertexShader","\nprecision highp float;\n\nattribute vec3 positions;\ninstancedattribute vec4 patchCoords;         // where the values will be written to in the target texture.\ninstancedattribute vec2 curveDataCoords;     // where the data will come from in the source texture\n\nuniform ivec2 curvesAtlasTextureSize;\n\n/* VS Outputs */\nvarying vec2 v_geomDataCoords;\nvarying vec2 v_patchSize;\nvarying vec2 v_vertexCoord;\n\n\n\nvoid main(void) {\n\n  vec2 patchPos = patchCoords.xy;\n  v_patchSize = patchCoords.zw;\n\n  v_geomDataCoords = curveDataCoords;\n  v_vertexCoord = (positions.xy + 0.5) * v_patchSize;\n\n  vec2 pos = (patchPos + v_vertexCoord) / vec2(curvesAtlasTextureSize);\n  gl_Position =  vec4((pos - 0.5) * 2.0, 0.0, 1.0);\n}\n"),this.__shaderStages.FRAGMENT_SHADER=I.parseShader("GLEvaluateCADCurveShader.fragmentShader",'\n// #extension GL_EXT_draw_buffers : require\nprecision highp float;\n\n/* VS Outputs */\nvarying vec2 v_geomDataCoords;\nvarying vec2 v_patchSize;\nvarying vec2 v_vertexCoord;\n\n\nstruct PosNorm {\n  vec3 pos;\n  vec3 normal;\n  int geomType;\n};\n\n\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLMath.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="GLSLCADCurves.glsl"/>\n<%include file="GLSLNURBS.glsl"/>\n<%include file="GLSLNURBSCurves.glsl"/>\n\nuniform sampler2D curveDataTexture;\nuniform ivec2 curveDataTextureSize;\nuniform int writeTangents;\n\nPosNorm evalCADCurves(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  int geomType = GLSLBinReader_readInt(reader, texture);\n\n  // PosNorm result;\n  // result.pos = vec3(float(geomType));\n  // // fragColor = reader.buffer;\n  // // fragColor = vec4(float(reader.textureSize.x), float(reader.textureSize.y), float(geomType), 1.0);\n  // return result;\n\n\n  if(geomType == CURVE_TYPE_LINE) {\n      return calcLinePoint(params.x, reader, texture);\n  } \n  if(geomType == CURVE_TYPE_CIRCLE) {\n      return calcCirclePoint(params.x, reader, texture);\n  } \n  if(geomType == CURVE_TYPE_ELIPSE) {\n      return calcElipsePoint(params.x, reader, texture);\n  }\n  if(geomType == CURVE_TYPE_NURBS_CURVE) {\n      return calcNURBSCurve3dPoint(params.x, reader, texture);\n  } \n  \n  PosNorm detault;\n  return detault;\n}\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n\n  // Evaluate the curve per vertex\n\n  // compute exact xy coords per pixel by rounding the vertex coord to the nearest integer and then dividing my patch size.\n  // The interpollated xy coords from the quad are not exact because the quad must cover the pixels with some margin.\n\n  // The quad overlaps the pixels by half a pixel, so \n  vec2 params = vec2(floor(v_vertexCoord.x), floor(v_vertexCoord.y));\n  if(v_patchSize.x > 1.0)\n      params.x /= v_patchSize.x - 1.0;\n  // if(v_patchSize.y > 1.0)\n  //     params.y /= v_patchSize.y - 1.0;\n\n  ivec4 region = ivec4(0, 0, curveDataTextureSize.x, curveDataTextureSize.y);\n  ivec2 start = ivec2(int(v_geomDataCoords.x), int(v_geomDataCoords.y));\n\n  GLSLBinReader reader;\n  GLSLBinReader_init(reader, curveDataTextureSize, region, start, 32);\n  PosNorm posNorm = evalCADCurves(params, reader, curveDataTexture);\n\n  if(writeTangents == 1) {\n      fragColor = vec4(posNorm.normal, 1.0);\n  }\n  else {\n      fragColor = vec4(posNorm.pos, 1.0);\n  }\n  // fragColor = vec4(params.x, params.y, 0.0, 1.0);\n  // gl_FragData[0] = vec4(posNorm.pos, 1.0);\n  // gl_FragData[1] = vec4(posNorm.normal, 1.0);\n\n  // fragColor.r = v_geomDataCoords.x;\n  // fragColor.g = v_geomDataCoords.y;\n  // fragColor.b = float(curveDataTextureSize.x);\n  // fragColor.a = float(curveDataTextureSize.y);\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize()}}p.register("GLEvaluateCADCurveShader",Qe);const Je=I.parseShader("GLDrawCADSurfaceShader.vertexShader",'\nprecision highp float;\n\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="stack-gl/inverse.glsl"/>\n\nattribute vec3 positions;\ninstancedattribute vec4 drawCoords;  // body ID, Surface index in Body, Surface Id, TrimSet Id\n// instancedattribute vec2 drawItemTexAddr;  // Address of the data in the draw item texture. (mat4)\n\nuniform mat4 viewMatrix;\nuniform mat4 cameraMatrix;\nuniform mat4 projectionMatrix;\nuniform ivec2 quadDetail;\nuniform vec3 assetCentroid;\n\n// #define DEBUG_SURFACES\nuniform int numSurfacesInLibrary;\n\n\n<%include file="GLSLCADSurfaceDrawing.vertexShader.glsl"/>\n\nvarying vec4 v_drawCoords;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_textureCoord;\nvarying vec3 v_bodyDescAddr;\nvarying float v_surfaceType;\nvarying vec2 v_quadDetail;\n\nvoid main(void) {\n    int cadBodyId = ftoi(drawCoords.r);\n    int drawItemIndexInBody = ftoi(drawCoords.g);\n    int surfaceId = ftoi(drawCoords.b);\n    int trimSetId = ftoi(drawCoords.a);\n\n    vec2 texCoords = positions.xy + 0.5;\n    \n    v_drawCoords = drawCoords;\n\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\n    vec4 cadBodyPixel1 = getCADBodyPixel(cadBodyId, 1);\n\n    // int bodyDescId = ftoi(cadBodyPixel0.r);\n    int cadBodyFlags = ftoi(cadBodyPixel0.g);\n    \n    //////////////////////////////////////////////\n    // Visibility\n    if(testFlag(cadBodyFlags, BODY_FLAG_INVISIBLE)) {\n        gl_Position = vec4(-3.0, -3.0, -3.0, 1.0);;\n        return;\n    }\n\n    //////////////////////////////////////////////\n    // Transforms\n#ifdef DEBUG_SURFACES\n    mat4 modelMatrix = mat4(1.0);\n    // if(v_surfaceType == SURFACE_TYPE_NURBS_SURFACE) {\n    //     // int drawItemIndexInBody = int(metadata.b+0.5);\n    //     int sideLen = int(ceil(sqrt(float(numSurfacesInLibrary))));\n    //     int x = drawItemIndexInBody % sideLen;\n    //     int y = drawItemIndexInBody / sideLen;\n    //     modelMatrix = mat4(1.0, 0.0, 0.0, 0.0, \n    //                     0.0, 1.0, 0.0, 0.0, \n    //                     0.0, 0.0, 1.0, 0.0,  \n    //                     float(x), float(y), 0.0, 1.0);\n    // }\n#else\n\n#ifdef CALC_GLOBAL_XFO_DURING_DRAW\n    mat4 bodyMat = getCADBodyMatrix(cadBodyId);\n    ivec2 bodyDescAddr = ftoi(cadBodyPixel0.ba);\n    v_bodyDescAddr.xy = vec2(float(bodyDescAddr.x), float(bodyDescAddr.y));\n    v_bodyDescAddr.z = float(drawItemIndexInBody);\n    mat4 surfaceMat = getDrawItemMatrix(bodyDescAddr, drawItemIndexInBody);\n    mat4 modelMatrix = bodyMat * surfaceMat;\n#else\n    mat4 modelMatrix = getModelMatrix();\n    // Note: on mobile GPUs, we get only FP16 math in the\n    // fragment shader, causing inaccuracies in modelMatrix\n    // calculation. By offsetting the data to the origin\n    // we calculate a modelMatrix in the asset space, and\n    //  then add it back on during final drawing.\n    // modelMatrix[3][0] += assetCentroid.x;\n    // modelMatrix[3][1] += assetCentroid.y;\n    // modelMatrix[3][2] += assetCentroid.z;\n#endif\n#endif\n    // modelMatrix = mat4(1.0);\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n    mat3 normalMatrix = mat3(transpose(inverse(modelViewMatrix)));\n\n    //////////////////////////////////////////////\n    // Vertex Attributes\n    \n    GLSLBinReader surfaceLayoutDataReader;\n    GLSLBinReader_init(surfaceLayoutDataReader, surfaceAtlasLayoutTextureSize, 16);\n    vec4 surfaceDataAddr = GLSLBinReader_readVec4(surfaceLayoutDataReader, surfaceAtlasLayoutTexture, surfaceId * 8);\n    int surfaceFlags = GLSLBinReader_readInt(surfaceLayoutDataReader, surfaceAtlasLayoutTexture, surfaceId * 8 + 6);\n\n    bool isFan = int(quadDetail.y) == 0;\n    vec2 vertexCoords = texCoords * (isFan ? vec2(quadDetail) + vec2(1.0, 1.0) : vec2(quadDetail));\n    vec4 surfaceVertex = getSurfaceVertex(surfaceDataAddr.xy, vertexCoords);\n    v_surfaceType = surfaceVertex.a;\n    vec3 normal  = getSurfaceNormal(surfaceDataAddr.xy, vertexCoords);\n    vec4 pos     = vec4(surfaceVertex.rgb, 1.0);\n    \n    bool flippedNormal = testFlag(surfaceFlags, SURFACE_FLAG_FLIPPED_NORMAL);\n    if(flippedNormal)\n        normal = -normal;\n\n    vec4 viewPos = modelViewMatrix * pos;\n    v_viewPos    = viewPos.xyz;\n    v_worldPos   = (modelMatrix * pos).xyz;\n    gl_Position  = projectionMatrix * viewPos;\n    v_viewNormal = normalMatrix * normal;\n\n    v_quadDetail = vec2(quadDetail);\n\n    {\n        // Pull back facing vertices towards us ever so slightly...\n        // This is to avoid z-fighting that occurs wehn we see the inside\n        // of a surface that is resting on another surface.\n        vec3 worldNormal = normalize(mat3(cameraMatrix) * v_viewNormal);\n\n        vec3 viewVector = normalize(mat3(cameraMatrix) * normalize(-v_viewPos));\n        float ndotv = dot(worldNormal, viewVector);\n        bool backFacing = ndotv <= 0.0;\n        if (backFacing) {\n            // Pull backfacing vertices towards us ever so slightly...\n            gl_Position.z *= 0.99999;\n        }\n    }\n\n    if(isFan) {\n        // We are drawing a Fan surface, so the uv coords\n        // simply come from the vertex positions.\n        v_textureCoord = positions.xy;\n    }\n    else {\n        v_textureCoord = texCoords;\n        if(testFlag(surfaceFlags, SURFACE_FLAG_FLIPPED_UV)) {\n            v_textureCoord = vec2(v_textureCoord.y, v_textureCoord.x);\n            v_quadDetail = vec2(v_quadDetail.y, v_quadDetail.x);\n        }\n\n        // v_textureCoord.y = 1.0 - v_textureCoord.y; // Flip y\n    }\n}'),je=I.parseShader("GLDrawCADSurfaceShader.fragmentShader",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="materialparams.glsl"/>\n<%include file="GGX_Specular.glsl"/>\n<%include file="PBRSurfaceRadiance.glsl"/>\n\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n\nuniform mat4 cameraMatrix;\n\nuniform bool headLighting;\nuniform bool displayWireframes;\nuniform bool displayEdges;\n\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\nuniform float exposure;\nuniform float gamma;\n#endif\n\nvarying vec4 v_drawCoords;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_textureCoord;\nvarying vec3 v_bodyDescAddr;\nvarying float v_surfaceType;\nvarying vec2 v_quadDetail;\n\nvec3 getDebugColor(int id){\n    \n    int sel = int(round(mod(float(id), 14.0)));\n    \n    if(sel==0)\n        return vec3(0.0, 1.0, 1.0);\n    else if (sel==1)\n        return vec3(0.0, 1.0, 0.0);\n    else if (sel==2)\n        return vec3(1.0, 0.0, 1.0);\n    else if (sel==3)\n        return vec3(0.75, 0.75, 0.0);\n    else if (sel==4)\n        return vec3(0.0, 0.75, 0.75);\n    else if (sel==5)\n        return vec3(0.75, 0.0, 0.75);\n    else if (sel==6)\n        return vec3(0.45, 0.95, 0.0);\n    else if (sel==7)\n        return vec3(0.0, 0.45, 0.95);\n    else if (sel==8)\n        return vec3(0.95, 0.0, 0.45);\n    else if (sel==9)\n        return vec3(0.95, 0.45, 0.0);\n    else if (sel==10)\n        return vec3(0.0, 0.95, 0.45);\n    else if (sel==11)\n        return vec3(0.45, 0.0, 0.95);\n    else if (sel==12)\n        return vec3(0.45, 0.45, 0.95);\n    else if (sel==13)\n        return vec3(0.0, 0.0, 0.45);\n    else if (sel==14)\n        return vec3(0.0, 0.45, 0.45);\n    else if (sel==15)\n        return vec3(0.45, 0.0, 0.45);\n    else return vec3(0.2, 0.2, 0.2);\n}\n\n<%include file="GLSLCADSurfaceDrawing.fragmentShader.glsl"/>\n\n// const float gridSize = 0.02;\nconst float gridSize = 0.2;\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n    \n    int cadBodyId = int(floor(v_drawCoords.r + 0.5));\n    int drawItemIndexInBody = int(floor(v_drawCoords.g + 0.5));\n    int surfaceId = int(floor(v_drawCoords.b + 0.5));\n    int trimSetId = int(floor(v_drawCoords.a + 0.5));\n\n\n    // TODO: pass as varying from pixel shader.\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\n    vec4 cadBodyPixel1 = getCADBodyPixel(cadBodyId, 1);\n\n    int flags = int(floor(cadBodyPixel0.g + 0.5));\n    vec2 materialCoords = cadBodyPixel1.xy;\n    //////////////////////////////////////////////\n    // Trimming\n    vec4 trimPatchQuad;\n    vec3 trimCoords;\n    if(trimSetId >= 0) {\n        GLSLBinReader trimsetLayoutDataReader;\n        GLSLBinReader_init(trimsetLayoutDataReader, trimSetsAtlasLayoutTextureSize, 16);\n        trimPatchQuad = GLSLBinReader_readVec4(trimsetLayoutDataReader, trimSetsAtlasLayoutTexture, trimSetId*4);\n\n        if(applyTrim(trimPatchQuad, trimCoords, flags)){\n            discard;\n            return;\n        }\n    }\n\n    ///////////////////////////////////////////\n    // Normal\n\n    vec3 normal = normalize(mat3(cameraMatrix) * v_viewNormal);\n    vec3 viewNormal = normalize(v_viewNormal);\n\n    vec3 viewVector = normalize(mat3(cameraMatrix) * normalize(-v_viewPos));\n    bool backFacing = dot(normal, viewVector) <= 0.0;\n    if(backFacing){\n        normal = -normal;\n        viewNormal = -viewNormal;\n    }\n\n    //////////////////////////////////////////////\n    // Material\n\n    vec4 matValue0 = getMaterialValue(materialCoords, 0);\n\n    MaterialParams material;\n\n    /////////////////\n    bool clayRendering = false;\n    if(clayRendering)\n        material.baseColor          = vec3(0.45, 0.26, 0.13);\n    else\n        material.baseColor          = matValue0.rgb;\n    \n    /////////////////\n    // Face color\n    #ifdef ENABLE_PER_FACE_COLORS\n    vec4 faceColor = getDrawItemColor(ftoi(v_bodyDescAddr.xy), ftoi(v_bodyDescAddr.z));\n    material.baseColor = mix(material.baseColor, faceColor.rgb, faceColor.a);\n    #endif\n\n    float opacity               = matValue0.a;\n        \n\n    //////////////////////////////////////////////\n    // Cutaways\n    // if (applyCutaway(cadBodyId, flags)) {\n    //     discard;\n    //     return;\n    // }\n    if (testFlag(flags, BODY_FLAG_CUTAWAY)) {\n        vec4 cadBodyPixel6 = getCADBodyPixel(cadBodyId, 6);\n        vec3 cutNormal = normalize(cadBodyPixel6.xyz);\n        float cutPlaneDist = cadBodyPixel6.w;\n        if (cutaway(v_worldPos, cutNormal, cutPlaneDist)) {\n            discard;\n            return;\n        }\n        // If we are not cutaway, but we can see a back facing face\n        // then set the normal to the cut plane do the lighting is flat.\n        if (backFacing){\n            normal = cutNormal;\n        }\n    }\n\n    vec3 irradiance ;\n#ifdef ENABLE_PBR\n    if (envMapPyramid_desc.x > 0.0) {\n        if (headLighting) {\n            irradiance = sampleEnvMap(viewNormal, 1.0);\n        } else {\n            irradiance = sampleEnvMap(normal, 1.0);\n        }\n    } else {\n#endif\n        float ndotv = dot(normal, viewVector);\n        irradiance = vec3(ndotv);\n#ifdef ENABLE_PBR\n    }\n#endif\n\n    /////////////////\n    // Debug backFacing\n    // if(backFacing) {\n    //     material.baseColor = mix(material.baseColor, vec3(1.0, 0.0, 0.0), 0.5);\n    // }\n\n    /////////////////\n    // Debug materialId\n#ifdef DEBUG_MATERIALID\n    {\n        material.baseColor = vec3(float(int(materialCoords.x) % 5)/5.0, float(int(materialCoords.y) % 5)/5.0, 0.0);\n    }\n#endif\n\n    /////////////////\n    // Debug bodyId\n#ifdef DEBUG_BODYID\n    {\n        material.baseColor       = getDebugColor(cadBodyId);\n    }\n#endif\n\n    /////////////////\n    // Debug drawItemIndexInBody\n#ifdef DEBUG_SURFACEID\n    {\n        material.baseColor       = getDebugColor(drawItemIndexInBody);\n    }\n#endif\n\n    /////////////////\n    // Debug surface Type\n#ifdef DEBUG_SURFACETYPE\n    {\n        material.baseColor       = getDebugColor(v_surfaceType);\n    }\n#endif\n\n    /////////////////\n    // bool flippedNormal = testFlag(flags, SURFACE_FLAG_FLIPPED_NORMAL);\n    // if(flippedNormal) {\n    //    material.baseColor = mix(material.baseColor, vec3(1,0,0), 0.75);\n    // }\n\n    // if (backFacing) {\n    //     material.baseColor = mix(material.baseColor, vec3(1,0,0), 0.75);\n    // }\n\n    /////////////////\n    // Debug UV layout.\n    // {\n    //     material.baseColor = vec3(v_textureCoord.x);\n    //     // material.baseColor.r = mix(0.0, 1.0, v_textureCoord.x);\n    //     // material.baseColor.g = mix(0.0, 1.0, v_textureCoord.y);\n    // }\n\n    /////////////////\n    // if(testFlag(flags, SURFACE_FLAG_FLIPPED_UV)){\n    //     material.baseColor = mix(material.baseColor, vec3(1,1,1), 0.5);\n    // }\n\n    /////////////////\n    // if(v_quadDetail.x > 512.0 || v_quadDetail.y > 512.0){\n    //     material.baseColor = mix(material.baseColor, vec3(1,0,0), 0.75);\n    // } else {\n    //     // discard;\n    // }\n    \n    /////////////////\n    // Debug trim texture.\n#ifdef DEBUG_TRIMTEXELS\n    if(trimCoords.x >= 0.0) {\n        // trimCoords = (trimPatchQuad.xy + 0.5) + ((trimPatchQuad.zw - 0.5) * v_textureCoord);\n        trimCoords.xy = trimPatchQuad.xy + (trimPatchQuad.zw * v_textureCoord);\n        vec2 trimUv = (trimCoords.xy) / vec2(trimSetAtlasTextureSize);\n        vec4 trimTexel = texture2D(trimSetAtlasTexture, trimUv);\n\n        vec2 texelOffset = trimCoords.xy - (floor(trimCoords.xy) + 0.5);\n        float texelDist = length(texelOffset);\n        \n        material.baseColor = trimTexel.rgb * texelDist;\n\n        // if (trimTexel.r > 0.5 && trimTexel.g > 0.5) {\n        //     material.baseColor = vec3(0,0,0);\n        // }\n\n        // material.baseColor = mix(material.baseColor, vec3(0,0,0), texelDist);\n        // material.baseColor = mix(material.baseColor, vec3(0,0,0), trimCoords.z);\n        // material.baseColor = mix(material.baseColor, vec3(0,0,0), (trimCoords.z < 0.5) ? 1.0 : 0.0);\n\n        // if(trimCoords.z < 0.5) {\n        //     material.baseColor = mix(material.baseColor, vec3(0,0,0), 0.1);\n        // }\n        // else{\n        //     float total = floor(trimCoords.x) +\n        //                   floor(trimCoords.y);\n        //     if(mod(total,2.0)==0.0)\n        //         material.baseColor = mix(material.baseColor, vec3(0,0,0), 0.25);\n        //     else\n        //         material.baseColor = mix(material.baseColor, vec3(1,1,1), 0.25);\n        // }\n    }\n#endif\n\n\n    \n    //////////////////////////////////////////////\n    // Transparency\n    // Simple screen door transparency.\n    // float threshold = gridSize * opacity * (1.0 - (v_viewPos.z / 300.0));\n    // // if(mod(v_viewPos.x / v_viewPos.z, gridSize) > threshold || mod(v_viewPos.y/v_viewPos.z, gridSize) > threshold)// || mod(v_viewPos.z, gridSize) > threshold)\n    // if(mod(abs(v_worldPos.x), gridSize) > threshold || mod(abs(v_worldPos.y), gridSize) > threshold || mod(abs(v_worldPos.z), gridSize) > threshold)\n    //     discard;\n\n\n    ///////////////////////////////////////////\n    // Lighting\n    vec3 radiance;\n\n    vec4 matValue1;\n    if(clayRendering)\n        matValue1          = vec4(0.0, 1.0, 0.0, 0.0);\n    else\n        matValue1          = getMaterialValue(materialCoords, 1);\n\n    material.metallic       = matValue1.r;\n    material.roughness      = matValue1.g;\n    material.reflectance    = matValue1.b;\n    float emissive          = matValue1.a;\n\n#ifdef ENABLE_PBR\n    if (envMapPyramid_desc.x > 0.0) {\n        if (headLighting) {\n            // Calculate PBR Reflection based on a screen space vecotr for both the noramal and the view vector.\n            radiance = pbrSurfaceRadiance(material, irradiance, viewNormal, normalize(-v_viewPos));\n        } else {\n            radiance = pbrSurfaceRadiance(material, irradiance, normal, viewVector);\n        }\n\n        // vec3 reflectionVector = reflect(-viewVector, normal);\n        // vec3 envColor = sampleEnvMap(reflectionVector, material.roughness);\n        // radiance = irradiance;\n    } else {\n#endif\n        // Simple diffuse lighting.\n        radiance = irradiance * material.baseColor;\n#ifdef ENABLE_PBR\n    }\n#endif\n\n    fragColor = vec4(mix(radiance, material.baseColor, emissive), 1.0);\n\n    /////////////////////////////\n    // fragColor = vec4(irradiance * material.baseColor, 1.0);\n    // fragColor = vec4(material.baseColor, 1.0);\n    // fragColor = vec4( normalize(viewNormal), 1.0);\n    // fragColor = vec4( normalize(normal), 1.0);\n\n    // fragColor = vec4(sampleEnvMap(viewNormal, material.roughness), 1.0);;\n    \n    ////////////////////\n    {\n        // vec4 wireColor = vec4(0.1, 0.1, 0.1, 1.0);\n        //vec4 wireColor = vec4(0.6, 0.6, 0.6, 1.0);\n        vec4 wireColor = vec4(0.0, 0.0, 0.0, 1.0);\n        \n        vec2 vertexCoords = v_textureCoord * v_quadDetail;\n        vec2 vcD = fwidth(vertexCoords);\n        vec2 vcW = fract(vertexCoords);\n\n        bool isFan = v_quadDetail.y < 0.5;\n        if(displayWireframes) {\n            if (isFan) {\n\n            } else {\n        \n                float lerpVal = smoothstep(0.0, vcD.x, vcW.x) * smoothstep(1.0, 1.0 - vcD.x, vcW.x) * smoothstep(0.0, vcD.y, vcW.y) * smoothstep(1.0, 1.0 - vcD.y, vcW.y);\n                \n                // Display a thin line at 50% opacity.\n                fragColor = mix(fragColor, wireColor, (1.0-smoothstep(0.0, 0.5, lerpVal)) * 0.5 );\n        \n                //fragColor = mix(fragColor, wireColor, (mod(vertexCoords.x, 2.0) < 1.0) ? 0.5 : 0.0 );\n            }\n        }\n\n    //     vec2 tcD = fwidth(v_textureCoord);\n    //     vec2 tcW = fract(v_textureCoord);\n    //     vec2 tpD = fwidth(trimPatchQuad.xy);\n    //     if(displayEdges) {   \n    //         if (isFan) {\n\n    //         } else {\n    //             if(trimPatchQuad.x >= 0.0) {\n    //                 if (trimPatchQuad.z < 1.0) {\n    //                     float stripBoundaryH = 0.5;\n    //                     float stripWidth = 2.0;\n\n    //                     float pixelWidth = ((tpD.x + tpD.y) * 0.5) / stripWidth;\n    //                     float minLimit = stripBoundaryH + pixelWidth * 0.5;\n    //                     float maxLimit = stripBoundaryH + pixelWidth * 0.75;\n                        \n    //                     float lerpVal;\n    //                     if (maxLimit < 1.0) {\n    //                         lerpVal = smoothstep(maxLimit, minLimit, trimPatchQuad.z);\n    //                     } else {\n    //                         // If the strip width is less then one screen pixel, then \n    //                         // we just interpollate over the width of the strip. \n    //                         lerpVal = 1.0 - smoothstep(0.75, 1.0, trimPatchQuad.z);\n    //                     }\n    //                     fragColor = mix(fragColor, wireColor, lerpVal);\n    //                 }\n    //             } \n    //             else {\n    //                 float lerpVal = smoothstep(0.0, tcD.x, tcW.x) * smoothstep(1.0, 1.0 - tcD.x, tcW.x) * smoothstep(0.0, tcD.y, tcW.y) * smoothstep(1.0, 1.0 - tcD.y, tcW.y);\n    //                 fragColor = mix(fragColor, wireColor, 1.0 - lerpVal);\n    //             }\n    //         }\n    //     }\n    }\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n    fragColor.rgb = toGamma(fragColor.rgb * exposure, gamma);\n#endif\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n');p.register("GLDrawCADSurfaceShader",class extends Me{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Je,this.__shaderStages.FRAGMENT_SHADER=je,this.finalize()}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"BaseColor",defaultValue:new d(1,1,.5)}),e.push({name:"EmissiveStrength",defaultValue:0}),e.push({name:"Metallic",defaultValue:0}),e.push({name:"Roughness",defaultValue:.25}),e.push({name:"Normal",defaultValue:new d(0,0,0)}),e.push({name:"TexCoordScale",defaultValue:1,texturable:!1}),e.push({name:"Reflectance",defaultValue:.025}),e}static getPackedMaterialData(e){const t=new Float32Array(8),r=e.getParameter("BaseColor").getValue();return t[0]=r.r,t[1]=r.g,t[2]=r.b,t[3]=r.a,e.getParameter("EmissiveStrength")?(t[4]=e.getParameter("Metallic").getValue(),t[5]=e.getParameter("Roughness").getValue(),t[6]=e.getParameter("Reflectance").getValue(),t[7]=e.getParameter("EmissiveStrength").getValue()):t[5]=1,t}});const qe=I.parseShader("GLDrawCADSurfaceGeomDataShader.fragmentShader",'\nprecision highp float;\n\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n\nuniform int passIndex;\nuniform int assetIndex;\n\nvarying vec4 v_drawCoords;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_textureCoord;\nvarying float v_surfaceType;\nvarying vec2 v_quadDetail;\n\n<%include file="GLSLCADSurfaceDrawing.fragmentShader.glsl"/>\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n\n    int cadBodyId = int(floor(v_drawCoords.r + 0.5));\n    int surfaceIndexInBody = int(floor(v_drawCoords.g + 0.5));\n    int surfaceId = int(floor(v_drawCoords.b + 0.5));\n    int trimSetId = int(floor(v_drawCoords.a + 0.5));\n\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\n    int flags = int(floor(cadBodyPixel0.g + 0.5));\n\n    //////////////////////////////////////////////\n    // Cutaways\n    if (testFlag(flags, BODY_FLAG_CUTAWAY)) {\n        vec4 cadBodyPixel6 = getCADBodyPixel(cadBodyId, 6);\n        vec3 cutNormal = cadBodyPixel6.xyz;\n        float cutPlaneDist = cadBodyPixel6.w;\n        if (cutaway(v_worldPos, cutNormal, cutPlaneDist)) {\n            discard;\n        }\n    }\n\n    //////////////////////////////////////////////\n    // Trimming\n    vec4 trimPatchQuad;\n    vec3 trimCoords;\n    if(trimSetId >= 0) {\n        GLSLBinReader trimsetLayoutDataReader;\n        GLSLBinReader_init(trimsetLayoutDataReader, trimSetsAtlasLayoutTextureSize, 16);\n        trimPatchQuad = GLSLBinReader_readVec4(trimsetLayoutDataReader, trimSetsAtlasLayoutTexture, trimSetId*4);\n\n        if(applyTrim(trimPatchQuad, trimCoords, flags)){\n            discard;\n            return;\n        }\n    }\n\n    float dist = length(v_viewPos);\n\n    int passAndAssetIndex = passIndex + (assetIndex * 64);\n\n    fragColor.r = float(passAndAssetIndex);\n    fragColor.g = float(cadBodyId);\n    fragColor.b = float(surfaceIndexInBody);\n    fragColor.a = dist;\n    \n    // fragColor.b = float(v_surfaceType);\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n');class $e extends Me{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Je,this.__shaderStages.FRAGMENT_SHADER=qe,this.nonSelectable=!0,this.finalize()}}p.register("GLDrawCADSurfaceGeomDataShader",$e);const et=I.parseShader("GLDrawSelectedCADSurfaceShader.fragmentShader",'\nprecision highp float;\n\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n\nvarying vec4 v_drawCoords;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_textureCoord;\nvarying float v_surfaceType;\nvarying vec2 v_quadDetail;\n\n<%include file="GLSLCADSurfaceDrawing.fragmentShader.glsl"/>\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n    \n    int cadBodyId = int(floor(v_drawCoords.r + 0.5));\n    int surfaceIndexInBody = int(floor(v_drawCoords.g + 0.5));\n    int surfaceId = int(floor(v_drawCoords.b + 0.5));\n    int trimSetId = int(floor(v_drawCoords.a + 0.5));\n\n    // TODO: pass as varying from pixel shader.\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\n    int flags = int(floor(cadBodyPixel0.g + 0.5));\n            \n\n    //////////////////////////////////////////////\n    // Cutaways\n    if (testFlag(flags, BODY_FLAG_CUTAWAY)) {\n        vec4 cadBodyPixel6 = getCADBodyPixel(cadBodyId, 6);\n        vec3 cutNormal = cadBodyPixel6.xyz;\n        float cutPlaneDist = cadBodyPixel6.w;\n        if (cutaway(v_worldPos, cutNormal, cutPlaneDist)) {\n            discard;\n        }\n    }\n\n    //////////////////////////////////////////////\n    // Trimming\n    vec4 trimPatchQuad;\n    vec3 trimCoords;\n    if(trimSetId >= 0) {\n        GLSLBinReader trimsetLayoutDataReader;\n        GLSLBinReader_init(trimsetLayoutDataReader, trimSetsAtlasLayoutTextureSize, 16);\n        trimPatchQuad = GLSLBinReader_readVec4(trimsetLayoutDataReader, trimSetsAtlasLayoutTexture, trimSetId*4);\n\n        if(applyTrim(trimPatchQuad, trimCoords, flags)){\n            discard;\n            return;\n        }\n    }\n    \n    vec4 highlightColor = getCADBodyPixel(cadBodyId, 5);\n    fragColor = highlightColor;\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n');class tt extends Me{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Je,this.__shaderStages.FRAGMENT_SHADER=et,this.nonSelectable=!0,this.finalize()}}p.register("GLDrawSelectedCADSurfaceShader",tt);const rt=I.parseShader("GLDrawCADCurveShader.vertexShader",'\nprecision highp float;\n\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="stack-gl/inverse.glsl"/>\n\nattribute vec3 positions;\ninstancedattribute vec4 drawCoords;  // body ID, Surface index in Body, Surface Id, TrimSet Id\n// instancedattribute vec2 drawItemTexAddr;  // Address of the data in the draw item texture. (mat4)\n\nuniform mat4 viewMatrix;\nuniform mat4 cameraMatrix;\nuniform mat4 projectionMatrix;\nuniform int edgeDetail;\nuniform vec3 assetCentroid;\n\n\n// #define DEBUG_SURFACES\nuniform int numCurvesInLibrary;\n\n\n<%include file="GLSLCADGeomDrawing.vertexShader.glsl"/>\n\n// GEOM\nuniform sampler2D curvesAtlasLayoutTexture;\nuniform ivec2 curvesAtlasLayoutTextureSize;\n\n\nuniform sampler2D curvesAtlasTexture;\nuniform ivec2 curvesAtlasTextureSize;\n// uniform sampler2D normalsTexture;\n\nvec3 getCurveVertex(ivec2 addr, int vertexId) {\n  return fetchTexel(curvesAtlasTexture, curvesAtlasTextureSize, ivec2(addr.x + vertexId, addr.y)).rgb;\n}\n\n// vec3 getCurveTangent(vec2 surfacePatchCoords, vec2 vertexCoord) {\n//   return fetchTexel(normalsTexture, curvesAtlasTextureSize, ivec2(ftoi(surfacePatchCoords.x + vertexCoord.x), ftoi(surfacePatchCoords.y + vertexCoord.y))).rgb;\n// }\n\nvarying vec4 v_drawCoords;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\n\nvoid main(void) {\n    int cadBodyId = ftoi(drawCoords.r);\n    int drawItemIndexInBody = ftoi(drawCoords.g);\n    int curveId = ftoi(drawCoords.b);\n    int trimSetId = ftoi(drawCoords.a);\n    v_drawCoords = drawCoords;\n\n    vec2 texCoords = positions.xy;\n\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\n    vec4 cadBodyPixel1 = getCADBodyPixel(cadBodyId, 1);\n\n    // int bodyDescId = ftoi(cadBodyPixel0.r);\n    int flags = ftoi(cadBodyPixel0.g);\n\n    // vec4 metadata = getDrawItemData(0);\n    // ivec4 curveAtlasCoords = ftoi(getDrawItemData(2));\n    // int flags = int(floor(metadata.a + 0.5));\n\n    //////////////////////////////////////////////\n    // Visibility\n    if(testFlag(flags, BODY_FLAG_INVISIBLE)) {\n        gl_Position = vec4(-3.0, -3.0, -3.0, 1.0);;\n        return;\n    }\n\n    //////////////////////////////////////////////\n    // Transforms\n#ifdef DEBUG_SURFACES\n    mat4 modelMatrix = mat4(1.0);\n    int numCurvesInLibrary = 15;\n    // int sideLen = int(ceil(sqrt(float(numCurvesInLibrary))));\n    // int x = curveId % sideLen;\n    // int y = curveId / sideLen;\n    modelMatrix = mat4(1.0, 0.0, 0.0, 0.0, \n                    0.0, 1.0, 0.0, 0.0, \n                    0.0, 0.0, 1.0, 0.0,  \n                    float(curveId), float(0), 0.0, 1.0);\n#else\n\n#ifdef CALC_GLOBAL_XFO_DURING_DRAW\n    mat4 bodyMat = getCADBodyMatrix(cadBodyId);\n    ivec2 bodyDescAddr = ftoi(cadBodyPixel0.ba);\n    Xfo surfaceXfo = getDrawItemXfo(bodyDescAddr, drawItemIndexInBody);\n    mat4 modelMatrix = bodyMat * xfo_toMat4(surfaceXfo);\n\n    // v_sc = surfaceXfo.sc;\n    //if (v_sc.z > 0.0) {\n    //  gl_Position = vec4(-3.0, -3.0, -3.0, 1.0);;\n    //  return;\n    //}\n#else\n    mat4 modelMatrix = getModelMatrix();\n    // Note: on mobile GPUs, we get only FP16 math in the\n    // fragment shader, causing inaccuracies in modelMatrix\n    // calculation. By offsetting the data to the origin\n    // we calculate a modelMatrix in the asset space, and\n    //  then add it back on during final drawing.\n    // modelMatrix[3][0] += assetCentroid.x;\n    // modelMatrix[3][1] += assetCentroid.y;\n    // modelMatrix[3][2] += assetCentroid.z;\n#endif\n#endif\n    // modelMatrix = mat4(0.001, 0.0, 0.0, 0.0, \n    //   0.0, 0.001, 0.0, 0.0, \n    //   0.0, 0.0, 0.001, 0.0,  \n    //   0.0, 0.0, 0.0, 1.0);\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n    //////////////////////////////////////////////\n    // Vertex Attributes\n    \n    GLSLBinReader curvesLayoutDataReader;\n    GLSLBinReader_init(curvesLayoutDataReader, curvesAtlasLayoutTextureSize, 16);\n    vec4 curveDataAddr = GLSLBinReader_readVec4(curvesLayoutDataReader, curvesAtlasLayoutTexture, curveId * 8);\n\n    int vertexId = int(positions.x * float(edgeDetail));\n    vec4 pos     = vec4(getCurveVertex(ftoi(curveDataAddr.xy), vertexId), 1.0);\n    // vec4 pos     = vec4(positions * float(edgeDetail), 1.0);\n\n    // if (vertexId == 0)\n    //   pos = vec4(vec3(0.0), 1.0);\n\n    vec4 viewPos = modelViewMatrix * pos;\n    v_viewPos    = viewPos.xyz;\n    v_worldPos   = (modelMatrix * pos).xyz;\n    gl_Position  = projectionMatrix * viewPos;\n\n    {\n        // Pull edge vertices towards us ever so slightly...\n        gl_Position.z *= 0.99999;\n    }\n}'),at=I.parseShader("GLDrawCADCurveShader.fragmentShader",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="materialparams.glsl"/>\n<%include file="GGX_Specular.glsl"/>\n<%include file="PBRSurfaceRadiance.glsl"/>\n\n<%include file="GLSLCADConstants.glsl"/>\n\nuniform mat4 cameraMatrix;\n\nuniform bool headLighting;\nuniform bool displayWireframes;\nuniform bool displayEdges;\nuniform vec4 edgeColor;\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\nuniform float exposure;\nuniform float gamma;\n#endif\n\nvarying vec4 v_drawCoords;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\n\n<%include file="GLSLCADGeomDrawing.fragmentShader.glsl"/>\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n\n    int cadBodyId = int(floor(v_drawCoords.r + 0.5));\n    int drawItemIndexInBody = int(floor(v_drawCoords.g + 0.5));\n    int curveId = int(floor(v_drawCoords.b + 0.5));\n\n    // TODO: pass as varying from pixel shader.\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\n    int flags = int(floor(cadBodyPixel0.g + 0.5));\n            \n\n    //////////////////////////////////////////////\n    // Cutaways\n    if (testFlag(flags, BODY_FLAG_CUTAWAY)) {\n        vec4 cadBodyPixel6 = getCADBodyPixel(cadBodyId, 6);\n        vec3 cutNormal = cadBodyPixel6.xyz;\n        float cutPlaneDist = cadBodyPixel6.w;\n        if (cutaway(v_worldPos, cutNormal, cutPlaneDist)) {\n            discard;\n            return;\n        }\n    }\n\n    fragColor = edgeColor;\n\n    // fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    // if (v_sc.x < 0.0) {\n    //   fragColor.r = 1.0;\n    // }\n    // if (v_sc.y < 0.0) {\n    //   fragColor.g = 1.0;\n    // }\n    // if (v_sc.z < 0.0) {\n    //   fragColor.b = 1.0;\n    // }\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n    fragColor.rgb = toGamma(fragColor.rgb * exposure, gamma);\n#endif\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n');class nt extends Me{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=rt,this.__shaderStages.FRAGMENT_SHADER=at,this.finalize()}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"BaseColor",defaultValue:new d(1,1,.5)}),e.push({name:"EmissiveStrength",defaultValue:0}),e.push({name:"Metallic",defaultValue:0}),e.push({name:"Roughness",defaultValue:.25}),e.push({name:"Normal",defaultValue:new d(0,0,0)}),e.push({name:"TexCoordScale",defaultValue:1,texturable:!1}),e.push({name:"Reflectance",defaultValue:.025}),e}static getPackedMaterialData(e){const t=new Float32Array(8),r=e.getParameter("BaseColor").getValue();return t[0]=r.r,t[1]=r.g,t[2]=r.b,t[3]=r.a,e.getParameter("EmissiveStrength")?(t[4]=e.getParameter("Metallic").getValue(),t[5]=e.getParameter("Roughness").getValue(),t[6]=e.getParameter("Reflectance").getValue(),t[7]=e.getParameter("EmissiveStrength").getValue()):t[5]=1,t}}p.register("GLDrawCADCurveShader",nt);class st extends P{constructor(e=!1){super(),this.debugMode=e,this.headLighting=!1,this.displayWireframes=!1,this.displaySurfaces=!0,this.__displayEdges=0,this.displayNormals=!1,this.normalLength=.002,this.debugTrimTex=!1,this.debugSurfaceAtlas=!1,this.debugAssetId=0,this.__assets=[],this.__loadQueue=0,this.__numHighlightedGeoms=0,this.__dirtyBodyDrawItemsIndices=[],this.__shaderCount=2,this.__shaderKeys={},this.__shaderOptsStack=[{}],this.__profiling={numSurfaces:0,numSurfaceInstances:0,surfaceEvalTime:0,numBodies:0,numMaterials:0,numTriangles:0,numDrawSets:0}}get displayEdges(){return this.__displayEdges>0}set displayEdges(e){1==e?this.__displayEdges++:this.__displayEdges--,this.emit("updated")}init(e,t){super.init(e,t),this.__dataLoadStartTime=performance.now();const r=e.gl,a=new Pe(r);a.on("updated",()=>this.emit("updated"));const n=[new Ne(r),new ze(r),new Xe(r)];if(c.isIOSDevice)throw new Error("The ZeaCAD cannnot be supported on iOS due to no ability to render to a FLOAT framebuffer.");const s="Safari"==c.browserName;"webgl2"!=r.name&&this.setShaderPreprocessorValue("#extension GL_OES_standard_derivatives : enable"),this.debugMode&&this.setShaderPreprocessorValue("#define DEBUG_MODE"),this.setShaderPreprocessorValue("#define ENABLE_TRIMMING"),this.setShaderPreprocessorValue("#define ENABLE_INLINE_GAMMACORRECTION"),c.deviceCategory,this.__cadpassdata={debugMode:this.debugMode,convertTo8BitTextures:s,assetCount:0,materialLibrary:a,evaluateCurveShader:new Qe(r),evaluateSurfaceShaders:n,trimCurveFansShader:new We(r),flattenTrimSetsShader:new ke(r),trimCurveStripsShader:new Ke(r),debugTrimSetsShader:new He(r),updateDrawItemsShader:this.__updateDrawItemsShader,glplanegeom:new C(r,new i(1,1,1,1)),maxTexSize:c.gpuDesc.maxTextureSize,incHighlightedCount:this.incHighlightedCount.bind(this),decHighlightedCount:this.decHighlightedCount.bind(this),incDisplayEdges:()=>{this.__displayEdges++,this.emit("updated")},decDisplayEdges:()=>{this.__displayEdges--,this.emit("updated")},genShaderID:e=>{if(!(e in this.__shaderKeys)){const t=p.getBlueprint(e);if(!t||!t.getPackedMaterialData)return this.__cadpassdata.genShaderID("GLDrawCADSurfaceShader");const a=this.applyOptsToShader(p.constructClass(e,r)),n=this.__shaderCount;return this.__shaderKeys[e]={id:n,shader:a},this.__shaderCount++,n}return this.__shaderKeys[e].id}},this.__cadpassdata.genShaderID("GLDrawCADSurfaceShader"),this.__decrementLoadQueue=()=>{this.__loadQueue--,0==this.__loadQueue&&(console.log("===All Assets Loaded==="),console.log("Total Load Time:"+(performance.now()-this.__gpuLoadStartTime)/1e3),this.__profiling.numTriangles=this.__profiling.numTriangles/1e6,console.log(this.__profiling),this.emit("updated"))},this.__renderer.registerPass((e,t)=>{if(e instanceof _e){const r=e;return this.__loadQueue++,this.__cadpassdata.assetCount++,r.isLoaded()?r.getNumBodyItems()>0?this.addCADAsset(r):this.__decrementLoadQueue():r.once("loaded",()=>{r.getNumBodyItems()>0?this.addCADAsset(r):this.__decrementLoadQueue()}),t.continueInSubTree=!0,!0}return!1},e=>e instanceof _e&&(this.removeCADAsset(e),!0))}getShaderPreprocessorValue(e){return this.getShaderState()[e]}setShaderPreprocessorValue(e,t=!0){e.startsWith("#")||(e="#define "+e),this.getShaderState()[e]=e;for(const r in this.__shaderKeys){const a=this.__shaderKeys[r];a.shader.setPreprocessorValue&&(a.shader.setPreprocessorValue(e),t&&a.shader.applyOptions())}this.__drawSelectedCADSurfaceShader&&(this.__drawSelectedCADSurfaceShader.setPreprocessorValue(e),t&&this.__drawSelectedCADSurfaceShader.applyOptions()),this.__drawCADSurfaceGeomDataShader&&(this.__drawCADSurfaceGeomDataShader.setPreprocessorValue(e),t&&this.__drawCADSurfaceGeomDataShader.applyOptions()),this.__updateDrawItemsShader&&(this.__updateDrawItemsShader.setPreprocessorValue(e),t&&this.__updateDrawItemsShader.applyOptions()),this.__renderer&&this.__renderer.requestRedraw()}clearShaderPreprocessorValue(e,t=!0){delete this.getShaderState()[e];for(const r in this.__shaderKeys){const a=this.__shaderKeys[r];a.shader.clearPreprocessorValue&&(a.shader.clearPreprocessorValue(e),t&&a.shader.applyOptions())}this.__renderer&&this.__renderer.requestRedraw()}applyOptsToShader(e){if(e.setPreprocessorValue){const t=this.getShaderState();for(const r in t)e.setPreprocessorValue(r);e.applyOptions()}return e}getShaderState(){return this.__shaderOptsStack[this.__shaderOptsStack.length-1]}pushShaderState(){this.__shaderOptsStack.push(Object.assign({},this.getShaderState()));for(const e in this.__shaderKeys){const t=this.__shaderKeys[e];t.shader.pushState&&t.shader.pushState()}}popShaderState(){this.__shaderOptsStack.pop();for(const e in this.__shaderKeys){const t=this.__shaderKeys[e];t.shader.popState&&t.shader.popState()}}startPresenting(){"High"!=c.deviceCategory&&this.pushShaderState()}stopPresenting(){"High"!=c.deviceCategory&&this.popShaderState()}getCutPlaneNormalParam(){return this.__cutPlaneNormalParam}getCutPlaneDistParam(){return this.__cutDistParam}getCutPlaneColorParam(){return this.__cutPlaneColorParam}incHighlightedCount(e){this.__numHighlightedGeoms+=e}decHighlightedCount(e){this.__numHighlightedGeoms-=e}addCADAsset(e){this.__gl.finish();const t=this.__assets.length;0==t&&(this.__gpuLoadStartTime=performance.now()),e.getVersion().greaterThan([0,0,26])&&this.setShaderPreprocessorValue("#define INTS_PACKED_AS_2FLOAT16"),e.getVersion().greaterOrEqualThan([0,0,29])&&this.setShaderPreprocessorValue("#define ENABLE_PER_FACE_COLORS"),e.getVersion().compare([1,0,5])>=0&&this.setShaderPreprocessorValue("#define ENABLE_BODY_EDGES");const r=new Fe(this.__gl,t,e,this.__cadpassdata);r.once("loaded",e=>{this.__profiling.numSurfaces+=e.numSurfaces,this.__profiling.numSurfaceInstances+=e.numSurfaceInstances,this.__profiling.surfaceEvalTime+=e.surfaceEvalTime,this.__profiling.numBodies+=e.numBodies,this.__profiling.numMaterials+=e.numMaterials,this.__profiling.numTriangles+=e.numTriangles,this.__profiling.numDrawSets+=e.numDrawSets,this.__decrementLoadQueue()}),r.on("updated",()=>this.emit("updated")),this.__assets.push(r)}removeCADAsset(e){this.__assets=this.__assets.filter(t=>t.getCADAsset()!=e||(t.destroy(),!1)),this.emit("updated")}getGLCADAsset(e){return this.__assets[e]}__updateViewXfo(e){const t=e.ori.getZaxis().negate(),r=e.tr.subtract(this.__prevViewXfo.tr);this.__moveThreshold=.2;const a=r.length();if(a>this.__moveThreshold){const e=t.toJSON(),n=r.toJSON(),s=t=>{t.onViewChanged(cameraXfoJSON,e,n,a)};this.__assets.forEach(s),this.__prevViewXfo=cameraXfo}}draw(e){const t=this.__gl;if(this.debugTrimTex&&this.__assets.length>this.debugAssetId&&this.__assets[this.debugAssetId].drawTrimSets(e),this.debugSurfaceAtlas)this.__assets.length>this.debugAssetId&&this.__assets[this.debugAssetId].drawSurfaceAtlas(e);else{if(this.displaySurfaces){this.__cadpassdata.materialLibrary.needsUpload()&&this.__cadpassdata.materialLibrary.uploadMaterials();for(const r in this.__shaderKeys){const a=this.__shaderKeys[r];if(a.shader.bind(e),e.shaderId=a.id,!this.__cadpassdata.materialLibrary.bind(e))return!1;e.unifs.headLighting&&t.uniform1i(e.unifs.headLighting.location,this.headLighting),e.unifs.displayWireframes&&t.uniform1i(e.unifs.displayWireframes.location,this.displayWireframes);const n=e.boundTextures;for(const t of this.__assets)t.draw(e),e.boundTextures=n;a.shader.unbind(e)}}if(this.displayNormals){if(this.__drawCADSurfaceNormalsShader||(this.__drawCADSurfaceNormalsShader=this.applyOptsToShader(new Oe(t))),!this.__drawCADSurfaceNormalsShader.bind(e))return!1;t.uniform1f(e.unifs.normalLength.location,this.normalLength);const r=this.__shaderKeys.GLDrawCADSurfaceShader.id,a=e.boundTextures;for(const t of this.__assets)t.drawNormals(e,r),e.boundTextures=a}if(this.__displayEdges>0){if(this.__drawCADCurvesShader||(this.__drawCADCurvesShader=this.applyOptsToShader(new nt(t))),!this.__drawCADCurvesShader.bind(e))return!1;t.uniform4f(e.unifs.edgeColor.location,.1,.1,.1,1),t.enable(t.BLEND),t.blendEquation(t.FUNC_ADD),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA);const r=e.boundTextures;for(const t of this.__assets)t.drawEdges(e,0),e.boundTextures=r;t.disable(t.BLEND)}}}drawHighlightedGeoms(e){if(0==this.__numHighlightedGeoms)return!1;const t=this.__gl;if(this.__drawSelectedCADSurfaceShader||(this.__drawSelectedCADSurfaceShader=this.applyOptsToShader(new tt(t))),!this.__drawSelectedCADSurfaceShader.bind(e))return!1;for(const t of this.__assets)t.drawHighlightedGeoms(e)}drawGeomData(e){const t=this.__gl;if(this.__drawCADSurfaceGeomDataShader||(this.__drawCADSurfaceGeomDataShader=this.applyOptsToShader(new $e(t))),!this.__drawCADSurfaceGeomDataShader.bind(e))return!1;t.disable(t.BLEND),t.disable(t.CULL_FACE),t.enable(t.DEPTH_TEST),t.depthFunc(t.LESS),t.depthMask(!0);const r=e.unifs.passIndex;r&&t.uniform1i(r.location,this.__passIndex);for(const t in this.__shaderKeys){if(!this.__shaderKeys[t].shader.nonSelectable){e.shaderId=this.__shaderKeys[t].id;for(const t of this.__assets)t.drawGeomData(e)}}}getGeomItemAndDist(e){const t=Math.round(e[0]/64),r=Math.round(e[1]),a=e[3];return{geomItem:this.__assets[t].getGeomItem(r),dist:a}}}export{ne as BODY_FLAG_CUTAWAY,se as BODY_FLAG_INVISIBLE,he as CADAssembly,_e as CADAsset,ce as CADBody,U as CADCurveTypes,N as CADSurfaceTypes,j as CURVE_FLAG_COST_IS_DETAIL,st as GLCADPass,re as SURFACE_FLAG_COST_IS_DETAIL_U,ae as SURFACE_FLAG_COST_IS_DETAIL_V,ee as SURFACE_FLAG_FLIPPED_NORMAL,te as SURFACE_FLAG_FLIPPED_UV,q as SURFACE_FLAG_PERIODIC_U,$ as SURFACE_FLAG_PERIODIC_V,K as drawItemShaderAttribsStride,Q as drawShaderAttribsStride,H as floatsPerSceneBody,M as geomLibraryHeaderSize,z as getCurveTypeName,X as getSurfaceTypeName,J as numValuesPerTrimSetCurveRef,Z as pixelsPerDrawItem,W as valuesPerCurveLibraryLayoutItem,Y as valuesPerCurveTocItem,k as valuesPerSurfaceLibraryLayoutItem,O as valuesPerSurfaceTocItem};
